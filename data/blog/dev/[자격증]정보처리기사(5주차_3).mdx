---
title: '[정보처리기사 자격증] 2.소프트웨어 개발 > 3장 제품소프트웨어 패키징 (WEEK 5)'
date: '2026-01-13'
tags: ['dev', 'license']
draft: false
summary: 정보처리기사 5주차 내용정리 - 제품소프트웨어 패키징
# https://velog.io/@alpaka206/40.-소프트웨어-사용자-매뉴얼-작성
---

import ImageWithCaption from '@/components/mdxComponents/ImageWithCaption'

### 1. 소프트웨어 패키징

1.  **소프트웨어 패키징의 개요**

    > 소프트웨어 패키징이란 모듈별로 생성된 실행 파일들을 묶어 배포용 설치 파일로 만드는 작업
    - 예시
      - 빌드된 파일을 실행할 수 있게 주변환경을 세팅하는것
      - .jar가 나왔을 때
        - 빌드만 된 상태
          - ```bash
             my-app.jar
            ```
          - 개발자 입장에서는 OK, 사용자 입장에서는 문제 많음
            - Java 설치여부 확인
            - 실행 명령 알아야함
            - 설정 파일 추가해야함
            - DB 주소 알아야함
            - 실행 스크립트 필요함
        - 패키징이 된 상태
          - ```txt
               MyApp/
               ├─ bin/
               │  ├─ start.sh
               │  └─ start.bat
               ├─ lib/
               │  └─ my-app.jar
               ├─ config/
               │  └─ application.yml
               ├─ docs/
               │  └─ user-manual.pdf
               └─ install.exe   (또는 install.sh)
            ```
          - 이 전체를 하나의 배포 패키지로 만드는 것
            - 실행 파일(.jar, .exe 등)을 설정 파일, 라이브러리, 문서, 스크립트와 함께 설치·배포 가능한 형태로 구성하는 것
            - 패키징 예시 3가지
              - ZIP 패키징 > MyApp.zip
              - 실행 스크립트 포함 패키징 > start.sh포함
              - 설치 프로그램 형태 > .exe, .msi, .pkg등의 설치 마법사 제공
    - 특징
      - 사용자 중심으로 진행이다
      - 소스 코드는 유지보수를 고려하여 모듈화 후 패키징
      - 다양한 사용자 환경에서 쉽게 설치·사용 가능하도록 일반적인 배포 형태로 제공

2.  **패키징 시 고려사항**
    1. 시스템 환경 정의
       - 운영체제(OS), CPU, 메모리 등 최소 실행 환경 명시
    2. UI 제공
       - UI는 시각적 자료와 함께 제공
       - 사용 매뉴얼과 일치하도록 구성
    3. 운영 및 관리 형태
       - 하드웨어와 함께 관리 가능한 Managed Service 형태 권장
    4. 보안 고려
       - 내부 콘텐츠 암호화
       - 보안 취약점 고려
    5. DRM 연동
       - 다른 콘텐츠·단말기와의 DRM(디지털 저작권 관리) 연동 고려
    6. 사용자 편의성
       - 불필요한 복잡성·비효율성 제거
    7. 암호화 알고리즘 적용
       - 제품 소프트웨어 특성에 적합한 암호화 알고리즘 적용

3.  ** 패키징 작업 순서**
    1. 패키징 주기 설정
       - 개발 방법론에 따라 다름
       - 애자일 기법: 보통 2~4주 주기
    2. 중간 패키징
       - 주기별 결과물 → 테스트 서버 배포
    3. 최종 패키징
       - 모든 개발 완료 후 최종 배포용 패키징
    4. 배포 방식
       - 온라인 배포
       - 운영 서버에 배포 파일 + 설치/사용 매뉴얼 등록
       - 사용자가 직접 다운로드
       - 오프라인 배포
       - CD-ROM / DVD / USB 등에 담아 제공

### 2. 디지털 저작관 관리(DRM: Digital Rights Management)

1.  **저작권의 개요**

    > 저작권이란 소설, 음악, 영상, 컴퓨터 프로그램 등 저작물에 대해 창작자가 가지는 배타적·독점적 권리
    - 컴퓨터 프로그램처럼 복제가 쉬운 저작물의 불법 복제·배포 방지를 위해 사용되는 기술

2.  **DRM 개요**

    > DRM이란 디지털 콘텐츠가 저작권자가 의도한 방식으로만 사용되도록 생성 → 유통 → 이용 전 과정에서 콘텐츠를 관리·보호하는 기술

3.  **DRM 패키징 개념**

    > DRM 패키징이란 콘텐츠를 그냥 파일로 배포하지 않고, 암호화 + 라이선스 정보 포함해서 통제 가능한 상태로 포장하는 것
    - 원본 콘텐츠가 아날로그인 경우 디지털 변환 후 DRM 패키징 수행
    - 패키저(Packager)가 콘텐츠를 암호화하여 배포 형태로 생성
    - 음원이나 문서와 같이 크기가 작은 경우에는 사용자가 콘텐츠를 요청하는 시점에서 실시간으로 패키징을 수행하고, 크기가 큰 경우에는 미리 패키징을 수행한 후 배포
    - 사용자가 콘텐츠를 사용하기 위해서는 클리어링 하우스에 등록된 라이선스 정보를 통해 사용자 인증과 콘텐츠 사용 권한 소유 여부를 확인받아야 한다.
    - 종량제 방식을 적용한 소프트웨어의 경우 클리어링 하우스를 통해 서비스의 실제 사용량을 측정하여 이용한 만큼의 요금을 부과한다.
    - 예시
      - `encrypted_content.drm`와 같이 .drm의 형태로 배포
      - 내부 컨텐츠
        - 암호화된 콘텐츠
        - 라이선스 정보
          - 사용 가능 기간
          - 재생 횟수
          - 허용 기기 수
        - 전자서명

4.  **DRM 구성 요소**
    | 구성 요소 | 설명 |
    | --------------- | --------------------------------- |
    | 클리어링 하우스 | 라이선스 발급, 키 관리, 결제 관리 |
    | 콘텐츠 제공자 | 저작권자 |
    | 패키저 | 콘텐츠 암호화 및 패키징 |
    | 콘텐츠 분배자 | 암호화 콘텐츠 유통 |
    | 콘텐츠 소비자 | 콘텐츠 구매·사용자 |
    | DRM 컨트롤러 | 이용 권한 통제 |
    | 보안 컨테이너 | 콘텐츠 원본 보호 |

5.  **DRM 기술 요소**
    | 기술 요소 | 설명 |
    | ----------------------- | ---------------------- |
    | 암호(Encryption) | 콘텐츠·라이선스 암호화 |
    | 키 관리(Key Management) | 암호화 키 저장·분배 |
    | 암호화 파일 생성 | 패키저 기술 |
    | 식별 기술 | 콘텐츠 식별 체계 |
    | 저작권 표현 | 라이선스 내용 표현 |
    | 정책 관리 | 라이선스 정책 관리 |
    | 크랙 방지 | 불법 사용 방지 |
    | 인증(Authentication) | 사용자 인증 |

### 3. 소프트웨어 설치 메뉴얼 작성

1.  **소프트웨어 설치 매뉴얼 개요**

    > 소프트웨어 설치 매뉴얼이란 개발 초기부터 적용된 기준과 사용자가 소프트웨어를 설치하는 데 필요한 모든 과정을 기록한 설명서·안내서
    - 핵심 포인트
      - 사용자 기준으로 작성
      - 설치 시작 → 완료까지 전 과정을 순서대로 설명
      - 설치 중 발생 가능한 오류 메시지 및 예외 상황을 별도로 분류하여 설명

2.  **설치 매뉴얼의 기본 구성 요소**
    - 반드시 포함되어야 할 항목
      - 목차
        - 전체 설치 과정을 순서대로 요약
        - 각 항목의 시작 페이지 번호 포함
      - 개요
        - 설치 매뉴얼의 주요 특징
        - 구성
        - 설치 방법 및 순서
      - 서문
        - 문서 이력 : 매뉴얼의 작성·수정 이력 관리
        - 설치 매뉴얼의 주석 : 주의사항(설치 시 반드시 알아야 하는 중요한 내용), 참고사항(사용자 환경·상황 중 설치에 영향을 미칠 수 있는 내용)
      - 기본 사항
        - 소프트웨어 개요 : 소프트웨어의 주요 기능 및 UI 설명
        - 설치 관련 파일 : 소프트웨어 설치에 필요한 파일 설명
        - 설치 아이콘(Installation) : 설치 아이콘 설명
        - 프로그램 삭제 : 프로그램 삭제 방법 설명
        - 관련 추가 정보 : 소프트웨어 이외의 관련 설치 프로그램 정보
3.  **설치 매뉴얼 작성 순서**
    1.  기능 식별
        - 소프트웨어가 무엇을 하는지, 개발 목적과 주요 기능 흐름을 정리
          - 매뉴얼에서 하는 일
            - 이 소프트웨어의 역할
            - 설치 후 무엇을 할 수 있는지
            - 전체 기능 흐름 요약
    2.  UI 분류
        - 설치 과정 중 등장하는 화면(UI) 을 단계별로 분류
          - 매뉴얼에서 하는 일
            - 설치 화면 순서 정리
            - 버튼, 체크박스, 옵션 설명
            - 화면 캡처와 설명 매칭
    3.  설치 파일 / 백업 파일 확인
        - 설치 과정에서 생성·변경되는 파일과 폴더를 확인
          - 매뉴얼에서 하는 일
            - 설치 위치
            - 생성되는 파일 목록
            - 기존 파일 덮어쓰기 여부
            - 백업 폴더 위치
    4.  Uninstall 절차 확인
        - 설치뿐 아니라 삭제 절차도 직접 검증
          - 매뉴얼에서 하는 일
            - Uninstall 실행 방법
            - 삭제 시 남는 파일 여부
            - 삭제 과정 단계별 설명
    5.  이상 Case 확인
        - 설치 중 발생 가능한 오류·예외 상황 점검
          - 매뉴얼에서 하는 일
            - 오류 메시지 정리
            - 발생 원인
            - 대처 방법
    6.  최종 매뉴얼 적용
        - 실제 사용자 기준으로 최종 검증 및 보완
          - 매뉴얼에서 하는 일
            - 설치 완료 메시지 추가
            - 완성본 매뉴얼 배포
            - 고객 지원 관련 내용 기록

### 4. 소프트웨어 버전 등록

1.  **소프트웨어 패키징 형상 관리(SCM: Software Configuration Management)**

    > 형상관리란 소프트웨어 개발 과정에서 발생하는 변경 사항을 체계적으로 관리하여 가시성과 추적성을 확보하고 품질과 생산성을 향상시키는 활동이다.
    - 형상관리 목적
      - 소프트웨어 변경 사항 추적 및 통제
      - 무분별한 변경 방지
      - 버그·수정 이력 관리
      - 개발 비용 절감
      - 개발 방해 요소 최소화
    - 형상관리 대상
      - 소스 코드
      - 프로젝트 계획서
      - 분석서
      - 설계서
      - 프로그램
      - 테스트 케이스
    - 대표적인 형상관리 도구
      - Git
      - CVS
      - Subversion(SVN)

2.  **형상관리의 중요성**
    - 변경 사항을 체계적으로 추적
    - 제품 소프트웨어의 무절제한 변경 방지
    - 버그 및 수정 사항 추적 가능
    - 소프트웨어는 형태가 없어 가시성이 부족 → 형상관리로 보완
    - 배포본 관리 용이
    - 다수 개발자 동시 개발 가능

3.  **형상관리 기능**
    | 기능 | 설명 |
    |--------------|------------------------------|
    | 형상 식별 | 형상 항목에 이름·관리번호 부여, 계층 구조로 관리 |
    | 버전 제어 | 여러 버전의 형상 항목을 관리 |
    | 형상 통제(변경 관리) | 변경 요구를 검토하여 기준선 반영 여부 결정 |
    | 형상 감사 | 기준선의 무결성 검증 및 공식 승인 |
    | 형상 기록(상태 보고) | 형상관리 결과를 기록·보고 |

4.  **소프트웨어 버전 등록 관련 주요 용어**
    | 용어 | 설명 |
    |------------------|-----------------------------|
    | 저장소 (Repository) | 최신 버전 파일 + 변경 이력 저장 장소 |
    | 가져오기 (Import) | 버전 관리 안 되던 파일을 처음으로 저장소에 등록 |
    | 체크아웃 (Check-Out) | 수정 위해 저장소에서 파일을 가져옴 |
    | 체크인 (Check-In) | 수정 완료 후 저장소에 새 버전으로 반영 |
    | 커밋 (Commit) | 체크인 시 충돌 발생하면 diff로 수정 후 갱신 |
    | 동기화 (Update) | 저장소의 최신 버전으로 작업 공간 갱신 |

5.  **소프트웨어 버전 등록 과정**
    1. 가져오기 (Import)
       - 버전 관리가 되지 않던 파일을 저장소에 최초 등록하는 단계
       - 최초 등록, 버전 관리 시작
    2. 인출 (Check-Out)
       - 저장소에 있는 파일을 수정하기 위해 개발자의 작업 공간으로 가져오는 단계
       - 수정 목적, 작업 공간으로 가져옴
    3. 예치 (Commit)
       - 수정한 파일을 설명과 함께 저장소에 반영하는 단계
       - 수정 완료 후 반영, 설명(메시지) 포함
    4. 동기화 (Update)
       - 커밋된 최신 버전으로 다른 개발자의 작업 공간을 갱신하는 단계
       - 최신 버전 유지, 작업 공간 갱신
    5. 차이 확인 (Diff)
       - 파일의 변경 이력을 비교하여 수정 전·후 차이를 확인하는 단계
       - 변경 이력 확인, 파일 간 차이 비교

### 5. 소프트웨어 버전 괸리 도구

1.  **소프트웨어 버전 관리**

    > 소프트웨어 개발 과정에서 소스 코드 및 관련 산출물의 변경 이력을 체계적으로 관리하기 위한 기법 및 도구
    - 관리 대상
      - 소스 코드
      - 라이브러리
      - 문서
      - 설정 파일

2.  **버전 관리 방식 분류**
    - | 구분            | 저장 위치      | 관리 주체 | 특징        |
      | --------------- | -------------- | --------- | ----------- |
      | 공유 폴더 방식  | 로컬 공유 폴더 | 사람      | 수동 관리   |
      | 클라이언트/서버 | 중앙 서버      | 서버      | 중앙 집중   |
      | 분산 저장소     | 로컬 + 원격    | 개발자    | 독립 + 협업 |
    1. 공유 폴더 방식
       - 여러 개발자가 하나의 공유 폴더를 이용해 파일을 주고받으며 버전을 관리하는 방식
       - 작업 흐름
         1. 개발자가 파일 수정
         2. 수정 완료 파일을 공유 폴더에 복사
         3. 담당자가 파일 수집
         4. 컴파일 및 테스트
         5. 문제 있으면 수정 요청
       - 특징 정리
         - 자동화 안됨
         - 충돌 관리 안됨
         - 변경 이력 관리 미흡
         - 파일 덮어쓰기 위험 높음
       - 초기 버전 관리 방식 / 소규모 개발에 적합
       - 대표 도구
         - SCCS
         - RCS
         - PVCS
         - QVCS
    2. 클라이언트 / 서버 방식
       - 중앙 서버에 모든 버전을 저장하고, 개발자는 서버에서 파일을 받아 작업하는 방식
       - 작업 흐름
         1. 서버 저장소(Repository)에 파일 저장
         2. 개발자가 서버에서 파일 Checkout
         3. 로컬에서 수정
         4. 수정 완료 후 Commit
         5. 서버에 반영
       - 특징 정리
         - 버전 관리가 중앙 서버에서 일괄 처리
         - 동일 파일 동시 수정 시 경고
         - 서버 장애 발생 시 개발 중단
       - 중앙 집중형 구조 / 서버 의존성 큼
       - 대표 도구
         - CVS
         - SVN(Subversion)
           - CVS의 단점을 개선한 클라이언트/서버 방식 버전 관리 도구
           - 핵심 특징
             - Apache Software Foundation 발표
             - 중앙 서버 구조
             - Revision 기반 버전 관리
             - Commit 시마다 Revision 번호 증가
             - 파일/디렉터리 이동·이름 변경 가능
         - CVSNT
         - Clear Case
         - CMVC
         - Perforce
    3. 분산 저장소 방식
       - 로컬 저장소에서도 버전 관리가 가능한 방식
       - 특징 정리
         - 원격 저장소 장애 시에도 작업 가능
         - 로컬에서 빠른 버전 관리
         - 협업 시 원격 저장소에 반영
       - 네트워크 의존도 낮음
       - 대표 도구
         - git
           - 리눅스 커널 개발을 위해 만들어진 분산 버전 관리 시스템
           - 핵심 특징
             - 로컬 저장소 + 원격 저장소 구조
             - 스냅샷 기반 버전 관리
             - 브랜치 생성·병합 자유로움
             - 빠른 처리 속도
    4. Git vs SVN
       - | 구분         | Git           | SVN           |
         | ------------ | ------------- | ------------- |
         | 저장 방식    | 분산 저장소   | 중앙 서버     |
         | 로컬에 이력  | ⭕ 있음       | ❌ 없음       |
         | 서버 장애 시 | 작업 가능     | 작업 불가     |
         | 버전 관리    | 로컬에서 수행 | 서버에서 수행 |
         | 대표 명령    | commit        | commit        |

### 6. 빌드 자동화 도구

1. **빌드(Build)란**

   > 빌드란 소스 코드 파일을 컴파일하고 여러 모듈을 묶어 실행 파일을 생성하는 과정이다.
   - 빌드에 포함되는 작업
     - 컴파일
     - 링크
     - 패키징
     - 테스트
     - 배포

2. **빌드 자동화 도구의 개요**

   > 빌드 자동화 도구란 소스 코드의 컴파일, 테스트, 배포 과정을 자동으로 수행하는 도구이다.
   - 사용 목적
     - 반복 작업 자동화
     - 빌드 오류 감소
     - 개발 생산성 향상
     - 배포 안정성 확보
   - 빌드 자동화 도구 종류
     - | 도구    | 특징               |
       | ------- | ------------------ |
       | Ant     | XML 기반, 절차적   |
       | Make    | Unix 기반          |
       | Maven   | 프로젝트 관리 중심 |
       | Gradle  | 태스크 기반, 빠름  |
       | Jenkins | CI 서버            |

3. **Jenkins**

   > Jenkins는 Java 기반의 오픈소스 빌드 자동화 도구로, 서버 기반 CI 도구이다.
   - 핵심 특징
     - Java 기반
     - 서버 기반 도구
     - 서블릿 컨테이너에서 실행
     - SVN, Git 등 형상관리 도구와 연동 가능
     - Web GUI 제공 → 사용 편리
     - 분산 빌드 / 분산 테스트 가능
     - 자동 테스트 가능
   - Jenkins 역할 요약
     - 코드 변경 감지
     - 자동 빌드
     - 자동 테스트
     - 결과 리포트

4. **Gradle**

   > Gradle은 Groovy 기반의 오픈소스 빌드 자동화 도구로, 태스크(Task) 단위로 빌드를 수행한다.
   - 핵심 특징
     - Groovy 기반 DSL 사용
     - 태스크(Task) 단위 실행
     - 안드로이드 앱 개발에 주로 사용
     - Java, C/C++, Python 등 확장 가능
     - 빌드 캐시 지원 → 속도 향상

   - Gradle 장점
     - 이전 태스크 재사용 가능
     - 다른 시스템 태스크 공유 가능
     - 빠른 빌드 속도
