---
title: '[정보처리기사 자격증] 5.정보시스템 구축 관리 > 1장 소프트웨어 개발 방법론 활용 (WEEK 6)'
date: '2026-01-23'
tags: ['dev', 'license']
draft: false
summary: 정보처리기사 6주차 내용정리 - 소프트웨어 개발 방법론 활용 
# https://velog.io/@alpaka206/126.-소프트웨어-개발-방법론
---

import ImageWithCaption from '@/components/mdxComponents/ImageWithCaption'

### 1. 소프트웨어 개발 방법론

1. **소프트웨어 개발 방법론이란?**

   > **한 줄 정의:** 소프트웨어 개발에 필요한 **수행 방법, 기법, 도구**를 체계적으로 정리하여 **표준화**한 것

2. **소프트웨어 개발 방법론 개요**

   | 항목 | 내용                                               |
   | ---- | -------------------------------------------------- |
   | 목적 | 소프트웨어 **생산성**과 **품질 향상**              |
   | 종류 | 구조적, 정보공학, 객체지향, CBD, 애자일, 제품 계열 |

3. **소프트웨어 개발 방법론 종류**

   |    방법론     | 핵심 키워드                          |
   | :-----------: | ------------------------------------ |
   |  **구조적**   | **프로세스(처리)** 중심, 분할과 정복 |
   | **정보공학**  | **데이터(자료)** 중심, ERD           |
   | **객체지향**  | **객체** 중심, 재사용                |
   |    **CBD**    | **컴포넌트** 재사용                  |
   |  **애자일**   | **유연**, 반복, 고객 요구 대응       |
   | **제품 계열** | **공통 기능**, 임베디드              |
   1. 구조적 방법론
      - **프로세스(처리) 중심**의 정형화된 분석 절차로 요구사항을 문서화하는 방법론
      - 사용자 요구사항을 파악하여 문서화하는 처리(Precess) 중심의 방법론
      - 구조적 방법론 특징
        | 특징 | 설명 |
        | ---- | ------------------------------------ |
        | 중심 | **처리 (Process)** 중심 |
        | 시기 | **1960년대**까지 가장 많이 적용 |
        | 원리 | **분할과 정복** (Divide and Conquer) |
        | 목적 | 쉬운 이해 및 검증 가능한 코드 생성 |
      - 구조적 방법론 절차

        ```
         요구사항 분석 → 구조적 분석 → 구조적 설계 → 구조적 프로그래밍
        ```

   2. 정보공학 방법론
      - **데이터(자료) 중심**의 계획, 분석, 설계, 구축을 통합 적용하는 방법론
      - 정보공학 방법론 특징

        | 특징   | 설명                        |
        | ------ | --------------------------- |
        | 중심   | **데이터 (자료)** 중심      |
        | 적합   | **대규모 정보 시스템** 구축 |
        | 모델링 | **ERD** (개체 관계도) 사용  |

      - 정보공학 방법론 절차

        ```
          정보 전략 계획 → 업무 영역 분석 → 시스템 설계 → 시스템 구축
        ```

   3. 객체지향 방법론
      - 현실 세계의 개체를 **객체(Object)**로 만들어 **조립**하여 소프트웨어를 구현하는 방법론
      - 객체지향 방법론 특징

        | 특징 | 설명                       |
        | ---- | -------------------------- |
        | 중심 | **객체 (Object)** 중심     |
        | 배경 | **소프트웨어 위기** 해결책 |
        | 비유 | 기계 **부품 조립**처럼     |

      - 객체지향 설계 모델링

        | 다이어그램            |
        | --------------------- |
        | **패키지 다이어그램** |
        | **배치 다이어그램**   |
        | **상태 전이도**       |

      - 객체지향 방법론 절차

        ```
         요구 분석 → 설계 → 구현 → 테스트 및 검증 → 인도
        ```

   4. 컴포넌트 기반(CBD) 방법론
      - 기존 **컴포넌트를 조합**하여 새로운 애플리케이션을 만드는 방법론
      - CBD 방법론 특징

        | 특징 | 설명                                   |
        | ---- | -------------------------------------- |
        | 핵심 | **컴포넌트 재사용** (Reusability)      |
        | 장점 | 시간/노력 절감, **확장성** 보장        |
        | 효과 | 유지보수 비용 최소화, 생산성/품질 향상 |

      - CBD 방법론 절차

        ```
           개발 준비 → 분석 → 설계 → 구현 → 테스트 → 전개 → 인도
        ```

   5. **애자일(Agile) 방법론**
      - 고객 요구사항 변화에 **유연하게 대응**, **일정한 주기를 반복**하며 개발하는 방법론
      - 애자일 의미
        - **Agile** = **민첩한**, **기민한**
      - 애자일 방법론 특징

        | 특징 | 설명                                                          |
        | ---- | ------------------------------------------------------------- |
        | 핵심 | **유연한 대응**, **반복 개발**                                |
        | 적합 | **소규모** 프로젝트, **숙달된** 개발자, **급변하는** 요구사항 |

      - 애자일 방법론 종류 (시험 필수!)

        |     종류     | 설명                |
        | :----------: | ------------------- |
        |    **XP**    | eXtreme Programming |
        |  **스크럼**  | Scrum               |
        |   **칸반**   | Kanban              |
        | **크리스탈** | Crystal             |

      - 애자일 방법론 절차

        ```
          계획 → 반복(개발) → 출시
        ```

   6. 제품 계열 방법론
      - 특정 제품에 적용할 **공통된 기능을 정의**하여 개발하는 방법론
      - 제품 계열 방법론 특징

        | 특징 | 설명                       |
        | ---- | -------------------------- |
        | 적합 | **임베디드 소프트웨어**    |
        | 구분 | **영역공학**, **응용공학** |

      - 영역공학 vs 응용공학

        | 구분 |                영역공학                |                응용공학                |
        | :--: | :------------------------------------: | :------------------------------------: |
        | 역할 |           **핵심 자산** 구현           |             **제품** 구현              |
        | 절차 | 영역 분석 → 영역 설계 → 핵심 자산 구현 | 제품 요구 분석 → 제품 설계 → 제품 구현 |

      - 제품 계열 방법론 구조

        ```
           ┌─────────────────────────────────────────┐
           │  영역공학: 영역 분석 → 영역 설계 → 핵심 자산 구현  │
           ├─────────────────────────────────────────┤
           │        ↓ 컴포넌트 (연계)                    │
           ├─────────────────────────────────────────┤
           │  응용공학: 제품 요구 분석 → 제품 설계 → 제품 구현  │
           └─────────────────────────────────────────┘
        ```

4. **방법론 비교표**

   |    방법론     |     중심      | 특징                    |
   | :-----------: | :-----------: | ----------------------- |
   |  **구조적**   | **프로세스**  | 분할과 정복, 1960년대   |
   | **정보공학**  |  **데이터**   | ERD, 대규모 시스템      |
   | **객체지향**  |   **객체**    | 부품 조립, 위기 해결    |
   |    **CBD**    | **컴포넌트**  | 재사용, 확장성          |
   |  **애자일**   |   **반복**    | 유연, XP/스크럼         |
   | **제품 계열** | **공통 기능** | 임베디드, 영역/응용공학 |

---

### 2. S/W 공학의 발전적 추세

1. **개요**

   > 소프트웨어 **재사용**, **재공학**, **CASE**를 통한 생산성과 품질 향상

2. **소프트웨어 재사용 (Software Reuse)**

   > **한 줄 정의:** 이미 개발된 소프트웨어의 **전체 또는 일부**를 다른 소프트웨어 개발이나 유지에 **다시 사용**하는 것
   - 재사용 이점
     | 이점 |
     | --------------------------- |
     | 개발 **시간과 비용** 단축 |
     | 소프트웨어 **품질** 향상 |
     | **생산성** 향상 |
     | 프로젝트 **실패 위험** 감소 |
     | 지식, 문서 **공유** |
   - 소프트웨어 재사용 방법

     |     방법      | 다른 이름          | 한 줄 정의                                       |
     | :-----------: | ------------------ | ------------------------------------------------ |
     | **합성 중심** | **블록 구성** 방법 | 소프트웨어 **부품(블록)**을 만들어 **끼워 맞춤** |
     | **생성 중심** | **패턴 구성** 방법 | 추상화 **명세를 구체화**하여 프로그램 생성       |

3. **소프트웨어 재공학 (Software Reengineering)**

   > **한 줄 정의:** 기존 시스템을 이용하여 **새로운 기능을 추가**하고 **성능을 향상**시키는 것
   - 소프트웨어 재공학은 기존 시스템을 기반으로 구조·성능을 개선하는 ‘유지보수 활동’이다.
   - 재공학 특징

     | 특징     | 설명                                |
     | -------- | ----------------------------------- |
     | 목적     | **유지보수성**과 **품질** 향상      |
     | 배경     | **유지보수 비용**이 대부분 차지     |
     | 유지보수 | **예방 (Preventive)** 유지보수 측면 |
     | 효과     | 소프트웨어 **위기 해결**            |

   - 재공학 이점

     | 이점                     |
     | ------------------------ |
     | 소프트웨어 **수명 연장** |
     | 개발 **기간 단축**       |
     | **오류 감소**            |
     | **비용 절감**            |

   - 재공학 주요 활동 (시험 필수!)

     |               활동               | 한 줄 정의                                            |
     | :------------------------------: | ----------------------------------------------------- |
     |       **분석** (Analysis)        | 기존 소프트웨어의 **동작 이해**, 재공학 **대상 선정** |
     |    **재구성** (Restructuring)    | 기존 **코드를 재구성** (기능/동작 **변경 없음**)      |
     | **역공학** (Reverse Engineering) | 기존 코드에서 **설계 정보 추출** (반대 방향)          |
     |       **이식** (Migration)       | 다른 **운영체제/하드웨어**로 **변환**                 |
     - **역공학 (Reverse Engineering)**
       - 기존 코드를 분석하여 **설계 정보를 재발견**하거나 **설계도를 추출**하는 활동
       - 역공학 특징

         | 특징 | 설명                                   |
         | ---- | -------------------------------------- |
         | 방향 | 일반 개발과 **반대 방향**              |
         | 역할 | 기존 코드 → **설계 정보** 추출         |
         | 활용 | 구성요소와 관계 파악 → **설계도 추출** |

       - 역공학 vs 일반 개발

         |    구분    |          방향           |
         | :--------: | :---------------------: |
         | 일반 개발  |       설계 → 코드       |
         | **역공학** | 코드 → **설계** (반대!) |

4. **CASE (Computer Aided Software Engineering)**

   > **한 줄 정의:** 소프트웨어 개발 과정 **전체 또는 일부**를 **컴퓨터로 자동화**하는 것
   - CASE 특징

     | 특징 | 설명                                     |
     | ---- | ---------------------------------------- |
     | 목적 | 개발 과정 **자동화**                     |
     | 대상 | 요구 분석, 설계, 구현, 검사, 디버깅      |
     | 활용 | 객체지향, 구조적 시스템 등 다양한 시스템 |

   - **CASE 도구 분류**

     |     구분      | 지원 단계                    |
     | :-----------: | ---------------------------- |
     | **상위 CASE** | **요구 분석**, **설계** 과정 |
     | **하위 CASE** | **구현**, **테스트** 과정    |

   - CASE 이점

     | 이점                              |
     | --------------------------------- |
     | 개발 **기간 단축**, **비용 절감** |
     | 소프트웨어 **품질 향상**          |
     | **유지보수** 간편                 |
     | **생산성** 향상                   |
     | **표준 확립**                     |
     | **재사용성** 향상                 |
     | **문서화** 용이                   |

   - CASE 주요 기능 및 원천 기술
     - 주요 기능

       | 기능                                  |
       | ------------------------------------- |
       | 소프트웨어 생명 주기 **전 단계 연결** |
       | 다양한 **개발 모형 지원**             |
       | **그래픽** 지원                       |
       | **모순 검사**, **오류 검증**          |
       | **자료흐름도** 작성                   |

     - 원천 기술

       | 기술                |
       | ------------------- |
       | **구조적 기법**     |
       | **프로토타이핑**    |
       | **자동 프로그래밍** |
       | **정보 저장소**     |
       | **분산 처리**       |

---

### 3. 상향식 비용 산정 기법

1. **상향식 비용 산정 기법이란?**

   > **한 줄 정의:** 프로젝트의 **세부 작업 단위별**로 비용을 산정한 후 **집계**하여 전체 비용을 산정하는 방법

2. **상향식 비용 산정 기법 종류**

   |          기법          | 특징                       |
   | :--------------------: | -------------------------- |
   |        **LOC**         | 원시 코드 라인 수          |
   | **개발 단계별 인월수** | LOC 보완, 단계별 노력 산정 |
   |    **수학적 산정**     | COCOMO, Putnam, FP 등      |
   1. **LOC 기법 (Line Of Code)**
      - **원시 코드 라인 수**의 낙관치, 비관치, 기대치를 측정하여 **예측치**를 구하고 비용을 산정하는 기법
      - LOC 기법 특징

        | 특징      | 설명                         |
        | --------- | ---------------------------- |
        | 측정 대상 | **원시 코드 라인 수**        |
        | 장점      | 측정 **용이**, 이해 **쉬움** |
        | 사용      | **가장 많이** 사용됨         |

      - LOC 예측치 공식
        - 예측치 공식

          ```
          예측치 = (a + 4m + b) / 6
          ```

          | 기호  | 의미                             |
          | :---: | -------------------------------- |
          | **a** | **낙관치** (Optimistic)          |
          | **m** | **기대치** (중간치, Most likely) |
          | **b** | **비관치** (Pessimistic)         |

      - LOC 산정 공식
        - 노력 (인월, Man-Month)

          ```
            노력(인월) = 개발 기간 × 투입 인원
                     = LOC / 1인당 월평균 생산 코드 라인 수
          ```

        - 개발 비용

          ```
          개발 비용 = 노력(인월) × 단위 비용(1인당 월평균 인건비)
          ```

        - 개발 기간

          ```
          개발 기간 = 노력(인월) / 투입 인원
          ```

        - 생산성

          ```
          생산성 = LOC / 노력(인월)
          ```

   2. 개발 단계별 인월수 (Effort Per Task) 기법
      - 각 기능 구현에 필요한 **노력을 생명 주기 단계별**로 산정하는 기법 (LOC 보완)
      - 특징

        | 특징   | 설명                           |
        | ------ | ------------------------------ |
        | 목적   | **LOC 기법 보완**              |
        | 방식   | 생명 주기 **단계별** 노력 산정 |
        | 정확도 | LOC보다 **더 정확**            |

      - LOC vs 개발 단계별 인월수 비교

        |   구분    |     LOC      | 개발 단계별 인월수 |
        | :-------: | :----------: | :----------------: |
        | 측정 기준 | 코드 라인 수 |  **단계별 노력**   |
        |  정확도   |     보통     |    **더 정확**     |
        |   관계    |  기본 기법   |    LOC **보완**    |

---

### 4. 수학적 산정 기법

1. **수학적 산정 기법이란?**

   > **한 줄 정의:** 과거 유사 프로젝트를 기반으로 **경험적 공식**을 사용하여 개발 비용을 **자동으로 산정**하는 기법

2. **수학적 산정 기법 개요**

   | 항목      | 내용                                       |
   | --------- | ------------------------------------------ |
   | 분류      | **상향식** 비용 산정 기법                  |
   | 다른 이름 | **경험적** 추정 모형, **실험적** 추정 모형 |
   | 목표      | 개발 비용 산정의 **자동화**                |

3. **수학적 산정 기법 종류**

   |        모형        |          제안자           | 특징                     |
   | :----------------: | :-----------------------: | ------------------------ |
   |     **COCOMO**     |     **보헴 (Boehm)**      | **LOC** 기반, 중소 규모  |
   |     **Putnam**     |    **푸트남 (Putnam)**    | **생명 주기** 예측, 대형 |
   | **기능 점수 (FP)** | **알브레히트 (Albrecht)** | **기능** 기반            |
   1. COCOMO 모형 (시험 필수!)
      - **보헴(Boehm)**이 제안한 **LOC(원시 코드 라인 수)** 기반 비용 산정 기법
      - COCOMO 특징

        | 특징   | 설명                                    |
        | ------ | --------------------------------------- |
        | 제안자 | **보헴 (Boehm)**                        |
        | 기반   | **LOC** (원시 코드 라인 수)             |
        | 적합   | **중소 규모** 프로젝트                  |
        | 결과   | **노력 (Man-Month)**                    |
        | 특징   | 같은 규모라도 **성격에 따라** 비용 다름 |

      - COCOMO 소프트웨어 개발 유형
        | 유형 | 규모 | 특징 | 적합 분야 |
        | :--------------------------: | :----------------: | ----------------------- | ---------------------- |
        | **조직형** (Organic) | **5만** 라인 이하 | 중·소 규모, 복잡도 낮음 | 사무용, 업무용, 과학용 |
        | **반분리형** (Semi-Detached) | **30만** 라인 이하 | 중간형 | 유틸리티, 컴파일러 |
        | **내장형** (Embedded) | **30만** 라인 이상 | 초대형, 복잡도 높음 | 실시간, 미사일, 신호기 |
      - COCOMO 비용 산정 공식 (시험 필수!)

        |     유형     | 노력 (MM)             | 개발 기간 (TDEV) |
        | :----------: | --------------------- | ---------------- |
        |  **조직형**  | 2.4 × (KDSI)^**1.05** | 2.5 × (MM)^0.38  |
        | **반분리형** | 3.0 × (KDSI)^**1.12** | 2.5 × (MM)^0.35  |
        |  **내장형**  | 3.6 × (KDSI)^**1.20** | 2.5 × (MM)^0.32  |
        - KDSI > 코드 줄 / 1000 > 소스 코드가 10,000줄이면 10 KDSI

   2. Putnam 모형
      - **푸트남(Putnam)**이 제안한 **생명 주기 예측** 모형, **대형 프로젝트** 노력 분포 산정
      - Putnam 특징

        | 특징      | 설명                     |
        | --------- | ------------------------ |
        | 제안자    | **푸트남 (Putnam)**      |
        | 다른 이름 | **생명 주기 예측** 모형  |
        | 기반      | **Rayleigh-Norden 곡선** |
        | 적합      | **대형** 프로젝트        |
        | 특징      | 개발 기간 ↑ → 노력 ↓     |

      - Putnam 산정 공식

        ```
        노력(MM) = L³ / (Ck³ × Td⁴)
        ```

        |  기호  | 의미              |
        | :----: | ----------------- |
        | **L**  | 원시 코드 라인 수 |
        | **Td** | 개발 기간         |
        | **Ck** | **환경 상수**     |
        - 환경 상수 (Ck) 값

          |   환경    | Ck 값  |
          | :-------: | :----: |
          | 빈약 환경 | 2,000  |
          | 좋은 환경 | 8,000  |
          | 최적 환경 | 12,000 |

   3. 기능 점수 (FP) 모형
      - **알브레히트(Albrecht)**가 제안한 소프트웨어 **기능 요인별 가중치**를 합산하여 비용을 산정하는 기법
      - 기능 점수 특징

        | 특징   | 설명                      |
        | ------ | ------------------------- |
        | 제안자 | **알브레히트 (Albrecht)** |
        | 기반   | 소프트웨어 **기능**       |
        | 방식   | 요인별 **가중치 합산**    |
        | 평가   | 현재 **최선의 평가**      |

      - 기능 점수 공식

        ```
         기능 점수(FP) = 총 기능 점수 × [0.65 + (0.1 × 총 영향도)]
        ```

      - 기능별 가중치

        | 기능 요인                   | 단순  |  보통  |  복잡  |
        | --------------------------- | :---: | :----: | :----: |
        | **자료 입력** (입력 양식)   |   3   |   4    |   6    |
        | **정보 출력** (출력 보고서) |   4   |   5    |   7    |
        | **명령어** (사용자 질의수)  |   3   |   4    |   6    |
        | **데이터 파일**             | **7** | **10** | **15** |
        | **외부 인터페이스**         |   5   |   7    |   10   |

4. **수학적 산정 기법 비교**

   |  구분  |    COCOMO     |   Putnam   |   기능 점수    |
   | :----: | :-----------: | :--------: | :------------: |
   | 제안자 |   **보헴**    | **푸트남** | **알브레히트** |
   |  기반  |    **LOC**    | 생명 주기  |    **기능**    |
   |  적합  | **중소** 규모 |  **대형**  |      전체      |
   |  평가  |       -       |     -      |    **최선**    |

---

### 5. 프로젝트 일정 계획

1. **프로젝트 일정 계획이란?**

   > **한 줄 정의:** 프로젝트의 **소작업을 파악**하고 **노력을 분배**하며 **순서와 일정**을 정하는 것

2. **프로젝트 일정 계획 개요**

   | 항목 | 내용                                        |
   | ---- | ------------------------------------------- |
   | 목적 | 개발 기간 **지연 방지**, 계획대로 진행      |
   | 역할 | 진행 관리의 **기초 자료**                   |
   | 조정 | 계획 vs 진행도 비교 → 차질 시 **조치/조정** |

3. **일정 계획 도구**

   |     도구      | 특징                       |
   | :-----------: | -------------------------- |
   |    **WBS**    | 작업 분할 구조             |
   |   **PERT**    | 네트워크, 낙관/기대/비관치 |
   |    **CPM**    | 네트워크, **임계 경로**    |
   | **간트 차트** | **막대 도표**, 일정표      |
   1. PERT (Program Evaluation and Review Technique) (시험 필수!)
      - 작업별로 **낙관치, 기대치, 비관치**를 나누어 각 단계별 **종료 시기를 결정**하는 네트워크 기법
      - PERT 특징

        | 특징 | 설명                                        |
        | ---- | ------------------------------------------- |
        | 표현 | **노드**(작업) + **간선**(낙관/기대/비관치) |
        | 적용 | 과거 경험 **없는** 프로젝트                 |
        | 예측 | 소요 기간 예측 **어려운** 경우              |

      - PERT 확인 가능 정보
        - 결정 경로
        - 작업에 대한 경계 시간
        - 작업 간의 **상호 관련성**
      - PERT 공식
        - 작업 예측치

          ```
            작업 예측치 = (비관치 + 4 × 기대치 + 낙관치) / 6
          ```

        - 평방 편차

          ```
            평방 편차 = ((비관치 - 낙관치) / 6)²
          ```

   2. **CPM (Critical Path Method, 임계 경로 기법)**
      - 작업을 나열하고 **소요 기간을 예측**하며 **임계 경로(최장 경로)**를 찾는 네트워크 기법
      - CPM 특징

        | 특징 | 설명                                      |
        | ---- | ----------------------------------------- |
        | 표현 | **노드**(작업) + **간선**(전후 의존 관계) |
        | 핵심 | **임계 경로** = **최장 경로**             |
        | 장점 | 작업 순서, 의존 관계, 동시 수행 여부 파악 |

      - CPM 노드 구성

        |     노드      | 의미   | 표시 내용            |
        | :-----------: | ------ | -------------------- |
        | **원형 노드** | 작업   | 작업 이름, 소요 기간 |
        | **박스 노드** | 이정표 | 예상 완료 시간       |

      - CPM 장점

        | 장점                           |
        | ------------------------------ |
        | 작업 **순서와 의존 관계** 파악 |
        | **동시 수행** 가능 여부 확인   |
        | 경영층 **의사 결정** 지원      |
        | **병행 작업** 계획 가능        |
        | **자원 할당** 가능             |

      - 임계 경로 (Critical Path) (시험 필수!)
        - 프로젝트 완성까지 걸리는 **최장 경로**
        - 임계 경로 = 최장 경로
          - 프로젝트 **최소 완료 시간** 결정
          - 임계 경로 상의 작업 지연 → **전체 프로젝트 지연**

   3. 간트 차트 (Gantt Chart)
      - 작업 일정을 **막대 도표**로 표시하는 프로젝트 **일정표**
      - 간트 차트 특징

        | 특징      | 설명                        |
        | --------- | --------------------------- |
        | 다른 이름 | **시간선 (Time-Line)** 차트 |
        | 표현 방식 | **막대 도표** (수평 막대)   |
        | 막대 길이 | 각 **작업 기간** 표시       |

      - 간트 차트 구성 요소

        | 요소          |
        | ------------- |
        | **이정표**    |
        | **작업 일정** |
        | **작업 기간** |
        | **산출물**    |

      - 간트 차트 장점

        | 장점                                     |
        | ---------------------------------------- |
        | 중간 목표 미달성 시 **이유와 기간 예측** |
        | **문제점**, **예산 초과** 관리           |
        | **자원 배치**, **인원 계획**에 유용      |
        | CPM 네트워크 데이터로 제작 가능          |

      - 간트 차트 단점

        | 단점                             |
        | -------------------------------- |
        | **작업 경로** 표시 **불가**      |
        | 계획 변화에 대한 **적응성 약함** |
        | 수정 시 **주관적 수치**에 치우침 |

---

### 6. 소프트웨어 개발 방법론 결정

1. **소프트웨어 개발 방법론 결정이란?**

   > **한 줄 정의:** 프로젝트 관리와 재사용 현황을 반영하여 **개발 단계, 활동, 작업, 절차**를 정의하는 것

2. **소프트웨어 개발 방법론 결정 개요**

   | 항목      | 내용                                        |
   | --------- | ------------------------------------------- |
   | 반영 요소 | **프로젝트 관리**, **재사용 현황**          |
   | 기준      | **소프트웨어 생명 주기**, **개발 방법론**   |
   | 정의 대상 | 개발 **단계**, **활동**, **작업**, **절차** |

3. **프로젝트 관리 (Project Management)**

   > **한 줄 정의:** 주어진 기간 내에 **최소 비용**으로 사용자를 만족시키는 시스템을 개발하기 위한 **전반적인 활동**
   - 프로젝트 관리 영역

     |   관리 영역   | 세부 활동                                            |
     | :-----------: | ---------------------------------------------------- |
     | **일정 관리** | 작업 순서, 작업 기간 산정, 일정 개발, 일정 통제      |
     | **비용 관리** | 비용 산정, 비용 예산 편성, 비용 통제                 |
     | **인력 관리** | 팀 편성, 자원 산정, 조직 정의, 팀 개발, 자원 통제    |
     | **위험 관리** | 위험 식별, 위험 분석/평가, 위험 계획, 위험 감시/조치 |
     | **품질 관리** | 품질 계획, 품질 보증, 품질 통제                      |

   - 관리 영역별 상세 활동
     1. 일정 관리

        | 활동               |
        | ------------------ |
        | 작업 **순서** 결정 |
        | 작업 **기간 산정** |
        | **일정 개발**      |
        | **일정 통제**      |

     2. 비용 관리

        | 활동               |
        | ------------------ |
        | **비용 산정**      |
        | 비용 **예산 편성** |
        | **비용 통제**      |

     3. 인력 관리

        | 활동                   |
        | ---------------------- |
        | 프로젝트 **팀 편성**   |
        | **자원 산정**          |
        | 프로젝트 **조직 정의** |
        | 프로젝트 **팀 개발**   |
        | **자원 통제**          |
        | 프로젝트 **팀 관리**   |

     4. 위험 관리

        |        활동        | 설명             |
        | :----------------: | ---------------- |
        |   **위험 식별**    | 위험 요소 파악   |
        | **위험 분석/평가** | 위험 정도 분석   |
        |   **위험 계획**    | 대응 계획 수립   |
        | **위험 감시/조치** | 모니터링 및 대응 |

     5. 품질 관리

        | 활동               |
        | ------------------ |
        | **품질 계획**      |
        | 품질 **보증 수행** |
        | 품질 **통제 수행** |

4. **소프트웨어 개발 방법론 결정 절차**
   - 절차 1: 프로젝트 관리와 재사용 현황 반영

     ```
     1-1. 반영 방법을 프로젝트 관련자들에게 설명
              ↓
     1-2. 반영 후 결과를 설명하고 결정
     ```

   - 절차 2: 개발 단계별 작업 및 절차 수립

     ```
     2-1. 생명 주기별 주요 프로세스 확인
        - 기본 생명 주기
        - 지원 생명 주기
        - 조직 생명 주기
              ↓
     2-2. 개발 프로세스, 생명 주기, 프로세스 모형 정리
     ```

   - 절차 3: 매뉴얼 작성

     ```
     3-1. 개발 단계별 활동 목적 정의
     3-2. 작업 내용 정의
     3-3. 산출물 정의
              ↓
     3-4. 매뉴얼 작성
     ```

---

### 7. 소프트웨어 개발 표준

1. **소프트웨어 개발 표준이란?**

   > **한 줄 정의:** 소프트웨어 개발 단계에서 수행하는 **품질 관리**에 사용되는 **국제 표준**

2. **대표적인 소프트웨어 개발 표준**

   |       표준        | 특징                                   |
   | :---------------: | -------------------------------------- |
   | **ISO/IEC 12207** | 소프트웨어 **생명 주기** 표준          |
   |     **CMMI**      | **능력 성숙도** 통합 모델 (5단계)      |
   |     **SPICE**     | 프로세스 **평가 및 개선** 표준 (6단계) |
   1. ISO/IEC 12207
      - **ISO**에서 만든 **소프트웨어 생명 주기** 표준 프로세스
      - ISO/IEC 12207 특징

        | 특징 | 설명                                 |
        | ---- | ------------------------------------ |
        | 제정 | **ISO** (국제표준화기구)             |
        | 목적 | 개발, 운영, 유지보수 **체계적 관리** |
        | 구성 | **3가지** 생명 주기 프로세스         |

      - ISO/IEC 12207 프로세스 구성

        |      프로세스      | 세부 프로세스                                                       |
        | :----------------: | ------------------------------------------------------------------- |
        | **기본** 생명 주기 | **획득, 공급, 개발, 운영, 유지보수**                                |
        | **지원** 생명 주기 | 품질 보증, 검증, 확인, 검토, 감사, 문서화, **형상 관리**, 문제 해결 |
        | **조직** 생명 주기 | **관리, 기반 구조, 훈련, 개선**                                     |

   2. CMMI (Capability Maturity Model Integration)
      - 소프트웨어 개발 조직의 **업무 능력** 및 **성숙도를 평가**하는 모델
      - CMMI 특징

        | 특징   | 설명                           |
        | ------ | ------------------------------ |
        | 한글명 | **능력 성숙도 통합 모델**      |
        | 개발   | 미국 **카네기멜론 대학교** SEI |
        | 단계   | **5단계**                      |

      - CMMI 성숙도 5단계 (시험 필수!)

        | 단계  |                   이름                   |         프로세스         | 특징                           |
        | :---: | :--------------------------------------: | :----------------------: | ------------------------------ |
        | **1** |            **초기** (Initial)            | 정의된 프로세스 **없음** | 작업자 능력에 따라 성공 결정   |
        | **2** |            **관리** (Managed)            |  **규칙화**된 프로세스   | 프로젝트 내 프로세스 정의/수행 |
        | **3** |            **정의** (Defined)            |  **표준화**된 프로세스   | 조직의 표준 프로세스 활용      |
        | **4** | **정량적 관리** (Quantitatively Managed) | **예측 가능**한 프로세스 | **정량적**으로 관리/통제       |
        | **5** |         **최적화** (Optimizing)          | **지속적 개선** 프로세스 | 프로세스 역량 **지속 개선**    |

   3. SPICE (Software Process Improvement and Capability dEtermination)
      - 소프트웨어 프로세스를 **평가 및 개선**하는 국제 표준 (ISO/IEC 15504)
      - SPICE 특징

        | 특징      | 설명                                       |
        | --------- | ------------------------------------------ |
        | 한글명    | 소프트웨어 처리 개선 및 **능력 평가** 기준 |
        | 공식 명칭 | **ISO/IEC 15504**                          |
        | 구성      | **5개 범주**, **40개 세부 프로세스**       |
        | 단계      | **6단계** (Level 0~5)                      |

      - SPICE 목적

        | 목적                                   |
        | -------------------------------------- |
        | 프로세스 **개선**을 위한 **자체 평가** |
        | 요구조건 **만족여부** 평가             |
        | 계약 체결 위한 **수탁기관 평가**       |

      - SPICE 프로세스 범주 (5개)

        |      범주       | 특징                          | 프로세스 수 |
        | :-------------: | ----------------------------- | :---------: |
        | **고객-공급자** | 고객에게 전달, 운용/사용 지원 |    10개     |
        |    **공학**     | 명세화, 구현, 유지보수        |     9개     |
        |    **지원**     | 다른 프로세스에 의해 이용     |     8개     |
        |    **관리**     | 프로젝트 관리자가 사용        |     4개     |
        |    **조직**     | 업무 목적 수립, 목표 달성     |     9개     |

      - SPICE 프로세스 수행 능력 6단계 (시험 필수!)

        | 레벨  |          이름           | 특징                                    |
        | :---: | :---------------------: | --------------------------------------- |
        | **0** | **불완전** (Incomplete) | 프로세스 **구현 안 됨**, 목적 달성 못함 |
        | **1** |  **수행** (Performed)   | 프로세스 **수행**, 목적 **달성**        |
        | **2** |   **관리** (Managed)    | 정의된 자원 내에서 **산출물 인도**      |
        | **3** | **확립** (Established)  | **공학 원칙** 기반 정의된 프로세스 수행 |
        | **4** | **예측** (Predictable)  | **양적 측정** 통해 일관되게 수행        |
        | **5** | **최적화** (Optimizing) | **지속적 개선**, 업무 목적 만족         |

---

### 8. 소프트웨어 개발 방법론 테일러링

1. **소프트웨어 개발 방법론 테일러링이란?**

   > **한 줄 정의:** 프로젝트 상황 및 특성에 맞도록 개발 방법론의 **절차, 사용 기법 등을 수정 및 보완**하는 작업

2. **테일러링 개요**
   - 테일러링 측면별 의미

     |    측면    | 의미                                                |
     | :--------: | --------------------------------------------------- |
     | **관리적** | **사전 위험 식별/제거** → 최단기간 안정적 진행      |
     | **기술적** | **최적화된 기술 요소 도입** → 최적의 기법/도구 적용 |

   - 테일러링 수행 절차

     ```
      1. 프로젝트 특징 정의
            ↓
      2. 표준 프로세스 선정 및 검증
            ↓
      3. 상위 수준의 커스터마이징
            ↓
      4. 세부 커스터마이징
            ↓
      5. 테일러링 문서화
     ```

   - 테일러링 고려사항
     - 내부적 기준 vs 외부적 기준

       |    구분    | 고려사항                                      |
       | :--------: | --------------------------------------------- |
       | **내부적** | 목표 환경, 요구사항, 프로젝트 규모, 보유 기술 |
       | **외부적** | 법적 제약사항, 표준 품질 기준                 |

     - 내부적 기준

       |       기준        | 테일러링 필요 상황                                     |
       | :---------------: | ------------------------------------------------------ |
       |   **목표 환경**   | 시스템의 **개발 환경**과 **유형**이 다른 경우          |
       |   **요구사항**    | 개발, 운영, 유지보수 등 **우선 고려 사항**이 다른 경우 |
       | **프로젝트 규모** | **비용, 인력, 기간** 등 규모가 다른 경우               |
       |   **보유 기술**   | 프로세스, 방법론, 산출물, **구성원 능력**이 다른 경우  |

     - 외부적 기준

       |        기준        | 테일러링 필요 상황                        |
       | :----------------: | ----------------------------------------- |
       | **법적 제약사항**  | **IT Compliance**가 다른 경우             |
       | **표준 품질 기준** | 금융, 제조 등 **분야별 표준**이 다른 경우 |

   - 테일러링 기법

     |         기법         | 한 줄 정의                                        |
     | :------------------: | ------------------------------------------------- |
     |  **규모와 복잡도**   | 규모(대/중/소) + 복잡도(상/중/하)로 구분          |
     | **프로젝트 구성원**  | 구성원의 **기술 숙련도**와 **방법론 이해도** 확인 |
     | **팀내 방법론 지원** | **방법론 담당 인력** 배정, 교육/의사소통 담당     |
     |      **자동화**      | **자동화 도구**로 산출물 산출, 작업 부하 감소     |
     - 테일러링 기법 상세
       1. 규모와 복잡도에 따른 테일러링
          - 가장 **일반적인** 기법, 규모와 복잡도 기준으로 구분

            |        구분         |     분류     |
            | :-----------------: | :----------: |
            |  **프로젝트 규모**  | 대 / 중 / 소 |
            | **프로젝트 복잡도** | 상 / 중 / 하 |

          - 프로젝트 **기간**, **작업 범위**, **참여 인원** 등으로 규모 결정
          - 업무 **난이도**에 따라 복잡도 결정

       2. 프로젝트 구성원에 따른 테일러링
          - 구성원의 **기술적 숙련도**와 **방법론 이해 정도**로 수준 결정
       3. 팀내 방법론 지원에 따른 테일러링
          - **방법론 담당 인력**을 배정하여 교육과 의사소통 담당
       4. 자동화에 따른 테일러링
          - **자동화 도구**로 산출물을 산출하여 **작업 부하 감소**

---

### 9. 소프트웨어 개발 프레임워크

1. **프레임워크란?**

   > **한 줄 정의:** 소프트웨어 개발에 공통으로 사용되는 **구성 요소와 아키텍처를 일반화**하여 제공하는 **반제품 형태의 소프트웨어 시스템**

2. **프레임워크 개요**

   | 항목      | 내용                                        |
   | --------- | ------------------------------------------- |
   | 형태      | **반제품** 형태의 소프트웨어                |
   | 장점      | **사업자 종속성 해소** (표준화된 개발 기반) |
   | 구현      | **클래스 라이브러리**로 일부 이미 구현됨    |
   | 개발 방식 | 기존 부분을 **확장 및 이용**                |

3. **프레임워크 주요 기능**

   | 기능                   |
   | ---------------------- |
   | **예외 처리**          |
   | **트랜잭션 처리**      |
   | **메모리 공유**        |
   | **데이터 소스 관리**   |
   | **서비스 관리**        |
   | **쿼리 서비스**        |
   | **로깅 서비스**        |
   | **사용자 인증 서비스** |

4. **프레임워크 특성**

   |      특성       | 한 줄 정의                                          |
   | :-------------: | --------------------------------------------------- |
   |   **모듈화**    | **캡슐화**로 모듈화 강화, **유지보수 용이**         |
   |  **재사용성**   | 재사용 가능한 모듈로 **예산 절감**, **생산성 향상** |
   |   **확장성**    | **다형성**을 통한 인터페이스 확장                   |
   | **제어의 역전** | 객체 제어를 프레임워크에 넘겨 **생산성 향상**       |
   - 프레임워크 특성 상세
     1. 모듈화 (Modularity)
        - **캡슐화**를 통해 모듈화를 강화하고 변경 영향을 **최소화**

          | 효과                     |
          | ------------------------ |
          | 소프트웨어 **품질 향상** |
          | **유지보수 용이**        |

     2. 재사용성 (Reusability)
        - 재사용 가능한 **모듈 제공**

          | 효과            |
          | --------------- |
          | **예산 절감**   |
          | **생산성 향상** |
          | **품질 보증**   |

     3. 확장성 (Extensibility)
        - **다형성(Polymorphism)**을 통한 인터페이스 확장

          | 효과                                          |
          | --------------------------------------------- |
          | 다양한 형태/기능의 **애플리케이션 개발** 가능 |

     4. 제어의 역전 (IoC: Inversion of Control)
        - 객체 **제어를 프레임워크에 위임**

          | 효과            |
          | --------------- |
          | **생산성 향상** |

5. **프레임워크 종류**

   |  프레임워크  | 특징                    |
   | :----------: | ----------------------- |
   |  **스프링**  | 자바, 오픈 소스, 경량형 |
   | **전자정부** | 공공부문, 스프링 기반   |
   |   **닷넷**   | Windows, Microsoft, CLR |
   1. 스프링 프레임워크 (Spring Framework)
      - **자바 플랫폼**을 위한 **오픈 소스 경량형** 애플리케이션 프레임워크
      - 스프링 특징

        | 특징   | 설명                                |
        | ------ | ----------------------------------- |
        | 플랫폼 | **자바 (Java)**                     |
        | 형태   | **오픈 소스**, **경량형**           |
        | 용도   | **동적 웹 사이트** 개발             |
        | 역할   | **전자정부 프레임워크**의 기반 기술 |

   2. 전자정부 프레임워크
      - **공공부문 정보화 사업**을 위한 효율적인 정보 시스템 구축 지원 프레임워크
      - 전자정부 프레임워크 특징

        | 특징 | 설명                                         |
        | ---- | -------------------------------------------- |
        | 대상 | **공공부문** 정보화 사업                     |
        | 목적 | **표준화**, **품질 향상**, **재사용성 향상** |
        | 기반 | **스프링 프레임워크** 기반                   |
        | 장점 | **특정 업체 종속성 배제**                    |
        | 장점 | 공통 컴포넌트 **중복 개발 방지**             |
        | 형태 | **오픈 소스** 기반                           |

   3. 닷넷 프레임워크 (.NET Framework)
      - **Windows 프로그램**의 개발 및 실행 환경을 제공하는 프레임워크
      - 닷넷 프레임워크 특징

        | 특징     | 설명                              |
        | -------- | --------------------------------- |
        | 개발     | **Microsoft**                     |
        | 플랫폼   | **Windows**                       |
        | 가상머신 | **CLR** (Common Language Runtime) |
        | 서비스   | 메모리 관리, 보안, 네트워크 등    |

   4. CLR (Common Language Runtime)
      - 코드 실행을 관리하는 **가상머신**
   5. 프레임워크 비교표

      |   구분   |   스프링   |   전자정부   |       닷넷       |
      | :------: | :--------: | :----------: | :--------------: |
      |  플랫폼  |  **자바**  |   **자바**   |   **Windows**    |
      |   개발   | 오픈 소스  |  한국 정부   |  **Microsoft**   |
      | 가상머신 |    JVM     |     JVM      |     **CLR**      |
      |   용도   |  웹 개발   | **공공부문** | Windows 프로그램 |
      |   특징   | **경량형** | 스프링 기반  | 통합 인터넷 전략 |
