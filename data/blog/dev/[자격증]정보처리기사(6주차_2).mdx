---
title: '[정보처리기사 자격증] 3.데이터베이스 구축 > 2장 물리 데이터베이스 설계 (WEEK 6)'
date: '2026-01-19'
tags: ['dev', 'license']
draft: false
summary: 정보처리기사 6주차 내용정리 - 물리 데이터베이스 설계
# https://velog.io/@alpaka206/60.-데이터베이스-설계
---

import ImageWithCaption from '@/components/mdxComponents/ImageWithCaption'

### 1. 트랜잭션 분석 / CRUD 분석

> 트랜잭션 = 한꺼번에 수행되어야 할 **작업의 단위**

1. **트랜잭션이란?**
   - DB 상태를 변환시키는 **하나의 논리적 작업 단위**
   - **병행 제어** 및 **회복 작업** 시 처리되는 단위
   - 모두 성공하거나, 모두 실패하거나! (All or Nothing)

2. **트랜잭션의 상태 5가지**

```
        ┌──────────┐
        │  활동     │ ← 실행 중
        │ (Active) │
        └────┬─────┘
             │
      ┌──────┴──────┐
      ↓             ↓
┌─────────┐   ┌─────────┐
│  실패    │   │ 부분완료   │ ← Commit 직전
│(Failed) │   │(Partial)│
└────┬────┘   └────┬────┘
     ↓             ↓
┌─────────┐   ┌─────────┐
│  철회    │   │  완료    │ ← Commit 완료
│(Aborted)│   │(Commit) │
└─────────┘   └─────────┘
  Rollback      성공!
```

| 상태                 | 설명            |
| -------------------- | --------------- |
| **활동 (Active)**    | 실행 중         |
| **실패 (Failed)**    | 오류 발생, 중단 |
| **철회 (Aborted)**   | Rollback 수행   |
| **부분 완료**        | Commit **직전** |
| **완료 (Committed)** | Commit **완료** |

3. **트랜잭션의 특성 - ACID (시험 필수!)**

|    특성    |      영문       | 의미                                    |
| :--------: | :-------------: | --------------------------------------- |
| **원자성** |  **A**tomicity  | 모두 반영 or 모두 취소 (All or Nothing) |
| **일관성** | **C**onsistency | 실행 전후 DB 상태 일관성 유지           |
| **독립성** |  **I**solation  | 다른 트랜잭션 끼어들기 불가             |
| **영속성** | **D**urability  | 완료된 결과는 영구 반영                 |

      - 암기법: **"ACID (산)"** - 원일독영

         ```
         A = 원자성: All or Nothing!
         C = 일관성: 전후 상태 동일
         I = 독립성: 끼어들기 금지
         D = 영속성: 영구 저장
         ```

4. **CRUD 분석**
   1. CRUD란?
      | 문자 | 의미 | SQL |
      | :---: | ------------- | ------ |
      | **C** | Create (생성) | INSERT |
      | **R** | Read (읽기) | SELECT |
      | **U** | Update (갱신) | UPDATE |
      | **D** | Delete (삭제) | DELETE |
   2. CRUD 분석 목적
      - 테이블에 발생하는 트랜잭션 양 분석
      - 데이터 양 유추 → **DB 용량 산정**
      - 부하 집중 테이블 파악 → **디스크 분산**
   3. CRUD 매트릭스
      - **행(Row)**: 프로세스
      - **열(Column)**: 테이블
      - **셀**: 프로세스가 테이블에 주는 변화 (C, R, U, D)
   4. 우선순위 (복수일 때)

      ```
      C > D > U > R
      ```

      → 여러 연산 시 **우선순위 높은 것만** 표시

   5. 예시

      | 프로세스      | 회원 | 상품 | 주문 |
      | ------------- | :--: | :--: | :--: |
      | 회원등록      |  C   |      |      |
      | 회원정보 변경 |  U   |      |      |
      | 주문요청      |  R   |  R   |  C   |
      | 주문취소      |      |      |  D   |
      - 검증 포인트
        - **C, R, U, D 없는 행/열** → 누락 또는 불필요
        - **C나 R 없는 열** → 테이블 검토 필요

5. **트랜잭션 분석서**
   - CRUD 매트릭스를 기반으로 "어떤 프로세스가 어떤 테이블에 얼마나 자주 접근하는지" 정리한 문서
   1. 구성 요소
      | 항목 | 설명 |
      | --------------- | ------------------------- |
      | 단위 프로세스 | 가장 작은 단위의 프로세스 |
      | CRUD 연산 | C, R, U, D |
      | 테이블명/컬럼명 | 접근하는 테이블.컬럼 |
      | 참조 횟수 | 테이블 참조 횟수 |
      | 트랜잭션 수 | 주기별 수행 횟수 |
      | 발생 주기 | 연/월/일/시간 등 |
   2. 예시
      | 프로세스 | CRUD | 테이블 | 참조횟수 | 트랜잭션수 | 주기 |
      | -------- | :--: | ------ | :------: | :--------: | :--: |
      | 주문요청 | R | 회원 | 1 | 150 | 일 |
      | 주문요청 | R | 상품 | 1 | 150 | 일 |
      | 주문요청 | C | 주문 | 3 | 450 | 일 |

---

### 2. 인덱스 설계

1. **인덱스(Index)란?**

   > **한 줄 정의:** 데이터를 빠르게 찾기 위한 **\<키 값, 포인터>** 쌍으로 구성된 데이터 구조 (책의 목차/색인과 같음)

2. **인덱스 핵심 개념**
   | 항목 | 내용 |
   | ------- | ------------------------------- |
   | 구성 | **키 값 + 포인터(주소)** |
   | 목적 | 레코드 **빠른 접근** |
   | 관리 | **DDL**로 생성/변경/제거 |
   | 없으면? | **TABLE SCAN** 발생 (전체 검색) |

3. **인덱스 종류**

   | 종류            | 설명                               |
   | --------------- | ---------------------------------- |
   | **기본 인덱스** | 기본키(PK)용 인덱스, **자동 생성** |
   | **보조 인덱스** | 기본 인덱스 외 나머지              |

   💡 삽입/삭제 **수시로** 발생 → 인덱스 개수 **최소화**가 효율적!

4. **클러스터드 vs 넌클러스터드 (시험 필수!)**

   | 구분           | 클러스터드 (Clustered)      | 넌클러스터드 (Non-Clustered)   |
   | -------------- | --------------------------- | ------------------------------ |
   | **한 줄 정의** | 데이터 자체가 정렬된 인덱스 | 인덱스만 정렬, 데이터는 그대로 |
   | 데이터 정렬    | ⭕ 정렬됨                   | ❌ 정렬 안 됨                  |
   | 검색 속도      | **빠름**                    | 상대적으로 느림                |
   | 개수           | 테이블당 **1개만**          | 테이블당 **여러 개** 가능      |
   | 삽입/삭제 시   | 재정렬 필요                 | 재정렬 불필요                  |
   - 클러스터드
     - 인덱스 키의 순서에 따라 데이터가 정렬되어 저장되는 방식
     - 사전 (ㄱㄴㄷ순 정렬)
   - 넌클러스터드
     - 인덱스의 키 값만 정렬되어 있을 뿐 실제 데이터는 정렬되지 않는 방식
     - 책 뒤 색인 (페이지만 알려줌)

5. **인덱스 종류별 정리**
   1. B 트리 인덱스

      > **한 줄 정의:** 트리 구조로 키 값을 비교하며 탐색하는 가장 일반적인 인덱스
      - 루트 → 하위 노드로 키 값 비교하며 검색
      - 모든 리프 노드는 **같은 레벨**
      - 구성: **브랜치 블록** (분기용) + **리프 블록** (데이터 위치)

   2. B+ 트리 인덱스

      > **한 줄 정의:** B 트리의 변형으로, 단말 노드만 데이터 주소를 가지며 **순차 처리 가능**
      - **인덱스 세트**: 경로만 제공 (단말 노드 아님)
      - **순차 세트**: 실제 데이터 주소 (단말 노드)
      - 단말 노드끼리 연결 → **순차 처리 가능**
      - 상용 DBMS에서 **주로 사용!**

   3. 비트맵 인덱스

      > **한 줄 정의:** 데이터를 **0과 1의 비트**로 변환하여 저장하는 인덱스
      - **분포도가 좋은 컬럼**에 적합 (예: 성별, Y/N)
      - 저장 공간 작음
      - **다중 조건** 검색에 적합
      - 논리 연산(AND, OR) 효율적

   4. 함수 기반 인덱스

      > **한 줄 정의:** 컬럼에 **함수나 수식을 적용한 결과**로 만든 인덱스
      - 대소문자, 띄어쓰기 무관 조회 시 유용
      - 입력/수정 시 함수 적용 → **부하 발생**

   5. 도메인 인덱스

      > **한 줄 정의:** 개발자가 **직접 만든** 사용자 정의 인덱스 (= 확장형 인덱스)

6. **인덱스 설계 순서**

   ```

   1. 대상 테이블/컬럼 선정
      ↓
   2. 효율성 검토 & 최적화
      ↓
   3. 인덱스 정의서 작성

   ```

7. **인덱스 대상 선정 기준**
   - 테이블 선정 기준
     - 랜덤 액세스가 **빈번한** 테이블
     - 특정 범위/순서로 조회 필요한 테이블
     - 다른 테이블과 **순차적 조인** 발생 테이블
   - 컬럼 선정 기준
     | 기준 | 설명 |
     | ---------- | ------------------------------------- |
     | **분포도** | **10~15% 이내**인 컬럼 |
     | 조회 조건 | 자주 조회/출력 조건으로 사용 |
     | 수정 빈도 | 수정이 **빈번하지 않은** 컬럼 |
     | 정렬/그룹 | ORDER BY, GROUP BY, UNION 빈번한 컬럼 |
     | 자동 생성 | PK, Unique 제약조건 컬럼 |

     💡 **분포도 공식**: (컬럼값의 평균 Row 수 / 테이블 총 Row 수) × 100

8. **인덱스 설계 시 고려사항**
   - 새 인덱스 → 기존 **액세스 경로에 영향**
   - 인덱스 **너무 많으면** → 오버헤드 발생
   - **넓은 범위** 인덱스 → 오버헤드 발생
   - **추가 저장 공간** 필요
   - 인덱스와 테이블 **저장 공간 분리** 설계

---

### 3. 뷰(View) 설계

1. **뷰(View)란?**

   > **한 줄 정의:** 하나 이상의 기본 테이블에서 유도된 **가상 테이블** (실제로 데이터를 저장하지 않음)

2. **뷰 핵심 개념**

   | 항목      | 내용                                    |
   | --------- | --------------------------------------- |
   | 본질      | **가상 테이블** (물리적으로 존재 X)     |
   | 유도      | 기본 테이블에서 유도                    |
   | 저장      | 뷰 **정의만** 저장됨 (데이터 X)         |
   | 실행      | 질의 시 기본 테이블로 **대체**되어 실행 |
   | 생성/삭제 | **CREATE** / **DROP**                   |

   ```
     [테이블1]  [테이블2]  [테이블3]
       \         |         /
        \        |        /
          ────[ 뷰 A ]────
               (가상)
   ```

3. **뷰의 특징 (시험 필수!)**

   | 특징          | 설명                                       |
   | ------------- | ------------------------------------------ |
   | 가상 테이블   | 물리적으로 **구현 안 됨**                  |
   | 논리적 독립성 | 기본 테이블 변경에 영향 적음               |
   | 보안          | 특정 데이터만 보여줘서 **보안 유지**       |
   | 편의성        | 조인 최소화, 명령문 간단                   |
   | 뷰 기반 뷰    | 뷰를 기초로 다른 뷰 정의 가능              |
   | 연쇄 삭제     | 기본 테이블 삭제 → 관련 뷰도 **자동 삭제** |

4. **삽입/삭제/갱신 조건**

   > 기본 테이블의 **기본키를 포함**한 속성으로 구성해야 가능!

5. **뷰의 장단점**
   1. 장점

      | 장점                 | 설명                          |
      | -------------------- | ----------------------------- |
      | **논리적 독립성**    | 기본 테이블 구조 변경에 유연  |
      | **다양한 요구 지원** | 동일 데이터, 다양한 관점 제공 |
      | **관리 간단**        | 필요한 데이터만 정의          |
      | **자동 보안**        | 접근 제어로 데이터 보호       |

   2. 단점

      | 단점               | 설명                         |
      | ------------------ | ---------------------------- |
      | **인덱스 불가**    | 독립적인 인덱스 가질 수 없음 |
      | **정의 변경 불가** | ALTER 불가, 삭제 후 재생성   |
      | **연산 제약**      | 삽입/삭제/갱신에 제약 있음   |

6. **뷰 설계 순서**

   ```
   1. 대상 테이블 선정
         ↓
   2. 대상 컬럼 선정 (보안 주의!)
         ↓
   3. 뷰 정의서 작성
   ```

7. 대상 테이블 선정 기준
   - 외부 시스템과 **인터페이스** 관련 테이블
   - CRUD 매트릭스에서 **자주 조인**되는 테이블
   - **인라인 뷰**로 자주 접근되는 테이블
   - **보안 유지**해야 할 컬럼 주의!

8. **뷰 설계 시 고려사항**
   1. 조인 단순화 : 자주 조인되는 테이블 → 뷰로 생성
   2. 업무별 관점 제공 : 같은 테이블도 업무에 따라 다르게 제공
   3. 보안 유지 : 민감한 정보는 뷰에서 제외

### 4. 파티션 설계

1.  **파티션(Partition)이란?**

    > **한 줄 정의:** 대용량 테이블/인덱스를 **작은 논리적 단위**로 나눠서 분산 저장하는 기법

2.  **파티션 핵심 개념**

    | 항목      | 내용                                |
    | --------- | ----------------------------------- |
    | 목적      | 대용량 DB **성능 향상** & 관리 용이 |
    | 처리 단위 | **테이블** 단위                     |
    | 저장 단위 | **파티션** 단위                     |
    | 분할 기준 | **파티션키** 또는 인덱스키          |

    ```
    [대용량 테이블]
          ↓ 파티셔닝
    ┌─────┬─────┬─────┐
    │파티션│파티션│파티션│ ← 물리적으로 분산 저장
    │  1  │  2  │  3  │
    └─────┴─────┴─────┘
    ```

3.  **파티션 장단점**
    1. 장점

       | 장점               | 설명                           |
       | ------------------ | ------------------------------ |
       | **성능 향상**      | 액세스 범위 축소 → 쿼리 빨라짐 |
       | **디스크 성능↑**   | 데이터 분산 저장               |
       | **백업/복구 빠름** | 파티션별로 수행                |
       | **장애 최소화**    | 손상 범위 줄임                 |
       | **가용성 향상**    | I/O 분산                       |

    2. 단점

       | 단점            | 설명                           |
       | --------------- | ------------------------------ |
       | 관리 복잡       | 세분화로 세심한 관리 필요      |
       | 조인 비용↑      | 테이블 간 조인 비용 증가       |
       | 소용량엔 비효율 | **작은 테이블**은 오히려 성능↓ |

4.  **파티션 종류 5가지**

    | 종류           | 한 줄 정의                    | 특징                   |
    | -------------- | ----------------------------- | ---------------------- |
    | **범위 분할**  | 지정 열의 **값 범위**로 분할  | 일별/월별/분기별       |
    | **해시 분할**  | **해시 함수** 결과값으로 분할 | 데이터 **고르게** 분산 |
    | **조합 분할**  | 범위 분할 + 해시 분할         | 범위 파티션이 클 때    |
    | **목록 분할**  | 지정 열의 **목록**으로 분할   | 특정 값 그룹화         |
    | **라운드로빈** | **순차적**으로 균일 분배      | 기본키 필요 없음       |
    - 상세 설명
      1. 범위 분할 (Range)
         - 열 값의 **범위를 기준**으로 분할
           ```
           판매일자 기준:
           ├─ 2023년 데이터 → 파티션1
           ├─ 2024년 데이터 → 파티션2
           └─ 2025년 데이터 → 파티션3
           ```
      2. 해시 분할 (Hash)
         - 해시 함수 결과값으로 **균등 분할**
           - 범위 분할의 **데이터 집중** 문제 해결
           - 어디에 있는지 **판단 불가**
           - 고객번호, 주민번호 등 **균일한 컬럼**에 효과적
      3. 조합 분할 (Composite)
         - 범위 분할 후 **다시 해시 분할**
         - 범위 파티션이 **너무 클 때** 유용
      4. 목록 분할 (List)
         - 특정 열 값의 **목록**을 만들어 분할
         ```
         국가 기준:
         ├─ '아시아' 목록(한국, 일본) → 파티션1
         └─ '미주' 목록(미국, 캐나다) → 파티션2
         ```
      5. 라운드 로빈 분할 (Round Robin)
         - 레코드를 **순차적으로 균일 분배**
         - 기본키 **필요 없음**

5.  **인덱스 파티션**
    - 인덱스 파티션은 파티션된 테이블의 데이터를 관리하기 위해 인덱스를 나눈 것
    - 인덱스 파티션의 종류
      - 테이블 종속 여부에 따라
        | 종류 | 한 줄 정의 | 관리 |
        | ---------- | --------------------------------------- | :-----: |
        | **Local** | 테이블 파티션 : 인덱스 파티션 = **1:1** | 쉬움 |
        | **Global** | 테이블과 인덱스가 **독립적** 구성 | 어려움 |

        ```
        Local: 테이블(판매일자) ↔ 인덱스(판매일자) 동일 기준
        Global: 테이블(판매일자) ↔ 인덱스(지점) 다른 기준
        ```

      - 파티션키 위치에 따라

        | 종류             | 한 줄 정의                         |
        | ---------------- | ---------------------------------- |
        | **Prefixed**     | 파티션키 = 인덱스 **첫 번째 컬럼** |
        | **Non-Prefixed** | 파티션키 ≠ 인덱스 첫 번째 컬럼     |

        ```
        Prefixed: 파티션키(판매일자) = 인덱스키(판매일자, ...)
        Non-Prefixed: 파티션키(판매일자) ≠ 인덱스키(품목코드, ...)
        ```

6.  **파티션키 선정 시 고려사항**
    - 테이블 **접근 유형**에 맞게 선정
    - 이력 데이터: **생성주기 = 소멸주기** 일치
    - 좋은 파티션키:
      - 매일 생성되는 **날짜 컬럼**
      - 백업 기준이 되는 날짜 컬럼
      - 파티션 간 **이동이 없는** 컬럼
      - 데이터 분포가 **양호한** 컬럼

### 5. 분산 데이터베이스 설계

1. **분산 데이터베이스란?**

   > **한 줄 정의:** 논리적으로는 **하나**지만, 물리적으로는 **여러 사이트에 분산**되어 있는 데이터베이스

2. **분산 데이터베이스 핵심 개념**

   | 항목   | 내용                                 |
   | ------ | ------------------------------------ |
   | 논리적 | **하나**의 시스템                    |
   | 물리적 | **여러 사이트**에 분산               |
   | 목적   | 데이터 처리를 **해당 지역**에서 해결 |

   ```
         [논리적으로 하나]
               ↓
   ┌─────────────────────────┐
   │    분산 데이터베이스         │
   └─────────────────────────┘
      ↙      ↓      ↘
   [서울]   [부산]   [대전]  ← 물리적으로 분산
   ```

3. **구성 요소 3가지**

   | 구성 요소             | 한 줄 정의                                  |
   | --------------------- | ------------------------------------------- |
   | **분산 처리기**       | 자체 처리 능력을 가진 분산된 컴퓨터 시스템  |
   | **분산 데이터베이스** | 지역 특성에 맞게 구성된 분산 DB             |
   | **통신 네트워크**     | 분산 처리기들을 연결해 하나처럼 작동하게 함 |

4. **분산 DB의 목표 - 4가지 투명성**

   | 투명성          | 한 줄 정의                                     |
   | --------------- | ---------------------------------------------- |
   | **위치 투명성** | 실제 위치 몰라도 **논리적 명칭**만으로 접근    |
   | **중복 투명성** | 여러 곳에 중복되어도 **하나처럼** 사용         |
   | **병행 투명성** | 여러 트랜잭션 **동시 실행**해도 결과 영향 없음 |
   | **장애 투명성** | 장애에도 트랜잭션을 **정확하게** 처리          |

5. **분산 DB 장단점**
   1. 장점
      | 장점 | 설명 |
      | ----------------- | ------------------------- |
      | **지역 자치성** | 각 지역에서 자체 관리 |
      | **자료 공유성** | 데이터 공유 향상 |
      | **성능 향상** | 분산 처리로 속도↑ |
      | **신뢰성/가용성** | 중앙 장애가 전체에 영향 X |
      | **확장 용이** | 점진적 용량 확장 가능 |
   2. 단점
      | 단점 | 설명 |
      | --------------- | ------------------- |
      | **복잡성** | DBMS 기능이 복잡 |
      | **설계 어려움** | DB 설계가 어려움 |
      | **비용 증가** | 개발/처리 비용↑ |
      | **오류 증가** | 잠재적 오류 가능성↑ |

6. **분산 설계 방법 3가지**
   1. 테이블 위치 분산
      - 테이블을 **각기 다른 서버**에 배치
      - 테이블 구조 변경 X
      - 테이블 중복 X

      ```
      본사 서버: 사원, 부서, 거래업체
      지사 서버: 상품, 판매현황
      ```

   2. 분할 (Fragmentation)
      - 테이블 데이터를 **쪼개서** 분산
      - 분할 규칙 3가지
        | 규칙 | 한 줄 정의 |
        | ------------------ | -------------------------------------- |
        | **완전성** | **전체** 데이터 대상으로 분할 |
        | **재구성** | 분할된 데이터를 **원래대로 복원** 가능 |
        | **상호 중첩 배제** | 분할된 데이터끼리 **중복 X** |
      - 분할 방법
        | 방법 | 한 줄 정의 | 기준 |
        | ------------- | -------------------------- | ----------------- |
        | **수평 분할** | **행(Row)** 단위로 분할 | 특정 속성 값 기준 |
        | **수직 분할** | **열(Column)** 단위로 분할 | 컬럼 단위 |

        ```
        [원본 테이블]
        사번 | 이름 | 부서   | 나이
        -----|------|--------|-----
        001  | 홍길동| 영업부 | 30
        002  | 김철수| 총무부 | 28

        수평 분할 (부서 기준):
        ├─ 영업부 테이블: 001, 홍길동, 영업부, 30
        └─ 총무부 테이블: 002, 김철수, 총무부, 28

        수직 분할 (컬럼 기준):
        ├─ 테이블1: 사번, 이름
        └─ 테이블2: 부서, 나이
        ```

   3. 할당 (Allocation)
      - 동일한 분할을 **여러 서버에 생성**
        | 방식 | 한 줄 정의 |
        | --------------- | ---------------------------------- |
        | **비중복 할당** | 단일 노드에만 분할 존재 |
        | **중복 할당** | 동일 테이블을 다른 서버에 **복제** |
        - 중복 할당 방식
          - **부분 복제**: 일부만 복제
          - **완전 복제**: 전체 복제

### 6. 데이터베이스 보안 / 암호화

1. **데이터베이스 보안이란?**

   > **한 줄 정의:** 권한 없는 사용자의 **액세스를 금지**하기 위한 기술

2. **DB 보안 핵심 개념**

   | 항목      | 내용                                          |
   | --------- | --------------------------------------------- |
   | 목적      | **비인가 사용자 접근 차단**                   |
   | 보안 단위 | 테이블 전체 ~ 특정 행/열의 데이터 값까지 다양 |
   | 권한      | 사용자마다 **다른 접근 권한** 부여            |

3. **암호화(Encryption)란?**
   - 평문을 **암호문으로 변환**하여 지정된 수신자만 내용을 알 수 있게 하는 것

4. **암호화 과정**

   ```
   [평문] ──암호화──→ [암호문] ──복호화──→ [평문]
         (Encryption)        (Decryption)
   ```

   | 용어       | 한 줄 정의           |
   | ---------- | -------------------- |
   | **암호화** | 평문 → 암호문 (보호) |
   | **복호화** | 암호문 → 평문 (복원) |

5. **암호화 방식 2가지**
   1. 개인키 암호 방식 (Private Key)
      - **동일한 키**로 암호화/복호화 (= 대칭키)

      | 항목          | 내용                                      |
      | ------------- | ----------------------------------------- |
      | 키 개수       | **1개** (동일)                            |
      | 다른 이름     | **대칭 암호**, 비밀키, 단일키             |
      | 키 관리       | 제3자에게 노출 X, 권한 있는 사용자만 공유 |
      | 대표 알고리즘 | **DES**, LUCIFER                          |

      ```
            [동일한 키]
                  ↓
      평문 ──암호화──→ 암호문 ──복호화──→ 평문
         (비밀키)         (비밀키)
      ```

   2. 공개키 암호 방식 (Public Key)
      - **서로 다른 키**로 암호화/복호화 (= 비대칭키)

      | 항목          | 내용                        |
      | ------------- | --------------------------- |
      | 키 개수       | **2개** (다름)              |
      | 다른 이름     | **비대칭 암호**             |
      | 공개키        | 암호화용, **공개**          |
      | 비밀키        | 복호화용, **관리자만 보유** |
      | 대표 알고리즘 | **RSA**                     |

      ```
      평문 ──암호화──→ 암호문 ──복호화──→ 평문
         (공개키)         (비밀키)
            공개!           비밀!
      ```

   3. 개인키 vs 공개키 비교 (핵심!)

      |    구분     | 개인키 (대칭)  | 공개키 (비대칭) |
      | :---------: | :------------: | :-------------: |
      | **키 개수** | **1개** (동일) | **2개** (다름)  |
      |  암호화 키  |     비밀키     |     공개키      |
      |  복호화 키  | 비밀키 (동일)  |  비밀키 (다름)  |
      |  다른 이름  |  대칭, 단일키  |     비대칭      |
      |    대표     |    **DES**     |     **RSA**     |
      |    속도     |      빠름      |      느림       |
      |   키 관리   |     어려움     |      쉬움       |

---

### 7. 데이터베이스 보안 - 접근통제

1. **접근통제란?**

   > **한 줄 정의:** 데이터 객체와 사용자(주체) 사이의 **정보 흐름을 제한**하여 불법 접근을 예방하는 것

2. **접근통제가 하는 일**
   - 비인가 사용자의 **접근 감시**
   - 접근 요구자의 **사용자 식별**
   - 접근 요구의 **정당성 확인 및 기록**
   - 보안 정책에 따른 **승인/거부**

3. **접근통제 방식 3가지 (시험 필수!)**

   | 방식            | 한 줄 정의                       |     권한 지정     | 기준 |
   | --------------- | -------------------------------- | :---------------: | ---- |
   | **DAC** (임의)  | **신원**에 따라 접근 권한 부여   | 데이터 **소유자** | 신원 |
   | **MAC** (강제)  | **등급** 비교하여 접근 권한 부여 |    **시스템**     | 등급 |
   | **RBAC** (역할) | **역할**에 따라 접근 권한 부여   |  **중앙관리자**   | 역할 |
   1. DAC (임의 접근통제)
      - 사용자의 **신원(Identity)**에 따라 접근 권한 부여
        | 항목 | 내용 |
        | ---------- | ------------------------------------------------------- |
        | 영문 | Discretionary Access Control |
        | 권한 지정 | **데이터 소유자** |
        | 특징 | 객체 생성자가 모든 권한 보유, 다른 사용자에게 허가 가능 |
        | SQL 명령어 | **GRANT** (부여), **REVOKE** (회수) |
   2. MAC (강제 접근통제)
      - 주체와 객체의 **보안 등급**을 비교하여 접근 권한 부여
        | 항목 | 내용 |
        | --------- | ----------------------------------------- |
        | 영문 | Mandatory Access Control |
        | 권한 지정 | **시스템** |
        | 특징 | 객체별 보안 등급, 사용자별 인가 등급 부여 |
      - 등급별 권한
        | 객체 등급 | 읽기 | 수정 | 등록 |
        | :-------: | :--: | :--: | :--: |
        | 높음 | ❌ | ❌ | ❌ |
        | 같음 | ⭕ | ⭕ | ⭕ |
        | 낮음 | ⭕ | ❌ | ❌ |
   3. RBAC (역할기반 접근통제)
      - 사용자의 **역할(Role)**에 따라 접근 권한 부여
        | 항목 | 내용 |
        | --------- | ------------------------------------------------------ |
        | 영문 | Role Based Access Control |
        | 권한 지정 | **중앙관리자** |
        | 특징 | DAC + MAC 단점 보완, **다중 프로그래밍 환경**에 최적화 |
        | 예시 | 인사담당자, DBA 등 역할별 권한 |

4. **MAC의 보안 모델 4가지**
   | 모델 | 한 줄 정의 |
   | --------------- | ---------------------------------------------- |
   | **벨-라파듈라** | **기밀성** 중심, 군대 보안 레벨 기반 |
   | **비바** | 벨-라파듈라 보완, **무결성** 최초 모델 |
   | **클락-윌슨** | 무결성 중심 **상업용**, 프로그램 통해서만 접근 |
   | **만리장성** | **이해충돌** 관계 객체 간 접근 통제 |
   1. **벨-라파듈라 모델 (기밀성)**
      - 자신 등급 **이하** 문서 → 읽기 ⭕
      - 자신 등급 **이상** 문서 → 쓰기 ⭕
   2. **비바 모델 (무결성)**
      - 벨-라파듈라의 **반대**
      - 비인가자의 **데이터 변형 방지**

5. **접근통제 3요소**

   ```
   ┌─────────────────────────────────────┐
   │          접근통제 3요소                │
   ├───────────┬───────────┬─────────────┤
   │   정책     │  메커니즘    │    보안모델   │
   │  (Policy) │(Mechanism)│   (Model)   │
   └───────────┴───────────┴─────────────┘
   ```

6. **접근통제 정책 3가지**
   | 정책 | 한 줄 정의 | 종류 |
   | ------------- | --------------------------- | -------- |
   | **신분 기반** | 주체/그룹 **신분**으로 제한 | IBP, GBP |
   | **규칙 기반** | 주체 **권한**으로 제한 | MLP, CBP |
   | **역할 기반** | 주체 **역할**로 제한 | RBAC |

7. **접근통제 메커니즘**
   | 메커니즘 | 한 줄 정의 |
   | ----------------------- | -------------------------------------------------- |
   | **접근통제 목록 (ACL)** | **객체** 기준, 어떤 주체가 어떤 행위 가능한지 기록 |
   | **능력 리스트** | **주체** 기준, 허가된 자원/권한 기록 |
   | **보안 등급** | 등급 기반 접근 승인 여부 결정 |
   | **패스워드** | 자신임을 증명하는 인증 방법 |
   | **암호화** | 평문 → 암호문 변환 |

### 8. 데이터베이스 백업

1. **데이터베이스 백업이란?**

   > **한 줄 정의:** 장애에 대비하여 데이터를 **보호하고 복구**하기 위한 작업

2. **백업 핵심 개념**
   | 항목 | 내용 |
   | ---- | ----------------------------- |
   | 목적 | 치명적인 **데이터 손실 방지** |
   | 주기 | **정기적** 백업 필요 |
   | DBMS | 복구 기능 제공 |

3. **데이터베이스 장애 유형 5가지**

   | 장애 유형                | 한 줄 정의                               |
   | ------------------------ | ---------------------------------------- |
   | **사용자 실수**          | 테이블 삭제, 잘못된 트랜잭션 처리        |
   | **미디어 장애**          | CPU, 메모리, 디스크 등 **하드웨어 장애** |
   | **구문 장애**            | 프로그램 오류, 공간 부족                 |
   | **사용자 프로세스 장애** | 프로그램 비정상 종료, 네트워크 이상      |
   | **인스턴스 장애**        | 정전, 시스템 파일 파손으로 **서버 중단** |

4. **로그 파일**

   > **한 줄 정의:** DB의 상태 변화를 **시간순으로 기록**한 파일 (복구의 핵심 자료!)
   - 로그 파일 역할

     | 작업     | 한 줄 정의                       |
     | -------- | -------------------------------- |
     | **UNDO** | 과거 상태로 **복귀** (취소)      |
     | **REDO** | 현재 상태로 **재생** (다시 실행) |

   - 로그 파일 기록 시점
     - 트랜잭션 **시작** 시점
     - **Rollback** 시점
     - 데이터 **입력/수정/삭제** 시점
   - 로그 파일 내용
     - 트랜잭션 식별자
     - 데이터 식별자
     - **Before Image** (갱신 이전 값)
     - **After Image** (갱신 이후 값)
   - 복구 알고리즘 4가지 (시험 필수!)
     | 알고리즘 | UNDO | REDO | 설명 |
     | ------------------- | :--: | :--: | ---------------- |
     | **NO-UNDO/REDO** | ❌ | ⭕ | 비동기적 갱신 |
     | **UNDO/NO-REDO** | ⭕ | ❌ | 동기적 갱신 |
     | **UNDO/REDO** | ⭕ | ⭕ | 동기/비동기 혼합 |
     | **NO-UNDO/NO-REDO** | ❌ | ❌ | 다른 영역에 기록 |
     1. NO-UNDO/REDO (비동기적)
        - 완료 전엔 DB에 기록 안 함 → 취소 불필요, 재실행 필요
        - **NO-UNDO**: 완료 전 DB 기록 X → 취소할 것 없음
        - **REDO**: 버퍼에만 있고 저장매체엔 없음 → 재실행 필요
     2. UNDO/NO-REDO (동기적)
        - 완료 전에 이미 저장매체에 기록 → 취소 필요, 재실행 불필요
        - **UNDO**: 완료 전 파손 시 → 취소 필요
        - **NO-REDO**: 이미 저장됨 → 재실행 불필요
     3. UNDO/REDO (동기/비동기)
        - 둘 다 필요한 경우
     4. NO-UNDO/NO-REDO (다른 영역)
        - 다른 영역에 이미 기록됨 → 둘 다 불필요

5. **백업 종류 2가지**

   | 종류          | 한 줄 정의                | 방법          | 복구 수준 |
   | ------------- | ------------------------- | ------------- | :-------: |
   | **물리 백업** | DB **파일** 자체를 백업   | 운영체제 이용 | 완전/시점 |
   | **논리 백업** | DB **논리적 객체**를 백업 | DBMS 유틸리티 | 시점까지  |
   1. 물리 백업 vs 논리 백업
      | 구분 | 물리 백업 | 논리 백업 |
      | ---------------- | :-------: | :-------: |
      | 속도 | **빠름** | 느림 |
      | 작업 | **단순** | 복잡 |
      | 문제 파악 | 어려움 | **쉬움** |
      | 데이터 손상 방지 | 보통 | **우수** |
   2. 물리 백업 복구 수준
      | 조건 | 복구 수준 |
      | ----------------------- | --------------- |
      | 로그 파일 백업 **있음** | **완전 복구** |
      | 로그 파일 백업 **없음** | 백업 시점까지만 |

### 9. 스토리지

1. **스토리지(Storage)란?**

   > **한 줄 정의:** 대용량 데이터 저장을 위해 **서버와 저장장치를 연결**하는 기술
   1. 스토리지 종류 3가지 (시험 필수!)
      | 종류 | 한 줄 정의 | 연결 방식 |
      | :-----: | ---------------------------- | ---------------------------- |
      | **DAS** | **직접 연결** (전용 케이블) | 서버 ↔ 저장장치 |
      | **NAS** | **네트워크 연결** (Ethernet) | 서버 ↔ 네트워크 ↔ 저장장치 |
      | **SAN** | **전용 네트워크** (광케이블) | 서버 ↔ FC스위치 ↔ 저장장치 |
      1. DAS (Direct Attached Storage)
         - 서버와 저장장치를 **전용 케이블로 직접 연결** (외장하드 연결 방식)
         - 특징
           | 장점 | 단점 |
           | ------------------ | ----------------------- |
           | 속도 **빠름** | 파일 공유 **불가** |
           | 설치/운영 **쉬움** | 다른 서버 접근 **불가** |
           | 비용 **저렴** | 확장성/유연성 **낮음** |
         - 적합 환경
           - 저장 데이터가 **적고**
           - **공유 불필요**한 환경
           ```
           [서버] ──전용케이블──→ [스토리지]
                    (직접 연결)
           ```
      2. NAS (Network Attached Storage)
         - 서버와 저장장치를 **네트워크(Ethernet)로 연결**, 파일 공유 가능
         - 특징
           | 장점 | 단점 |
           | ---------------------- | -------------------------- |
           | **파일 공유** 가능 | 접속 증가 시 **성능 저하** |
           | 어디서나 접근 가능 | DAS보다 느림 |
           | 확장성/유연성 **우수** | |
         - 핵심 포인트
           - **NAS Storage**가 저장장치 직접 관리
           - **Ethernet 스위치** 사용
           ```
           [서버1]  [서버2]  [서버3]
              \      |      /
              ── [Ethernet 스위치] ──
                       |
                 [NAS Storage] ← 파일 관리 기능 내장
           ```
      3. SAN (Storage Area Network)
         - DAS의 **빠른 속도** + NAS의 **파일 공유** = **전용 네트워크 구성**
         - 특징
           | 장점 | 단점 |
           | ----------------------------- | ------------------------- |
           | 속도 **빠름** (광케이블) | 초기 비용 **높음** |
           | 파일 **공유** 가능 | 별도 네트워크 구축 필요 |
           | 확장성/유연성/가용성 **최고** | 기존 장비 업그레이드 필요 |
           | 높은 트랜잭션 처리 효과적 | |
         - 핵심 포인트
           - **광 채널(FC) 스위치** 사용
           - **광케이블** 연결 → 빠른 속도
           - 여러 저장장치/백업장비 **단일화** 가능

           ```
           [서버1]  [서버2]  [서버3]
              \      |      /
              ── [FC 스위치] ── (광케이블)
                       |
              ┌────────┴────────┐
           [스토리지1]  [스토리지2]  [백업장비]
           ```

2. **DAS vs NAS vs SAN 비교**

   |    구분    |      DAS      |         NAS         |        SAN         |
   | :--------: | :-----------: | :-----------------: | :----------------: |
   |  **연결**  | 직접 (케이블) | 네트워크 (Ethernet) | 전용 네트워크 (광) |
   |  **속도**  |     빠름      |        보통         |   **가장 빠름**    |
   |  **공유**  |      ❌       |         ⭕          |         ⭕         |
   | **확장성** |     낮음      |        높음         |   **가장 높음**    |
   |  **비용**  |     저렴      |        중간         |      **비쌈**      |
   |  **관리**  |     서버      |     NAS Storage     |     FC 스위치      |
   |  **예시**  |   외장하드    |      공유 폴더      |     데이터센터     |
