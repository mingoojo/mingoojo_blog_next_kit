---
title: '[정보처리기사 자격증] 1.소프트웨어 설계 > 3장 애플리케이션 설계 (WEEK 3)'
date: '2025-12-31'
tags: ['dev', 'license']
draft: false
summary: 정보처리기사 3주차 내용정리_2 - 애플리케이션 설계
# https://velog.io/@alpaka206/45.-애플리케이션-테스트의-분류
---

import ImageWithCaption from '@/components/mdxComponents/ImageWithCaption'

### 1. 소프트웨어 아키텍쳐

> 소프트웨어 시스템을 구성하는 주요 요소들과 그 요소들 간의 관계, 그리고 이를 지탱하는 설계 원칙을 정의한 구조

1.  **상위 설계와 하위 설계**
    - | 구분      | 상위 설계                       | 하위 설계                        |
      | --------- | ------------------------------- | -------------------------------- |
      | 요약      | 무엇을, 어떤 구조로 만들 것인가 | 그걸 실제로 어떻게 구현할 것인가 |
      | 별칭      | 아키텍처 설계, 예비 설계        | 모듈 설계, 상세 설계             |
      | 설계 대상 | 시스템의 전체적인 구조          | 시스템의 내부구조 및 행위        |
      | 세부 목록 | 구조, DB, 인터페이스            | 컴포넌트 자료구조 알고리즘       |
      | 산출물    | 아키텍처 다이어그램             | 클래스 / API 설계                |
      | 대상      | PM, 아키텍트, 리드              | 개발자                           |

2.  **모듈화**

    > 소프트웨어 성능 및 수정, 재사용 용이성을 위해 시스템의 기능들을 모듈 단위로 나누는 것
    - 특징
      - 기능 분리로 인해 인터페이스가 단순해짐
      - 효율적 관리 가능
      - 모듈의 갯수가 상승하면 관리의 피로도가 높아지고, 너무 적어지면 모듈별 기능이 커져 개발 비용상승과 관심사의 분리가 안된다.

3.  **추상화**

    > 공통적이고 중요한 개념만 드러내고, 세부 구현은 숨기는 것
    - 추상화의 유형
      - 과정 추상화: 자세한 수행과정을 정의하지 않고 전반적인 흐름만 파악할 수 있게 설계하는 방법
      - 데이터 추상화: 데이터의 세부적인 속성이나 용도를 정의하지 않고 데이터 구조를 대표할 수 있는 표현으로 대체하는 방법
      - 제어 추상화: 이벤트 발생의 정확한 절차나 방법을 정의하지 않고 대표할 수 있는 표현으로 대체하는 방법

4.  **단계적분해**

    > 복잡한 문제를 한 번에 해결하려 하지 않고,큰 개념 → 작은 개념으로 단계적으로 쪼개며 설계하는 방법
    - 추상화의 반복에 의해 세분화
    - 소프트웨어의 기능에서부터 시작하여 점차적으로 구체화하고, 알고리즘, 자료 구조 등 상세한 내역은 가능한 한 뒤로 미루어 진행한다.

5.  **정보 은닉**

    > 모듈 내부의 구현 세부사항을 외부에 노출하지 않고,필요한 최소한의 인터페이스만 공개하는 설계 원칙
    - 다른 모듈과 커뮤니케이션이 필요할때 정해진 방법으로 인터페이스를 통해 주고받는다.
    - 모듈의 독립적 수행이 가능하고, 다른 모듈에 영향을 주지 않는다.(수정, 시험, 유지보수 용이)

6.  **아키텍쳐 설계 과정**
    - 설계목표 설정 > 시스템 타입 결정(시스템의 성격을 큰 틀에서 규정하는 단계) > 아키텍처 패턴 적용 > 서브시스템 구체화 > 검토

### 2. 아키텍처 패턴

1.  **아키텍처 패턴의 개요**

    > 아키텍처 패턴은 소프트웨어 아키텍처 설계 시 참고할 수 있는 전형적인 구조적 해결 방식
    1. 장점
       - 검증된 구조를 활용하여 시행착오를 줄이고 시간 단축
       - 안정적인 설계 > 고품질의 개발
       - 개발자 간 공통된 구조를 인식 > 의사소통 용이
       - 유지보수 용이
       - 특성을 예측 가능

2.  **파이프-필터 패턴**

    > 데이터를 처리 단계(Filter)로 나누고,각 단계를 파이프(Pipe)로 연결하여 순차적으로 처리하는 아키텍처 패턴
    1. 기본 구성 요소
       - 필터(Filter) : 입력 데이터를 받아 처리하고 출력하는 독립적인 처리 단위
       - 파이프(Pipe) : 필터와 필터를 연결하는 데이터 전달 통로
    2. 장점
       - 높은 재사용성
       - 확장성
       - 유지보수 용이
       - 병렬 처리 가능
    3. 특징
       - 파이프–필터 패턴에서는 각 필터가 독립적으로 동작하기 때문에, 필터에서 다음 필터로 데이터를 넘길 때 데이터 형태를 바꾸는 비용(오버헤드)이 발생한다.
       - 파이프-필터 패턴은 데이터 변환, 버퍼링, 동기화 등에 주로 사용된다.
       - 대표적으로 UNIX의 쉘(Shell)이 있다.

3.  **모델-뷰-컨트롤러 패턴(Model-View-Controller Pattern)**

    > 애플리케이션을 Model, View, Controller 세 부분으로 분리하여역할을 명확히 하고 유지보수성과 확장성을 높이는 아키텍처 패턴
    1. 모델 : 서브시스템의 핵심 기능과 데이터를 보관한다.
    2. 뷰 : 사용자에게 정보를 표시한다.
    3. 컨트롤러 : 사용자로부터 입력된 변경 요청을 처리하기 위해 모델에게 명령을 보낸다.

4.  **레이어 패턴(Layers pattern)**

    > 시스템을 계층(Layer)으로 구분하여 구성하는 고전적인 방법
    - 레이어 패턴은 각각의 서브시스템들이 계층 구조를 이루며, 하위 계층은 상위 계층에 대한 서비스 제공자가 되고, 상위 계층은 하위 계층의 클라이언트가 된다.
    - 레이어 패턴은 서로 마주보는 두 개의 계층 사이에서만 상호작용이 이루어지며, 변경 사항을 적용할 때도 서로 마주보는 두 개의 계층에만 영향을 미치므로 변경 작업이 용이하다.
    - 레이어 패턴은 특정 계층만을 교체해 시스템을 개선하는 것이 가능하다.

5.  **클라이언트-서버 패턴(Client-Server Pattern)**

    > 서비스를 요청하는 클라이언트(Client)와 요청을 처리하고 자원을 제공하는 서버(Server)로 역할을 분리하는 아키텍처 패턴
    1. 클라이언트
       - 사용자 인터페이스 제공
       - 요청 생성 및 전송
       - 결과 수신 후 표시
    2. 서버
       - 요청 처리
       - 비지니스 로직 처리
       - 데이터 관리

6.  **마스터슬레이브 패턴(Master-Slave Pattern)**

    > 하나의 마스터(Master)가 전체 작업을 관리·분배하고, 여러 슬레이브(Slave)가 실제 작업을 수행하는 아키텍처 패턴
    1. Master (마스터)
       - 작업 분할
       - 슬레이브에게 작업 할당
       - 결과 수집 및 통합
       - 전체 흐름 제어
    2. Slave (슬레이브)
       - 마스터로부터 작업 수신
       - 실제 계산/처리 수행
       - 결과 반환

### 3. 객체 지향

1.  **객체 지향의 개요**

    > 현실 세계의 개념을 객체(Object)로 모델링하여 객체 간의 상호작용으로 소프트웨어를 구성하는 개발 패러다임(기능이 아닌 객체를 중심으로 개발)
    1. 객체 : 데이터(속성)와 그 데이터를 처리하는 함수(메서드)를 함께 묶은 단위
    2. 메세지 : 객체들 간의 상호작용을 할때 사용되는 수단, 객체에게 행위를 지시하는 명령
    3. 클래스
       - 클래스는 객체가 어떤 속성과 행동을 가질지 미리 정의해 둔 설계도
       - 클래스에 속한 각각의 객체를 인스턴스(Instance)라 하며, 클래스로부터 새로운 객체를 생성하는 것을 인스턴스화(Instantiation)라고 한다.
       - 예시
         - ```java
             User user1 = new User();
             User user2 = new User();
             //	•	User → 클래스
             // •	user1, user2 → 객체
             // •	user1, user2는 User 클래스의 인스턴스
           ```
    4. 캡슐화
       - 캡슐화는 데이터(속성)와 데이터를 처리하는 함수를 하나로 묶는 것
       - 캡슐화된 객체는 세부 내용이 은폐되어 외부에서의 접근이 제한적이기 때문에 외부 모듈의 변경으로 인한 파급 효과가 적다.
       - 캡슐화를 통해 인터페이스 단순화
       - 재사용 용이
    5. 상속
       - 기존 클래스의 속성과 메서드를 물려받아 새로운 클래스를 만드는 것
       - 상속을 이용하면 하위 클래스는 상위 클래스의 모든 속성과 연산을 자신의 클래스내에서 다시 정의하지 않고서도 즉시 자신의 속성으로 사용할 수 있음
       - 상속받은 속성과 연산 외에 새로운 속성과 연산을 첨가하여 사용할 수 있다.
       - 예시
         - ```java
           class Child extends Parent {
             }
           ```

    6. 다형성
       - 하나의 참조 타입으로 여러 형태의 객체를 다룰 수 있는 성질
       - 객체(클래스)들은 동일한 메소드명을 사용하며 같은 의미의 응답
       - 응용 프로그램 상에서 하나의 함수나 연산자가 두 개 이상의 서로 다른 클래스의 인스턴스들을 같은 클래스에 속한 인스턴스처럼 수행할 수 있도록 하는 것
       - 예시
         - ```java
             //Payment.java
             interface Payment {
               void pay();
             }

           ```

         - ```java
             //CardPayment.java
             class CardPayment implements Payment {
                 public void pay() {
                     System.out.println("카드 결제");
                 }
             }
             //CashPayment.java
             class CashPayment implements Payment {
                 public void pay() {
                     System.out.println("현금 결제");
                 }
             }

           ```

         - ```java
             //run.java
             Payment payment;

             payment = new CardPayment();
             payment.pay();   // 카드 결제

             payment = new CashPayment();
             payment.pay();   // 현금 결제

           ```

    7. 집단화
       - 객체 간의 “전체–부분(Has-a)” 관계를 표현하는 객체지향 개념으로, 부분 객체가 전체 객체와 독립적으로 존재할 수 있는 관계
       - 예시
         - ```java
           class Student {
                 String name;
             }

             class Classroom {
                 List<Student> students;
             }
           ```

         - Classroom 없어져도 Student는 존재 가능

### 4. 객체 지향 분석 및 설계

1.  **객체지향 분석의 개념**

    > 사용자가 뭘 원하는지 보고, 이걸 어떤 ‘객체들’로 나눌지 찾는 과정
    - 소프트웨어를 개발하기 위한 비즈니스(업무)를 객체와 속성, 클래스와 멤버 전체와 부분 등으로 나누어서 분석

2.  **객체지향 분석의 방법론**
    1. Rumbaugh(럼바우) 기법 : 가장 일반적으로 사용되는 방법으로 분석 활동을 객체 모델, 동적 모델, 기능 모델로 나누어 수행하는 방법이다.
    2. Booch(부치) 기법: 미시적(Micro) 개발 프로세스와 거시적(Macro) 개발 프로세스를 모두 사용하는 분석 방법으로, 클래스와 객체들을 분석 및 식별하고 클래스의 속성과 연산을 정의한다.
    3. Jacobson 기법: Use Case를 강조하여 사용하는 분석 방법이다.
    4. Coad와 Yourdon 기법: E-R 다이어그램을 사용하여 객체의 행위를 모델링하며, 객체 식별, 구조 식별 주제 정의, 속성과 인스턴스 연결 정의, 연산과 메시지 연결 정의 등의 과정으로 구성하는 기법이다.
    5. Wirts-Brock 기법: 분석과 설계 간의 구분이 없고, 고객 명세서를 평가해서 설계 작업까지 연속적으로 수행하는 기법이다.

3.  **럼바우의 분석 기법**

    > 객체를 구조·동작·기능, 세 가지 관점에서 나눠서 분석하는 방법
    - 가장 일반적으로 사용되는 기법
      - 객체지향 분석의 가장 표준적인 방식
      - UML의 기반
      - 분석 단계에 최적화
    - 분석 활동은 '객체 모델링 → 동적 모델링 → 기능 모델링' 순으로 통해 이루어짐
      - 객체 모델링(Object Modeling)
        - 정보모델링이라고도 하며, 시스템에서 요구되는 객체를 찾아내어 속성과 연산 식별 및 객체들 간의 관계를 규정하여 객체 다이어그램으로 표시하는 것이다.
        - User, Order, Product와 같은 정적인 요소
      - 동적 모델링(Dynamic Modeling)
        - 상태 다이어그램 (상태도)을 이용하여 시간의 흐름에 따른 객체들 간의 제어 흐름, 상호 작용, 동작 순서 등의 동적인 행위를 표현하는 모델링이다.
        - 시스템의 동적인 행위를 나타낸다.
        - 주문됨 → 결제완료 → 배송중 → 완료과 같이 동적인 요소
      - 기능 모델링(Functional Modeling)
        - 자료 흐름도(DFD)를 이용하여 다수의 프로세스들 간의 자료 흐름을 중심으로 처리 과정을 표현한 모델링이다.
        - 시스템이 어떤 기능을 수행하는지를 분석한다.
        - 사용자 입력 → 검증 → 저장 → 결과 출력와 같이 처리 중심 대한 요소

4.  **객체지향 설계 원칙**
    > 객체지향 기능을 쓰는 법이 아니라,유지보수 잘 되게 ‘설계하는 법’에 대한 규칙
    - 객체지향 설계 원칙은 시스템 변경이나 확장에 유연한 시스템을 설계하기 위해 지켜야 할 다섯 가지 원칙으로 다섯 가지 원칙의 앞 글자를 따 SOLID 원칙이라고도 불린다.
    - SOLID 원칙
      - 단일 책임원칙(SRP, Single Responsibility Principle) : 객체는 단 하나의 책임만 가져야 한다는 원칙
      - 개방-폐쇄 원칙(OCP, Open-Closed Principle) : 기존의 코드를 변경하지 않고 기능을 추가할 수 있도록 설계해야 한다는 원칙
      - 리스코프 치환원칙(LSP, Liskov Substitution Principle) : 자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행 할 수 있어야 한다는 설계원칙
      - 인터페이스 분리 원칙(ISP, Interface Segregation Principle) : 신이 사용하지 않는 인터페이스와 의존 관계를 맺거나 영향을 받지 않아야 한다는 원칙
      - 의존 역전 원칙(DIP, Dependency Inversion Principle) : 각 객체들간의 의존관계가 성립될 때 추상성이 낮은 클래스보다 추상성이 높은 클래스와 의존 관계를 맺어야 한다는 원칙

### 5. 모듈

1.  **모듈의 개요**

    > 모듈화를 통해 분리된 시스템의 각 기능 단위로, 서브루틴, 서브시스템, 프로그램, 작업 단위 등과 같은 의미로 사용되는 독립적인 소프트웨어 구성 요소
    > 기능 하나를 담당하는 독립적인 프로그램 부품

2.  **모듈의 특징**
    - 독립성이 높은 모듈일수록 모듈을 수정하더라도 다른 모듈들에게는 거의 영향을 미치지 않으며, 오류가 발생해도 쉽게 발견하고 해결할 수 있다.
    - 모듈의 기능적 독립성은 소프트웨어를 구성하는 각 모듈의 기능이 서로 독립됨을 의미하는 것으로, 모듈이 하나의 기능만을 수행하고 다른 모듈과의 과도한 상호작용을 배제함으로써 이루어진다.(관심사의 분리)
    - 모듈의 독립성은 결합도(Coupling)와 응집도(Cohesion)에 의해 측정되며, 독립성을 높이려면 모듈의 결합도는 약하게, 응집도는 강하게, 모듈의 크기는 작게 만들어야함
    - 모듈의 4대 핵심 특징
      - 독립성: 다른 모듈과 상관없이 독자적으로 컴파일 및 실행이 가능함
      - 독자적 기능: 하나의 모듈은 하나의 특정한 기능만을 수행함 (단일 책임)
      - 인터페이스 통신: 모듈끼리는 정해진 연결 통로(인터페이스)를 통해서만 소통함
      - 정보 은닉: 모듈 내부의 복잡한 논리는 숨기고 필요한 결과만 외부에 제공함
    - 모듈의 평가 기준
      - 응집도(Cohesion): 모듈 내부 요소들의 관련도
        - 응집도가 강할수록 품질이 높고, 약할수록 품질이 낮음
        - 응집도의 종류에는 우연적 응집도, 논리적 응집도, 시간적 응집도, 절차적 응집도, 교환(통신)적 응집도, 순차적 응집도, 기능적 응집도가 있음
      - 결합도(Coupling): 모듈 사이의 관계
        - 결합도가 약할수록 품질이 높고, 강할수록 품질이 낮음
        - 결합도가 강하면 시스템 구현 및 유지보수 작업이 어려움
        - 결합도의 종류에는 자료 결합도, 스탬프 결합도, 제어 결합도, 외부 결합도, 공통 결합도, 내용 결합도가 있음

3.  **팬인(Fan-In) / 팬아웃(Fan-Out)**

    > 나를 호출하는 녀석은 몇 명인지(팬인), 내가 호출하는 녀석은 몇 명인지(팬아웃)를 세어 모듈의 복잡도를 측정하는 지표
    1. 팬인(Fan-In)
       - 정의: 어떤 모듈을 제어(호출)하는 상위 모듈의 수
       - 화살표 방향: 화살표가 모듈 안쪽으로 들어옴
       - 특징: 팬인이 높다는 것은 그만큼 여러 곳에서 이 모듈을 쓰고 있다는 뜻으로, 재사용성이 높다고 평가
    2. 팬아웃 (Fan-Out)
       - 정의: 어떤 모듈에 의해 제어(호출)되는 하위 모듈의 수
       - 화살표 방향: 화살표가 모듈 바깥으로 나감
       - 특징: 팬아웃이 너무 높으면 모듈이 너무 많은 일을 하거나 복잡하다는 뜻으로, 설계의 최적화가 필요
           <ImageWithCaption src="/static/images/fan_in_out.png" alt="fan in / fan out" caption="팬인/팬아웃" />

4.  **N-S 차트 (Nassi-Schneiderman Chart)**

    > 논리의 흐름을 **상자(Box)**로 묶어 표현하는 도구로, 화살표를 쓰지 않는 구조적 설계 기법
    1. 핵심내용
       - 구조적 프로그래밍 (Structured Programming)
         - 설명: 오직 3가지 기본 구조(순차, 선택, 반복)로만 논리를 표현
         - 특징: 화살표가 없기 때문에 프로그램의 제어가 제멋대로 뛰는 GOTO 문(임의 제어 이동) 사용이 불가능
       - 시각적 명확성
         - 설명: 로직 전체가 하나의 큰 상자 안에 갇혀 있는 형태입니다.
         - 장점: 그래픽 설계 도구로서 논리적인 구조를 한눈에 파악하기 매우 쉽습니다.
       - 하향식(Top-Down) 흐름
         - 설명: 프로그램의 시작부터 끝까지 위에서 아래로 물 흐르듯 진행됩니다.

           <ImageWithCaption src="/static/images/nschart.jpeg" alt="ns chart" caption="NS 차트" />

### 6. 공통 모듈

1.  **공통 모듈의 개요**

    > 공통 모듈은 여러 프로그램에서 공통적으로 사용할 수 있는 모듈을 의미
    1. 핵심내용
       - 재사용성
         - 설명: 한 번 만들어두면 여기저기서 호출만 해서 쓸 수 있습니다.
         - 효과: 개발 시간이 단축되고, 코드의 중복을 막을 수 있습니다.
       - 공통모듈 설계의 5가지 원칙
         - 정확성 (Accuracy): 해당 기능이 실제 시스템에서 반드시 필요한지 정확하게 파악해야 함
         - 명확성 (Clarity): 해당 기능을 이해할 때 중의적으로 해석되지 않도록 명확하게 정의함
         - 완전성 (Completeness): 시스템이 요구하는 모든 기능을 포함해야 함
         - 일관성 (Consistency): 공통 기능들 사이에 충돌이 발생하지 않도록 일관성을 유지함
         - 추적성 (Traceability): 요구사항 분석부터 설계까지 단계별로 어디서 왔는지 추적 가능해야 함
    2. 효과적인 모듈 설계 방안
       - 결합도는 줄이고 응집도는 높여서 모듈의 독립성과 재사용성을 높인다.
       - 제어 영역 안에서 영향 영역을 유지시킨다. > 내가 수정되었을 때, 나를 호출한 상위 모듈이나 다른 모듈이 바뀌어야 한다면 잘못된 설계이다.
       - 단순하고 일관되게 설계를 한다.
       - 예측가능하게 설계해야 한다.
       - 유지보수성이 좋아야 한다.
       - 시스템을 히해가기 쉬운 크기로 설계되어야한다.
       - 하나의 입구과 하나의 출구를 갖도록 해야한다. > 함수나 모듈이 시작되면 반드시 맨 첫 줄부터 실행되고, 끝날 때도 정해진 return 지점으로만 나오는 구조
       - 모듈끼리 주고받는 데이터 때문에 엉뚱한 로직이 실행되지 않도록, 모듈 사이의 연결 통로(인터페이스)를 명확하게 만들어야 한다.
       - 모듈 간의 계층적 관계를 정의하는 자료를 제시되어야 한다

### 7. 코드

1.  **코드(Code)의 개요**

    > 데이터를 식별하고 분류하기 위해 사물이나 개념에 부여하는 숫자, 문자 또는 기호
    > 데이터를 쉽고 정확하게 관리하기 위한 짧은 약속(기호)
    1. 핵심내용
       - 코드는 정보를 신속·정확 명료하게 전달할 수 있게 한다.
       - 코드는 일정한 규칙에 따라 작성되며, 정보 처리의 효율과 처리된 정보의 가치에 많은 영향을 미친다.
       - 일반적인 코드의 예로 주민등록번호, 학번, 전화번호 등이 있다.
    2. 코드의 5대 주요 기능
       - 식별 (Identification): 다른 것과 구별하는 기능 (예: 주민번호)
       - 분류 (Classification): 유사한 그룹끼리 묶는 기능 (예: 학과 코드)
       - 배열 (Arrangement): 순서대로 나열하는 기능 (예: 출석 번호)
       - 간소화 (Simplification): 복잡한 데이터를 짧게 줄이는 기능 (예: 대한민국 $\rightarrow$ KR)
       - 표준화 (Standardization): 일관된 규칙을 적용하는 기능
    3. 코드의 종류
       - | 코드 종류                     | 핵심 설명                                                                                                      | 예시                                                                      |
         | ----------------------------- | -------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------- |
         | 순차 코드 (Sequence)          | 발생 순서대로 일련번호를 부여                                                                                  | 1, 2, 3, 4...                                                             |
         | 블록 코드 (Block)             | 공통성 있는 것끼리 블록을 정해 번호 부여                                                                       | 1-100(인사과), 101-200(총무과)                                            |
         | 10진 코드 (Decimal)           | 코드화 대상 항목을 0~9까지 10진 분할하고, 다시 그 각각에 대하여 10진 분할하는 방법을 필요한 만큼 반복하는 방법 | 1000: 공학, 1100: 소프트웨어 공학, 1110 : 소프트웨어 설계                 |
         | 그룹 분류 (Group)             | 대분류-중분류-소분류를 구분하여 부여                                                                           | 10-01-005 (지역-동-번지)                                                  |
         | 연상 코드 (Mnemonic)          | 대상의 명칭이나 약자를 사용하여 연상 유도                                                                      | KR(Korea), USD(US Dollar)                                                 |
         | 표의 숫자 (Significant Digit) | 길이, 무게 등 물리적인 수치를 포함                                                                             | TV-55-LED (55인치 LED TV)                                                 |
         | 합성 코드 (Combined)          | 2개 이상의 코드를 조합하여 만드는 방법                                                                         | 연상 코드+ 순차 코드 => KE-711 : 대한항공 711기 AC-253 : 에어캐나다 253기 |

2.  코드 부여 체계

    > 코드 부여 체계는 이름만으로 개체의 용도와 적용 범위를 알 수 있도록 코드를 부여하는 방식
    1. 핵심내용
       - 개체들의 식별 및 추출을 용이하게 함
       - 코드의 부여 규칙 정의 필요
       - 코드 부여 체계를 담당하는 자는 코드의 자릿수와 구분자, 구조 등을 상세하게 명시
           <ImageWithCaption src="/static/images/code_make_rule.png" alt="code rule" caption="코드 부여 체계" />

### 8. 디자인 패턴

1.  **디자인 패턴(Design Pattern)의 개요**

    > 디자인 패턴이란 소프트웨어 설계 시 공통적으로 발생하는 문제들에 대해 반복적으로 적용할 수 있는 검증된 해결책
    - 디자인 패턴은 문제 및 배경. 실제 적용된 사례, 재사용이 가능한 샘플 코드 등으로 구성
    - 디자인 패턴은 1995년 GoF(Gang of Four)라고 불리는 에릭 감마(Erich Gamma), 리차드 헬름(Richard Helm), 랄프 존슨(Ralph Johnson), 존 블리시디스(John Vlisides)가 처음으로 구체화 및 체계화함.

2.  **GoF(Gang of Four) 디자인 패턴**

    > 가장 유명한 표준으로, 총 23가지 패턴을 3가지 범주로 분류된 디자인 패턴
    - 장점: 개발자 간의 의사소통 원활, 설계 변경에 따른 유연한 대처, 재사용성을 통한 개발 시간 단축.
    - GoF의 디자인 패턴은 수많은 디자인 패턴들 중 가장 일반적인 사례에 적용될 수 있는 패턴들을 분류하여 정리함으로써, 지금까지도 소프트웨어 공학이나 현업에서 가장 많이 사용되는 자인 패턴이다.

3.  **디자인패턴 표준 분류법**
    1. 생성(Creational)
       - 객체의 생성과 참조 과정을 캡슐화하여 객체가 생성되거나 변경되어도 프로그램 구조에 영향을 주지 않도록 함.
       - 생성 패턴 : Abstract Factory, Builder, Factory Method, Prototype, Singleton
         - Singleton(싱글톤) : 클래스의 인스턴스가 단 하나만 생성되도록 보장하고, 어디서든 그 인스턴스에 접근할 수 있게 하는 패턴.
         - Factory Method(팩토리 메소드) : 객체 생성을 서브 클래스에서 결정하도록 분리하여 캡슐화하는 패턴.
    2. 구조(Structural)
       - 클래스나 객체를 조합하여 더 큰 구조를 만드는 패턴. 복잡한 형태의 구조를 효율적으로 구축함.
       - 구조 패턴 : Adapter, Bridge, Composite, Decorator, Facade, Flyweight, Proxy
         - Adapter(어댑터) : 호환성이 없는 인터페이스를 사용하는 클래스들을 함께 사용할 수 있도록 연결해주는 패턴.
         - Facade(퍼싸드) : 복잡한 서브 시스템 앞단에 **간단한 인터페이스(창구)**를 두어 시스템을 쉽게 사용할 수 있게 함.
         - Proxy(프록시) : 실제 객체에 대한 접근을 제어하기 위해 대리 객체를 사용하는 패턴.
    3. 행위(Behavioral)
       - 클래스나 객체를 조합하여 더 큰 구조를 만드는 패턴. 복잡한 형태의 구조를 효율적으로 구축함.
       - 행위 패턴 : Chain of Responsibility, Command, Iterator, Herator, Mediator, Memento, Observer, State, Strategy, Template Method, Visitor,
         - Adapter(어댑터) : 호환성이 없는 인터페이스를 사용하는 클래스들을 함께 사용할 수 있도록 연결해주는 패턴.
         - Strategy(행위) : 알고리즘을 각각 캡슐화하여 필요할 때마다 교체해서 사용할 수 있게 하는 패턴.
