---
title: '[정보처리기사 자격증] 2.소프트웨어 개발 > 1장 데이터 입출력 구현 (WEEK 5)'
date: '2026-01-11'
tags: ['dev', 'license']
draft: false
summary: 정보처리기사 5주차 내용정리 - 데이터 입출력 구현
# https://velog.io/@alpaka206/24.-시스템-인터페이스-요구사항-분석
---

import ImageWithCaption from '@/components/mdxComponents/ImageWithCaption'

### 1. 자료구조

1.  **자료 구조(Data Structure)의 정의**

    > 자료 구조란 컴퓨터에서 자료를 효율적으로 이용할 수 있도록 기억장치 내에 저장하는 방법, 자료 간의 관계, 그리고 그에 따른 처리 방법을 연구·분석하는 것을 의미
    1. 핵심내용
       - 저장 공간의 효율성 : 기억장치(메모리) 용량의 적절한 사용
       - 실행 시간의 신속성 : 자료의 처리 및 실행 속도의 신속성

2.  **자료구조의 분류**
    - <ImageWithCaption src="/static/images/data_stucture.png" alt="data stucture" caption="자료구조의 분류" />
    1.  선형구조
        1.  배열(double[], String[])
            - 특징: 동일한 자료형의 데이터가 연속된 공간에 나열됨.
            - 장점: 첨자(Index)를 사용해 접근이 빠름, 반복 처리에 용이.
            - 단점: 정적 할당(크기 고정)으로 인한 메모리 낭비 발생, 데이터 삽입/삭제 시 오버헤드 큼.
        2.  선형 리스트(List\<>)
            - 일정한 순서에 의해 나열된 자료 구조
            - 선형 리스트는 배열을 이용하는 연속 리스트(Contiguous List)와 포인터를 이용하는 연결 리스트(Linked List)로 구분
              1. 연속 리스트(Contiguous List)
                 - 메모리의 연속된 공간에 데이터를 차곡차곡 채우는 방식. 자바의 ArrayList가 대표적
                 - **접근 속도**: 인덱스(Index)로 바로 찾아가기 때문에 매우 빠름.
                 - **저장 효율**: 포인터 같은 부가적인 정보 없이 데이터만 딱딱 채우므로 기억장치 이용 효율(밀도)이 1로 가장 좋습니다.
                 - **삽입/삭제 시 오버헤드가 발생**
                 - **유연성 부족**
              2. 연결 리스트 (Linked List)
                 - 메모리의 아무 빈 공간에나 데이터를 던져놓고, 각 데이터가 **다음 데이터의 위치(포인터)**를 가리키게 하여 연결한 방식
                 - **삽입/삭제**: 중간에 데이터를 넣을 때 포인터 선만 두 번 다시 연결해주면 된다. 자료의 이동이 필요 없다.
                 - **유연성**: 메모리 어디든 빈 공간만 있으면 연결해서 늘릴 수 있음.
                 - **접근 속도**: "세 번째 데이터 어디 있어?"라고 물으면 첫 번째부터 포인터를 타고 가야 하므로 검색 속도가 느리다.
                 - **저장 효율**: 데이터 외에 포인터(링크)를 저장할 공간이 추가로 필요해서 효율이 조금 떨어진다.
                 - **위험성**: 중간 포인터가 끊어지면 그 뒤의 데이터는 미아가 되어 찾을 수 없다.
        3.  스택
            - 스택은 한쪽 끝으로만 자료의 삽입과 삭제가 이루어지는 선형 구조(ex - 프링글스 통, 쌓여 있는 접시)
            - LIFO (Last-In-First-Out, 후입선출): 가장 나중에 들어온 데이터가 가장 먼저 나가는 방식
            - Stack의 응용 분야
              - 함수 호출의 순서 제어, 인터럽트의 처리, 수식 계산 및 수식 표기법, 컴파일러를 이용한 언어 번역, 부 프로그램 호출 시 복귀 주소 저장, 서브 루틴 호출 및 복귀 주소 저장
            - 상태 및 포인터
              - TOP (스택 포인터): 스택의 가장 위에 있는 자료의 위치를 가리키는 요소
              - Bottom: 스택의 가장 밑바닥
            - 연산(Operation)
              - Push: 스택에 새로운 자료를 삽입하는 동작. (TOP이 위로 올라감)
              - Pop: 스택에서 자료를 꺼내서 삭제하는 동작. (TOP이 아래로 내려감)
            - 오류 상태
              - 오버플로(Overflow): 스택이 꽉 찼는데 데이터를 더 넣으려고(Push) 할 때 발생하는 오류.
              - 언더플로(Underflow): 스택이 비어 있는데 데이터를 꺼내려고(Pop) 할 때 발생하는 오류.

        4.  큐(Queue)
            - 큐(Queue)는 스택과 반대되는 개념으로, 먼저 온 사람이 먼저 나간다는 원칙
            - FIFO (First-In-First-Out, 선입선출): 가장 먼저 들어온 데이터가 가장 먼저 나가는 방식입니다.
            - 주요 용어 및 포인터
              - 프런트(Front, F) 포인터: 큐의 출구 역할, 가장 먼저 삽입된 자료의 위치를 가리키며, 삭제(Delete) 연산 시 사용
              - 리어(Rear, R) 포인터: 큐의 입구 역할, 가장 마지막에 삽입된 자료의 위치를 가리키며, 삽입(Insert) 연산 시 사용
            - 큐의 응용 분야
              - 운영체제(OS)의 작업 스케줄링 : 프로세스들이 CPU를 할당받기 위해 순서대로 줄을 서는 대기 큐
              - 스풀(Spool) 운용 :프린터로 인쇄 명령. 데이터가 들어온 순서대로 인쇄되는 방식
              - 데이터 버퍼(Buffer) : 서로 다른 속도로 작동하는 기기 사이에서 데이터를 주고받을 때, 데이터를 임시로 보관하는 용도로 사용
              - 너비 우선 탐색(BFS, Breadth-First Search)

        5.  데크(Deque)
            - 데크는 Double-Ended Queue의 약자로, 리스트의 양쪽 끝(Front, Rear) 어디에서나 삽입과 삭제가 모두 가능한 자료 구조
            - 특징: 스택과 큐를 하나로 합친 형태
            - 유연성: 상황에 따라 스택처럼 쓸 수도 있고, 큐처럼 쓸 수도 있어 매우 유연
            - 입력 제한 데크 (Scroll, 스크롤)
              - 특징: 삽입은 한쪽 끝에서만 가능하고, 삭제는 양쪽 끝에서 가능한 형태.
            - 출력 제한 데크 (Shelf, 쉘프)
              - 특징: 삽입은 양쪽 끝에서 가능하고, 삭제는 한쪽 끝에서만 가능

    2.  비선형 구조
        1.  그래프(Graph)
            - 그래프는 단순한 선형 구조와 달리 데이터들이 그물망처럼 복잡하게 연결된 구조
            1. 구성 요소:
               - 정점(Vertex, V): 데이터가 저장되는 지점 (노드).
               - 간선(Edge, E): 정점과 정점을 잇는 선.
            2. 표현: G=(V,E)
            3. 그래프의 분류
               1. 무방향 그래프 (Undirected Graph)
                  - 간선에 방향성이 없음. (A와 B가 연결되면 서로 오갈 수 있음)
                  - $(A, B)$와 $(B, A)$는 같은 간선으로 취급.
               2. 방향 그래프 (Directed Graph)
                  - 간선에 화살표로 방향이 표시됩니다. (A → B는 가능하지만 B → A는 별도의 선이 있어야 함)
                  - (A, B)와 (B, A)는 서로 다른 간선입니다.
               3. 최대 간선 수 계산
                  - 정점의 개수가 n개일 때, 그래프가 가질 수 있는 최대 간선의 수
                    | 구분 | 공식 | 정점(n)이 4개일 때 |
                    | ------------- | -------------------- | --------------------------------- |
                    | 무방향 그래프 | $$\frac{n(n-1)}{2}$$ | $\frac{4(4-1)}{2} = \mathbf{6}$개 |
                    | 방향 그래프 | $$n(n-1)$$ | $4 \times 3 = \mathbf{12}$개 |

        2.  트리(Tree)
            - 트리는 정점(Node)과 선분(Branch)을 이용하여 사이클(Cycle)이 이루어지지 않도록 구성한 그래프의 특수한 형태
            1. 특징:
               - 계층 구조: 부모-자식 관계가 존재하는 계층적 모델
               - 비선형 구조: 데이터가 일직선이 아닌 사방으로 뻗어나가는 형태
               - 활용: 가족의 족보, 조직도, 컴퓨터의 디렉터리 구조 등에 사용
            2. 트리 관련 필수 용어
               | 용어 | 설명 | 예시 (보내주신 자료 기준) |
               | ------------------------- | ------------------------------------- | ----------------------------- |
               | 근 노드 (Root Node) | 트리의 맨 위에 있는 최상위 노드 | 노드 A |
               | 디그리 (Degree, 차수) | 각 노드에서 뻗어 나온 가지(자식)의 수 | 노드 D의 디그리는 3 (H, I, J) |
               | 트리의 디그리 | 노드들의 디그리 중 가장 큰 값 | 위 트리의 디그리는 3 |
               | 단말 노드 (Terminal/Leaf) | 자식이 하나도 없는 노드 (디그리 = 0) | K, L, F, G, M, I, J |
               | 자식/부모/형제 | 다음/이전 레벨 노드 및 같은 부모 노드 | H, I, J는 형제 노드 |
            3. 트리의 운행법
               - 트리를 구성하는 각 노드들을 찾아가는 방법을 말함
                 1. Preorder (전위): Root → Left → Right
                 2. Inorder (중위): Left → Root → Right
                 3. Postorder (후위): Left → Right → Root

### 2. 정렬

1.  **정렬(Sort)의 개요**

    > 정렬이란 데이터를 특정 기준(오름차순 또는 내림차순)에 따라 나열하는 것
    - 실행 위치에 따라 내부 정렬(메모리 내 처리)과 외부 정렬(보조기억장치 이용)로 나뉨

2.  **주요 정렬 알고리즘의 특징**
    1. 삽입, 선택, 쉘, 버블 정렬
       - 이 알고리즘들은 구현은 쉽지만 대량의 데이터 처리에 성능이 떨어지는 편
       1. 삽입 정렬(Insertion Sort)
          - 이미 정렬된 부분에 새로운 레코드를 알맞은 위치에 삽입하여 정렬
       2. 선택 정렬(Selection Sort)
          - 전체 중 최솟값(또는 최댓값)을 찾아 맨 앞의 레코드와 교환
          - 작동 방식:
            - 전체 데이터 중에서 최솟값을 찾음.
            - 그 최솟값을 맨 앞에 있는 데이터와 자리를 바꿈.
            - 이제 맨 앞은 고정! 나머지 데이터들 중에서 다시 최솟값을 찾아 두 번째 자리와 바꿈.
            - 이 과정을 반복.
       3. 쉘 정렬 (Shell Sort)
          - 멀리 떨어진 사람들끼리 먼저 줄 세우기
          - 작동 방식:
            - 일정한 간격(Gap, h)을 정해서 그 간격만큼 떨어진 데이터들끼리 묶는다.
            - 묶인 그룹 내에서 삽입 정렬을 한다.
            - 간격을 점점 줄여가며 이 과정을 반복하다가 마지막엔 간격을 1로 해서 마무리.
       4. 버블 정렬(Bubble Sort)
          - 주어진 파일에서 인접한 두 개의 레코드 키 값을 비교하여 그 크기에 따라 레코드 위치를 서로 교환하는 정렬 방식
          - 작동 방식:
            - 인접한 두 데이터를 비교
            - 앞의 숫자가 더 크면 서로 자리를 바꾼다.
            - 한 바퀴(1회전) 돌고 나면 가장 큰 숫자가 맨 뒤에 가 있게 됨
    1. 고급 정렬 알고리즘
       1. 퀵 정렬 (Quick Sort)
          - **피봇(Pivot)**이라는 기준값을 정하고, 이보다 작은 값은 왼쪽, 큰 값은 오른쪽으로 모으는 과정을 반복.
          - 정렬방식 중에서 가장 빠른 방식
          - 재귀적으로 동작하므로 스택(Stack) 메모리가 필요
          - 분할(Divide)과 정복(Conquer)을 통해 자료를 정렬
            - 분할(Divide) : 기준값인 피봇(Pivot)을 중심으로 정렬할 자료들을 2개의 부분집합으로 나눔.
            - 정복(Conquer) : 부분집합의 원소들 중 피봇(Pivot)보다 작은 원소들은 왼쪽, 피봇(Pivot)보다 큰 원소들은 오른쪽 부분집합으로 정렬.
            - 부분집합의 크기가 더 이상 나누어질 수 없을 때까지 분할과 정복을 반복 수행.
       2. 힙 정렬(Heap Sort)
          - 힙 정렬은 전이진 트리(Complete Binary Tree)를 이용한 정렬 방식(토너먼트 대진표에서 우승자부터 뽑아내기)
          - 작동 방식
            - 데이터를 전이진 트리 형태인 힙(Heap) 구조로 만듬. (부모가 자식보다 큰 구조)
            - 루트 노드(맨 위)에 있는 가장 큰 값을 꺼내서 맨 뒤로 보냄.
            - 남은 트리에서 다시 힙 구조를 만들어 다음 큰 값을 꺼냄.
       3. 2-Way 합병 정렬(Merge Sort)
          - 이미 정렬되어 있는 두 개의 파일을 한 개의 파일로 합병하는 정렬
          - 작동 방식:
            - 두 개의 키들을 한 쌍으로 하여 각 쌍에 대하여 순서를 정한다.
            - 순서대로 정렬된 각 쌍의 키들을 합병하여 하나의 정렬된 서브리스트로 만든다.
            - 위 과정에서 정렬된 서브리스트들을 하나의 정렬된 파일이 될 때까지 반복한다.
       4. 기수정렬(Radix Sort)
          - 기수정렬은 Queue를 이용하여 자릿수(Digit)별로 정렬하는 방식
          - 작동 방식:
            - 레코드의 키 값을 분석하여 같은 수 또는 같은 문자끼리 그 순서에 맞는 버킷에 분배 하였다가 버킷의 순서대로 레코드를 꺼내어 정렬.

### 3. 검색 (자료 검색)

1.  **이분 검색**
    - 이분 검색은 전체 자료를 반씩 나눠가며 찾는 방식
    - 핵심 특징
      - 반드시 정렬(Sorted)되어 있어야 함: 데이터가 순서대로 나열되어 있지 않으면 사용할 수 없습니다. (시험 단골 지문)
      - 성능: 비교를 거듭할 때마다 검색 대상이 **절반(1/2)**으로 줄어듭니다. $O(\log_2 n)$
      - 중간값(M) 공식:
        - $\mathbf{M}= \frac{F + L}{2}$
      - 예시 1~100 사이에서 '15' 찾기
        - 1회전: 중간값 M=(1+100)/2=50.5→50. (15 < 50 이므로 왼쪽 1~49 탐색)
        - 2회전: 중간값 M=(1+49)/2=25. (15 < 25 이므로 왼쪽 1~24 탐색)
        - 3회전: 중간값 M=(1+24)/2=12.5→12. (15 > 12 이므로 오른쪽 13~24 탐색)
        - 4회전: 중간값 M=(13+24)/2=18.5→18. (15 < 18 이므로 왼쪽 13~17 탐색)
        - 5회전: 중간값 M=(13+17)/2=15. 검색 성공! (비교 횟수 총 5회)

2.  **해싱 (Hashing)**
    - 키 값을 주소로 바로 바꿔버리는 초고속 검색법
    - 해싱은 산술적인 계산을 통해 데이터가 저장될 위치(주소)를 직접 구하는 방식
    - 주요 용어
      - 해시 테이블(Hash Table): 데이터가 저장되는 전체 공간.
      - 버킷(Bucket): 하나의 주소를 갖는 구역.
      - 슬롯(Slot): 버킷 안에 한 개의 레코드를 저장하는 공간. (1버킷 = 여러 개의 슬롯)
      - 충돌(Collision): 서로 다른 두 키가 같은 홈 주소를 가지는 현상.
      - 동의어(Synonym): 충돌이 발생한 레코드들의 집합.
      - 오버플로(Overflow): 버킷에 빈 슬롯이 없어서 더 이상 저장할 수 없는 상태.
    - 해싱 함수의 종류
      | 종류 | 설명 |
      | ------------------------- | -------------------------------------------------------------------- |
      | 제산법(Division) | 키($K$)를 소수($Q$)로 나눈 나머지를 주소로 사용 ($h(K) = K \pmod Q$) |
      | 제곱법(Mid-Square) | 키 값을 제곱한 후 중간 부분의 값을 주소로 사용 |
      | 폴딩법(Folding) | 키를 여러 부분으로 나누고 더하거나 XOR 연산하여 사용 |
      | 기수 변환(Radix) | 키를 다른 진수로 변환하여 주소로 사용 |
      | 숫자 분석(Digit Analysis) | 키의 숫자 분포를 분석해 고른 분포의 자릿수만 선택 |
    - 충돌 해결 방법
      1. 체이닝(Chaining): 같은 주소인 경우 **연결 리스트(Linked List)**로 줄줄이 연결함.
      2. 개방 주소법(Open Addressing): 충돌 나면 옆의 빈자리를 찾아서 들어감.
      3. 재해싱(Rehashing): 충돌 나면 새로운 해시 함수를 한 번 더 돌림.

### 4. 데이터베이스 개요

1.  **데이터저장소**
    - 데이터저장소는 소프트웨어 개발 과정에서 다루어야 할 데이터들을 논리적인 구조로 조직화하거나, 물리적인 공간에 구축한 것
    - 데이터저장소는 논리 데이터저장소와 물리 데이터저장소로 구분

2.  **데이터베이스(Database)의 정의**

    > 데이터베이스는 단순히 데이터를 모아둔 것이 아니라, 조직의 목적을 위해 체계적으로 관리되는 데이터의 집합
    - 데이터베이스의 특징
      - 통합된 데이터 (Integrated): 중복을 최소화하여 효율성을 높힘
      - 저장된 데이터 (Stored): 컴퓨터가 읽을 수 있는 매체에 저장
      - 운영 데이터 (Operational): 조직의 고유 업무를 수행하는 데 꼭 필요
      - 공용 데이터 (Shared): 여러 사용자와 응용 프로그램이 함께 사용

3.  **DBMS (데이터베이스 관리 시스템)**

    > BMS는 사용자와 데이터베이스 사이에서 다리 역할을 하는 소프트웨어
    - DBMS의 3대 필수 기능
      - 정의(Definition) 기능: 데이터의 구조(타입, 제약 조건 등)를 설정하는 기능.
      - 조작(Manipulation) 기능: 데이터를 검색, 삽입, 삭제, 갱신(CRUD)하는 기능.
      - 제어(Control) 기능: 무결성 유지, 보안 및 권한 검사, 병행 제어(Concurrency Control) 등을 수행하는 기능.

4.  **데이터의 독립성 (Independence)**

    > 데이터베이스의 궁극적인 목적 중 하나는 응용 프로그램과 데이터를 분리하는 것
    - 논리적 독립성: 데이터베이스의 논리적 구조(개념 스키마)가 바뀌어도 응용 프로그램은 영향을 받지 않음.
    - 물리적 독립성: 저장 장치(내부 스키마)가 바뀌어도 응용 프로그램이나 논리적 구조는 영향을 받지 않음.

5.  **스키마 (Schema) 3계층**
    > 스키마는 데이터베이스의 설계도 혹은 명세서
    1. 외부 스키마 (External Schema):
       - 사용자나 개발자가 보는 개인적인 관점.
       - 전체 DB 중 필요한 부분만 보여줌 (서브 스키마).
    2. 개념 스키마 (Conceptual Schema):
       - 데이터베이스의 전체적인 논리 구조.
       - 조직 전체의 관점으로, 딱 하나만 존재함.
       - 보안, 무결성 규칙 등을 정의함. (시험에서 가장 중요!)
    3. 내부 스키마 (Internal Schema):
       - 물리적인 저장 장치 관점.
       - 실제 데이터가 하드디스크에 어떻게 저장되는지(인덱스, 필드 크기 등)를 정의함.

### 5. 절차형 SQL

1.  **절차형 SQL이란**
    - 절차형 SQL은 C나 Java처럼 변수를 만들고, 조건문(IF)을 쓰고, 반복문(LOOP)을 돌릴 수 있는 SQL
    - 특징
      - 블록(Block) 구조: BEGIN ~ END 형식 안에 로직 사용
      - 효율성: DBMS 엔진 안에서 직접 실행되므로, 애플리케이션과 DB 사이를 오가는 데이터 패킷이 줄어들어 효울적.

2.  **절차형 SQL의 핵심**
    | 구분 | 저장 프로시저 | 트리거 | 사용자 정의 함수 |
    |--------|----------------------|---------------------------|-----------------------------------|
    | 목적 | 특정 로직을 일괄 처리 | 이벤트 발생 시 자동 실행 | 계산을 통한 결과값 반환 |
    | 실행 방식 | EXECUTE 명령어로 호출 | INSERT, UPDATE 등 이벤트 시 자동 | SELECT 문 등에 포함되어 실행 |
    | 반환값 | 없을 수도 있고 여러 개일 수도 있음 | 없음 (반환 불가) | 반드시 1개의 단일값 반환 |
    | 핵심 키워드 | 트랜잭션, 호출 | 이벤트, 자동, 로그 남기기 | Return, 단일값 |

3.  **테스트와 디버깅 (실무형 팁)**
    - SHOW 명령어: SQL 구문 오류가 났을 때 구체적인 에러 내용을 확인하기 위해 사용합니다. (예: SHOW ERRORS;)
    - 주석 처리: 디버깅 시 실제 DB 데이터를 건드리면 안 되므로, INSERT나 UPDATE 문은 주석(--)으로 막아놓고 출력문으로 값만 확인합니다.

4.  **쿼리 성능 최적화 (Tuning)**
    1. APM 활용: 성능 측정 도구(Application Performance Management)를 사용하여 가장 느린 쿼리를 찾아냄.
    2. 옵티마이저(Optimizer): DBMS의 두뇌 역할을 하는 옵티마이저가 수립한 실행 계획을 검토
    3. 인덱스(Index) 재구성: 실행 계획을 보고 인덱스가 제대로 쓰이고 있는지 확인하여 SQL을 수정
