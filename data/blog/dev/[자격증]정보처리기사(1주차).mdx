---
title: '[정보처리기사 자격증 공부] 1.소프트웨어 설계 > 1장 요구사항 확인 (WEEK 1)'
date: '2025-12-09'
tags: ['dev', 'license']
draft: false
summary: 정보처리기사 1주차 내용정리 - 요구사항 확인
---

import ImageWithCaption from '@/components/mdxComponents/ImageWithCaption'

### 1. 소프트웨어 생명주기

1.  **소프트웨어 생명주기**
    1. 소프트웨어 개요

       > 컴퓨터 시스템을 운영하거나 특정 업무를 수행하기 위해 작성된 프로그램, 절차, 알고리즘, 문서 등을 포함하는 개념.
       > 형태가 없는 비물질적 재화(Intangible product).

    2. 소프트웨어 생명주기(Software Life Cycle)
       - 소프트웨어를 개발하기 위해 계획부터 폐기까지의 모든 과정을 단계별로 나눈 모델
       - 목적
         - 프로젝트의 비용 산정, 일정 관리, 품질 향상을 체계적으로 하기 위함
       - 단계
         1. 계획 (타당성 검토)
         2. 요구사항 분석 (사용자가 원하는 기능 정의)
         3. 설계 (시스템 구조 정의)
         4. 구현 (실제 코딩)
         5. 테스트 (오류 검출)
         6. 유지보수 (가동 후 관리)

    3. 소프트웨어 생명주기 모델
       1. 폭포수 모델
          - 가장 오래된 전통적인 모델로, 이전 단계가 끝나야 다음 단계로 넘어가는 순차적 방식.
          - 이해하기 쉽고 관리가 용이함.
          - 요구사항 변경이 어렵고, 마지막 단계에서야 결과물을 확인할 수 있어 리스크가 큼.
       2. 프로토타입 모델
          - 실제 소프트웨어를 만들기 전, **견본품(Prototype)**을 만들어 사용자에게 미리 보여주는 방식.
          - 사용자의 요구사항을 정확히 파악할 수 있고, 오해를 줄일 수 있음.
       3. 나선형 모델
          - 폭포수와 프로토타입 모델의 장점에 위험 분석 기능을 추가한 모델.
          - 4단계 순환: 계획 수립 → 위험 분석 → 개발 및 검증 → 고객 평가 순으로 반복
       4. 에자일 모델
          - 일정한 주기를 반복하며 고객의 요구사항 변화에 유연하고 신속하게 대응하는 방식.
          - 핵심 가치: 문서 중심보다 실행되는 코드, 프로세스보다 사람 간의 소통 중시
          - 대표 사례: XP(eXtreme Programming), Scrum, Kanban, Lean.
          - 에자일 선언
            - 기존의 무거운 개발 방식에서 벗어나기 위한 4가지 핵심 가치와 12가지 원칙
            - 애자일 선언의 4가지 핵심 가치
              1. 개인과 상호작용에 큰 가치를 둔다(\<->프로세스와 도구)
              2. 실행되는 소프트웨어에 큰 가치를 둔다(\<->광범위한 문서화)
              3. 고객과의 협력에 큰 가치를 둔다(\<->계약 협상)
              4. 변화에 대응(\<->계획 준수)
            - 애자일 선언의 12가지 원칙
              1. 가장 우선순위는 고객 만족이다.
              2. 개발 후반부라도 요구사항 변경을 환영한다.
              3. 작동하는 소프트웨어를 자주(짧은 간격으로) 전달한다.
              4. 비즈니스 담당자와 개발자는 프로젝트 내내 매일 함께 일해야 한다.
              5. 동기 부여된 개인들로 팀을 구성하고 그들을 신뢰한다.
              6. 정보를 전달하는 가장 효율적인 방법은 얼굴을 보고 대화하는 것이다.
              7. 작동하는 소프트웨어가 진척률의 주요 척도다.
              8. 지속 가능한 개발 속도를 유지한다.
              9. 기술적 탁월함과 좋은 설계에 지속적인 관심을 기울인다.
              10. 단순함(Simplicity)—하지 않아도 될 일을 최대화하는 기술—이 필수적이다.
              11. 최고의 아키텍처와 설계는 자기 조직화된 팀에서 나온다.
              12. 정기적으로 팀이 어떻게 더 효과적이 될지 돌아보고 행동을 조율한다.

### 2. 스크럼 기법

1. **스크럼의 개요**

   > 스크럼은 럭비 경기에서 유래된 용어로, 팀원들이 하나의 목적을 위해 똘똘 뭉쳐 짧은 주기로 개발을 반복하는 방식. 이론보다는 경험적 데이터를 바탕으로 프로젝트를 관리

2. **스크럼팀의 구성**
   1. 제품 책임자 (Product Owner, PO)
      - 백로그(Backlog)[앞으로 해야 할 일들을 우선순위에 따라 나열한 목록]를 작성하고 우선순위를 결정
      - 비즈니스 가치를 극대화하는 최종 책임자
   2. 스크럼 마스터 (Scrum Master, SM)
      - 스크럼 원칙을 잘 지키도록 돕고, 팀의 장애물을 제거
      - 회의를 주재하며 팀을 보호하는 서번트 리더(Servant Leader) 역할
      - 팀원들이 개발에만 집중할 수 있는 환경을 만드는것에 목표를 둠
      - 스크럼마스터의 핵심 업무
        1. 장애물 제거 (Impediment Removal)
        2. 외압으로부터 팀보호
        3. 가이드 및 교육
   3. 개발 팀 (Development Team)
      - PO가 정한 우선순위에 따라 스프린트 기간 동안 실제 결과물 제작

3. **스크럼 프로세스 (The Sprint Flow)**
   1. 제품 백로그 (Product Backlog): 제품에 필요한 모든 요구사항을 우선순위에 따라 나열한 목록 작성
   2. 스프린트 계획 회의 (Sprint Planning): 이번 주기(스프린트) 동안 수행할 작업 목록인 스프린트 백로그를 작성
   3. 스프린트 (Sprint): 짧은 주기(보통 1~4주)동안 실제 개발을 진행
   4. 일일 스크럼 (Daily Scrum): 매일 15분 정도 짧게 서서 진행상황과 장애 요인을 공유 (진척도는 번다운 차트로 확인)
   5. 스프린트 검토 회의 (Sprint Review): 스프린트가 끝나면 고객(PO 포함) 앞에서 결과물을 시연하고 피드백
   6. 스프린트 회고 (Sprint Retrospective): 개발 과정에서 좋았던 점, 아쉬웠던 점을 팀원끼리 나누며 다음 스프린트를 위해 개선점 도출

### 3. XP(eXtreme Programing) 기법

1. **XP(eXtreme Programing)의 개요**

   > 고객의 요구사항에 유연하게 대응하기 위해 고객의 참여를 극대화하고, 개발 생산성을 높이는 기법
   - xp는 짧고 반복적인 개발주기, 단순한설계, 고객의 적극적인 참여를 통해 소프트웨어를 빠르게 개발하는것을 목적으로 함
   - 몇 개의 요구사항이 적용된 일부 기능이 완성될 때마다 이를 고객에서 보여주고 이에 대한 반응을 확인하는 과정을 최종 제품이 완성될 때까지 지속적으로 반복

2. **XP(eXtreme Programing)의 핵심 가치**
   1. 의사소통 : 팀원, 고객간의 원할한 소통
   2. 단순성 : 부가적 기능 배제, 필요한 만큼만 설계
   3. 피드백 : 지속적인 테스트와 고객리뷰를 통한 피드백 반영
   4. 용기 : 요구사항 변화에 맞게 과감히 수정할 수 있는 용기
   5. 존중 : 팀원 간의 전문성을 인정하고 존중

3. **XP(eXtreme Programing)의 개발 프로세스**
   1. 사용자 스토리
      - 고객의 요구사항을 시나리오로 표현한 것
      - 복잡한 요구사항 명세서 대신, **"나는 ~로서 ~를 하기 위해 ~를 원한다"**는 식의 일상 언어로 작성
   2. 릴리즈 계획 수립
      - 사용자 스토리를 바탕으로 이번 릴리즈에 무엇을 포함할지, 일정은 어떻게 될지 계획 수립
      - 개발 기간과 비용을 추정하여 고객에게 전달하고, 고객은 그 안에서 우선순위를 정합니다.
   3. 스파이크 (Spike)
      - 어려운 기술이나 잠재적인 오류를 해결하기 위해 별도로 만든 간단한 프로그램
      - 기술적 불확실성을 미리 제거하기 위한 '탐색용 코드'
   4. 이터레이션 (Iteration / 반복)
      - 실제 개발 단계로, 1~3주 정도의 짧은 기간 동안 진행
      - 사용자 스토리를 더 작은 단위로 나누고, **TDD(테스트 주도 개발)**와 짝 프로그래밍을 통해 실제 코드를 작성합니다.
   5. 승인 테스트 (Acceptance Test / 검사)
      - 이터레이션이 끝날 때마다 고객이 직접 자신의 요구사항(사용자 스토리)대로 만들어졌는지 테스트
      - 오류가 발견되면 다음 이터레이션에 반영
   6. 소규모 릴리즈 (Small Release)
      - 승인 테스트를 통과한 결과물을 실제로 배포
      - 한 번에 크게 배포하는 것이 아니라, 기능을 쪼개서 자주 배포함으로써 고객이 가치를 빨리 체감

### 4. 현행 시스템 파악

1. **현행 시스템 파악의 개요**

   > 새로 개발하려는 시스템의 개발 범위를 명확히 설정하기 위해, 현재 운영 중인 시스템이 어떤 구성인지, 어떤 기술을 쓰고 있는지 등을 파악하는 과정

2. **현행 시스템 파악 절차**
   1. 1단계(소프트웨어 측면 파악)
      - 파악 항목 : 구성, 기능, 인터페이스
      - 어떤 시스템이 있고(구성), 무엇을 하며(기능), 어떻게 연결되는가(인터페이스)
      1. 시스템 구성의 파악
         - 우리 회사가 운영 중인 모든 정보시스템의 리스트를 파악하는 단계, 기간업무와 지원업무로 나뉨
           - 기간 업무: 회사의 핵심 매출을 만드는 업무 (예: 쇼핑몰의 주문/결제 시스템).
           - 지원 업무: 핵심을 돕는 업무 (예: 인사/회계 시스템).
      2. 시스템 기능의 파악
         - 각 시스템이 구체적으로 어떤 일을 하는지 파악하는 단계
         - 계층형 표시: 주요 기능(회원관리) > 하부 기능(로그인) > 세부 기능(SNS 로그인) 순으로 정리
      3. 시스템 인터페이스의 파악
         - 시스템끼리 대화하는 규칙을 단계
         - 데이터 형식(JSON, XML), 통신 규약(HTTP, TCP), 주기(실시간, 배치) 등이 핵심
   2. 2단계(기술 구조 측면 파악)
      - 파악 항목 : 아키텍처, 소프트웨어 구성
      - 어떤 설계도로 그려져 있는가
      1. 아키텍처 구성 파악
         - 시스템이 어떤 기술 계층으로 쌓여 있는지 보여주는 최상위 설계도
         - 보통 웹 서버, 애플리케이션 서버, 데이터베이스가 어떻게 층을 이루고 있는지(3-Tier 등)를 아키텍처 구성도로 작성
      2. 소프트웨어 구성 파악
         - 설치된 소프트웨어의 제품명, 용도, 라이선스 정보를 파악
         - 나중에 시스템을 새로 만들 때 라이선스 비용이 수억 원씩 들 수 있기 때문에 파악
   3. 3단계(물리적 기반 측면 파악)
      - 파악 항목 : 하드웨어 구성, 하드웨어 구성
      - 장비와 선은 어떻게 연결되어 있는가?
      1. 하드웨어 구성 파악
         - 서버의 CPU 성능, 메모리 용량, 서버 대수 등 물리적인 구성을 파악
         - 이중화(High Availability) 파악: 서버가 한 대 고장 나도 다른 한 대가 즉시 대신 일할 수 있게 세팅되어 있는지 확인
      2. 네트워크 구성 파악
         - 서버들이 어디에 있는지(물리적 위치), 광케이블이나 랜선이 어떻게 얽혀 있는지 네트워크 구성도로 파악
         - 보안 취약점을 미리 찾아내고, 장애가 났을 때 "어디가 끊겼지?"를 빨리 파악

### 5. 개발 기술 환경 파악

1. **개발 기술 환경 파악의 개요**

   > 소프트웨어를 개발할 때 기반이 되는 운영체제(OS), 데이터베이스(DBMS), 미들웨어(WAS) 등을 선정할 때 무엇을 따져봐야 하는지, 그리고 오픈 소스 사용 시 주의점을 파악하는 단계

2. 운영체제(OS, Operating System)
   - 하드웨어와 사용자 사이의 인터페이스 역할을 하며 자원을 효율적으로 관리하는 시스템 소프트웨어
   - OS 요구사항 식별 시 고려사항
     - | 구분      | 주요 고려사항 (Keywords)                                                  |
       | --------- | ------------------------------------------------------------------------- |
       | 가용성    | 장시간 운영 시 결함 여부, 메모리 누수(Leak), 패치 설치를 위한 재가동 여부 |
       | 성능      | 대규모 동시 사용자 처리, 대용량 파일 작업, 지원 가능한 메모리 크기        |
       | 기술 지원 | 제작사의 안정성, 오픈 소스 여부, 사용자 간 정보 공유(커뮤니티)            |
       | 주변 기기 | 설치 가능한 하드웨어 종류, 여러 주변기기 지원 여부                        |
       | 구축 비용 | 하드웨어 비용, 라이선스 정책, 유지관리 비용, 총 소유 비용(TCO)            |

3. 데이터베이스 관리 시스템 (DBMS)
   - 사용자와 데이터베이스 사이에서 데이터를 관리하고 공용할 수 있도록 환경을 제공하는 소프트웨어
   - DBMS 요구사항 식별 시 고려사항
     - | 구분        | 주요 고려사항 (Keywords)                                                 |
       | ----------- | ------------------------------------------------------------------------ |
       | 가용성      | 백업 및 복구 편의성, 이중화(Replication) 및 복제 지원 여부               |
       | 성능        | 대규모 데이터/트랜잭션 처리 성능, 튜닝 옵션, 질의 최적화(Optimizer) 지원 |
       | 기술 지원   | 제작사의 기술 지원, 오픈 소스 여부                                       |
       | 상호 호환성 | 설치 가능한 OS 종류, JDBC/ODBC와의 호환성                                |
       | 구축 비용   | 라이선스 정책, 총 소유 비용(TCO)                                         |

4. 웹 애플리케이션 서버 (WAS, Web Application Server)
   - 사용자의 요구에 따라 변하는 동적인 콘텐츠를 처리하기 위한 미들웨어입니다.
   - WAS 요구사항 식별 시 고려사항
     - | WAS 요구사항 식별 시 고려사항 | 주요 고려사항 (Keywords)                                                 |
       | ----------------------------- | ------------------------------------------------------------------------ |
       | 가용성                        | 백업 및 복구 편의성, 이중화(Replication) 및 복제 지원 여부               |
       | 성능                          | 대규모 데이터/트랜잭션 처리 성능, 튜닝 옵션, 질의 최적화(Optimizer) 지원 |
       | 기술 지원                     | 제작사의 기술 지원, 오픈 소스 여부                                       |
       | 상호 호환성                   | 설치 가능한 OS 종류, JDBC/ODBC와의 호환성                                |
       | 구축 비용                     | 라이선스 정책, 총 소유 비용(TCO)                                         |

5. 오픈 소스(Open Source) 사용 시 고려사항
   - 라이선스의 종류: 저작권 준수 여부(GPL, Apache, MIT 등 라이선스마다 의무사항이 다름).
   - 기술의 지속 가능성: 개발자 커뮤니티가 활발한지, 향후 업그레이드가 계속될 것인지 확인.
   - 사용자 수: 이미 많은 기업에서 검증된 소프트웨어인지 확인.

### 6. 요구사항 정의

1. **요구사항(Requirement) 개요**

   > 소프트웨어가 문제를 해결하기 위해 제공해야 하는 서비스와 운영에 필요한 제약조건
   - 목표: 이해관계자(고객, 개발자 등) 간의 의사소통을 원활하게 하고, 개발의 기준과 근거를 마련
   - 중요성: 요구사항이 잘못 정의되면 전체 프로젝트가 산으로 갈 수 있으므로 가장 신중해야 하는 단계

2. **요구사항의 유형**
   - | 유형            | 핵심 내용                             | 주요 예시                                              |
     | --------------- | ------------------------------------- | ------------------------------------------------------ |
     | 기능 요구사항   | 시스템이 **'무엇(What)'**을 하는가?   | 로그인, 결제, 장바구니 담기, 데이터 조회               |
     | 비기능 요구사항 | '어떻게(How)' 운영되는가? (품질/제약) | 응답 시간 1초 이내, 보안 암호화, 가용성 99.9%, OS 제약 |
     | 사용자 요구사항 | 사용자 관점 (친숙한 언어)             | "사용자가 쉽게 결제할 수 있어야 한다."                 |
     | 시스템 요구사항 | 개발자 관점 (기술적 용어)             | "결제 모듈은 외부 API와 HTTPS로 연동되어야 한다."      |

3. **요구사항 개발 프로세스**
   1. 사전 단계
      - 개발 대상에 대한 요구사항을 체계적으로 도출하고 이를 분석한 후 분석 결과를 명세서(Specification Document)에 정리한 다음 마지막으로 이를 확인 및 검증하는 일련의 활동
      - 요구사항 개발 프로세스가 진행되기 전에 개발 프로세스가 비지니스 목적에 부합되는지, 예산은 적정한지 등에 대한 정보를 수집, 평가한 보고서를 토대로 타당성 조사(Feasibility Study)가 선행필수

   2. 요구사항 개발 단계
      1. 도출 (Elicitation): 고객과 대화하며 요구사항이 어디에 있는지 수집하는 단계 (인터뷰, 브레인스토밍, 프로토타이핑).
      2. 분석 (Analysis): 모호한 내용을 걸러내고 비용과 일정 제약을 조율하는 단계 (자료 흐름도 DFD, 자료 사전 DD 활용).
      3. 명세 (Specification): 분석된 내용을 문서(SRS)로 작성하는 단계 (소단위 명세서 등 활용).
      4. 확인 (Validation): 명세서가 완벽한지 검토하고 검증하는 단계 (형상 관리 수행).

### 7. 요구사항 분석

1. **요구사항(Requirement) 분석의 개요**
   - 사용자의 요구를 구체적으로 이해하고, 이를 **문서화(명세화)**하는 활동
   - 목표: 사용자 요구의 타당성 조사, 비용/일정 제약 설정, 목표 확정.
   - 도구: UML, DFD, 자료 사전(DD), 소단위 명세서(Mini-Spec), ERD, STD 등.
   - 핵심: 분석의 결과물은 이후 설계 단계의 기초 자료

2. **구조적 분석 기법**
   - 자료의 흐름과 처리를 중심으로 하는 고전적이면서도 강력한 요구사항 분석 방법
   - 하향식(Top-Down) 방법: 큰 시스템을 작은 단위로 세분화하며 분석합니다.
   - 특징: 도형 중심의 도구를 사용하여 중복을 배제하고 분석의 질을 높입니다.

3. **자료 흐름도 (DFD; Data Flow Diagram)**
   - DFD의 4가지 기본 기호
     - |  기호  | 이름                     | 의미                                   | 모양                |
       | :----: | :----------------------- | :------------------------------------- | :------------------ |
       | **○**  | 프로세스 (Process)       | 자료를 변환시키는 처리 과정            | 원 또는 둥근 사각형 |
       | **→**  | 자료 흐름 (Data Flow)    | 자료의 이동 통로                       | 화살표              |
       | **〓** | 자료 저장소 (Data Store) | 시스템 내의 자료 저장 공간 (DB, 파일)  | 평행선 (두 줄)      |
       | **□**  | 단말 (Terminator)        | 시스템 외부의 엔티티 (입력원/출력대상) | 사각형              |

### 8. 요구사항 분석 CASE와 HIPO

1. **요구사항 분석 CASE(자동화 도구)**

   > CASE(Computer Aided Software Engineering)는 요구사항 분석 과정을 컴퓨터 소프트웨어의 도움을 받아 자동화하는 도구.
   - 장점
     - 표준화와 보고를 통한 문서화 품질 개선
     - 데이터베이스가 모두에게 이용 가능하다는 점에서 분석가들 간의 적절한 조정
     - 변경이 주는 영향 추적의 용이성
     - 명세에 대한 유지보수 비용의 축소
   - 종류
     - | 도구명  | 제조사/출처 | 핵심 특징                                                      |
       | ------- | ----------- | -------------------------------------------------------------- |
       | SADT    | SoftTech 사 | 블록 다이어그램을 채택한 구조적 분석/설계 도구                 |
       | SREM    | TRW 사      | 실시간 처리 소프트웨어 타겟. RSL(언어) + REVS(분석기) 구성     |
       | PSL/PSA | 미시간 대학 | PSL(언어) + PSA(분석기)를 사용하는 도구                        |
       | TAGS    | -           | 개발 주기의 전 과정에 이용되는 통합 도구. IORL(명세 언어) 사용 |

1. **HIPO (Hierarchy plus Input-Process-Output)**
   > 시스템의 분석, 설계, 문서화에 사용되는 기법
   - 특징
     - 하향식(Top-Down) 소프트웨어 개발을 위한 도구.
     - 기호와 도표를 사용해 이해가 빠르고 유지보수가 용이함.
     - 기능과 자료의 의존 관계를 동시에 표현 가능.
   - 종류
     - 가시적 도표 (Visual Table of Contents): 시스템의 전체적인 기능과 흐름을 계층(Tree) 구조로 보여주는 도표.
     - 총체적 도표 (Overview Diagram): 입력, 처리, 출력에 대한 전반적인 정보를 제공하는 도표.
     - 세부적 도표 (Detail Diagram): 총체적 도표에 표시된 기능을 구성하는 요소들을 상세히 기술하는 도표.

### 9. UML(Unified Modeling Language)

1. **UML의 개요**

   > UML은 객체지향 소프트웨어 개발 과정에서 산출물을 가시화, 명세화, 구축, 문서화하는 데 사용되는 표준화된 모델링 언어.

2. **UML의 구성요소**
   - 구성 요소: 사물(Things), 관계(Relationships), 다이어그램(Diagram).
   1. 사물 (Things)
      - 구조 사물: 클래스, 유스케이스, 컴포넌트, 노드 등 (물리적 요소).
      - 행동 사물: 상호작용, 상태 머신 등 (동적 요소).
      - 그룹 사물: 패키지 (요소들을 그룹화).
      - 주해 사물: 노트 (설명이나 제약조건).
   2. 관계 (Relationships)
      - 사물과 사물 사이의 연관성을 표현
      - | 관계명                 | 특징 및 표현 방식                          | 핵심 키워드              |
        | ---------------------- | ------------------------------------------ | ------------------------ |
        | 연관(Association)      | 실선으로 연결. 다중도 표기 가능.           | 2개 이상의 사물이 관련됨 |
        | 집합(Aggregation)      | 속이 빈 마름모. 전체와 부분의 독립적 관계. | 독립적, Whole-Part       |
        | 포함(Composition)      | 속이 채워진 마름모. 생명주기를 함께함.     | 영구적, 변화 영향 미침   |
        | 일반화(Generalization) | 속이 빈 화살표. 부모와 자식 관계.          | 상속, Is-a 관계          |
        | 의존(Dependency)       | 점선 화살표. 짧은 시간 동안만 연관.        | 매개변수 사용, 임시적    |
        | 실체화(Realization)    | 속이 빈 점선 화살표. 인터페이스 구현.      | 기능 수행 지정           |
   3. 다이어그램 (Diagram)
      1. 구조적(Structural) 다이어그램 : 정적 모델링
         - 클래스(Class): 시스템 구조 파악의 핵심.
         - 객체(Object): 특정 시점의 객체 인스턴스 표현. (럼바우 객체 모델링)
         - 컴포넌트(Component): 실제 구현 모듈 간의 관계.
         - 배치(Deployment): 물리적 요소(노드)의 위치 표현.
         - 복합체 구조 / 패키지
      2. 행위(Behavioral) 다이어그램 : 동적 모델링
         - 유스케이스(Use Case): 사용자 요구 분석, 기능 모델링.
         - 순차(Sequence): 객체 간 주고받는 메시지를 시간 순서로 표현.
         - 상태(State): 객체의 상태 변화 표현. (럼바우 동적 모델링)
         - 활동(Activity): 로직이나 처리 흐름을 순서대로 표현. (럼바우 기능 모델링)
         - 커뮤니케이션 / 상호작용 개요 / 타이밍

### 10. 주요 UML 다이어그램 (Use Case, Class, Sequence)

1. **유스케이스(Use Case) 다이어그램**
   - 사용자의 관점에서 시스템이 제공하는 기능을 표현한 기능 모델링 도구
   - 특징: 개발될 시스템의 범위를 정의하고, 외부 요소(액터)와의 상호작용을 파악합니다.
   - 구성 요소
     - 시스템(System) 범위: 내부 기능을 사각형으로 묶어 표현.
     - 액터(Actor): 시스템과 상호작용하는 외부 존재 (사람 = 주액터, 외부 시스템 = 부액터).
     - 유스케이스(Use Case): 시스템이 제공하는 개별 서비스나 기능 (타원형으로 표기).
     - 관계: 연관, 포함(include), 확장(extend), 일반화 관계.

2. **클래스(Class) 다이어그램**
   - 시스템의 정적 구조를 표현하는 대표적인 구조적 다이어그램
   - 클래스의 구성
     - 이름(Name)
     - 속성(Attribute): 상태나 정보 (변수)
     - 오퍼레이션(Operation): 동작이나 함수 (메서드)

3. **순차(Sequence) 다이어그램**
   - 객체들이 주고받는 메시지를 시간의 흐름에 따라 표현한 행위 다이어그램
   - 구성 요소
     - 생명선(Lifeline): 객체가 메모리에 존재하는 기간 (점선).
     - 실행 상자(Active Box): 객체가 실제 구동되고 있는 시간 (직사각형).
     - 메시지(Message): 객체 간 주고받는 신호 (화살표).
     - 회귀 메시지(Reply): 처리 결과 반환 (점선 화살표).
     - 제어 블록(Loop): 반복되는 영역 표시.
