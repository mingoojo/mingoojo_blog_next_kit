---
title: '[정보처리기사 자격증 공부] Chaper1 - 소프트웨어 설계 (WEEK 1)'
date: '2025-12-09'
tags: ['dev', 'license']
draft: false
summary: 정보처리기사 1주차 내용정리 - 소프트웨어 설계
---

import ImageWithCaption from '@/components/mdxComponents/ImageWithCaption'

### 1. 소프트웨어 공학

1.  **소프트웨어**

    > 컴퓨터 시스템을 운영하거나 특정 업무를 수행하기 위해 작성된 프로그램, 절차, 알고리즘, 문서 등을 포함하는 개념.
    > 형태가 없는 비물질적 재화(Intangible product).
    1. 시스템
       - 시스템의 개요
         - 컴퓨터로 처리 가능한 자료를 입력하고 저장, 처리, 가공해 출력할 수 있도록 설계된 정보체계
         - 하나의 목적을 위해 다양한 요소가 유기젹으로 결합
       - 기본요소
         - 입력, 처리, 출력, 제어, 피드백으로 구성
    2. 소프트웨어 특징
       - 상품성 : 소프트웨어를 개발하면 상품이 되어 판매가 된다.
       - 복잡성 : 개발하는 과정이 복잡하고 관리가 어렵다.
       - 변경 가능성 : 프로그램을 일부 수정하여 업그레이드 및 오류 수정 등을 할 수 있다.
       - 복제성 : 복제가 용이해 쉽게 복사, 유통이 가능하다.
    3. 소프트웨어 위기
       - 컴퓨터의 발달 과정에서 소프트웨어의 개발 속도가 하드웨어의 개발 속도를 따라가지 못해 사용자들의 요구사항을 감당할 수 없는 문제가 발생함을 의미한다.
       - 소프트웨어 위기의 원인
         - 하드웨어 비용을 초과하는 개발 비용의 증가
         - 개발 기간의 지연
         - 개발 인력 부족 및 인건비 상승
         - 성능 및 신뢰성 부족
         - 유지보수의 어려움에 따른 비용 발생
    4. 소프트웨어 공학(소프트웨어 개발부터 파기까지의 모든 방법론)
       - 적은돈으로 빠른 시간안에 정확한 소프트웨어를 만들어 내는 방법, 도구와 절차들의 체계를 의미
       - IEEE(전기전자학회)는 소프트웨어의 개발, 운용, 유지보수 및 파기에 대한 체계적인 접근방법이라 정의
       - 소프트웨어 공학의 기본원칙
         - 현대적인 프로그래밍 기술 적용
         - 신뢰성이 높아야 함
         - 사용의 편리성과 유지보수성이 높아야함
         - 결과에 대한 명확한 기록을 유지해야 함
         - 사용자가 원하는 대로 동작
         - 시스템의 안전성과 보안에 만전을 기한다.
         - 최신 프로그램 언어, 최신 알고리즘 사용 현황을 확인
         - 소프트웨어 개발 비용 최소화
         - 개발 단계와 소스 코드 등의 문서화를 통해 명확성을 유지하도록 한다.
    5. 공학적으로 좋은 소프트웨어
       - 신뢰성이 높고 효율적이어야함.
       - 사용자의 의도대로 작동
       - 편리성 제공 및 잠재적 에러를 최소화 해야한다.
       - 유지보수성이 용이해야 한다.
    6. 소프트웨어의 공학 계층 구조
       - 도구 : 프로세스와 방법을 처리하는 기능을 제공하는 것
       - 방법론 : 소프트웨어를 설계하는데 기술적인 방법을 제공하는 것
       - 프로세스 : 소프트웨어의 가장 기초가 되며 개발에 사용되는 방법론과 도구가 적용되는 순서를 의미
    7. 소프트웨어의 품질 목표
       - 소프트웨어 품질
         - 사용자의 요구대로 만들어야 한다
         - 유지보수가 쉬어야 한다
         - 에러를 최소화
         - 초반에 정한 비용에 맞춰 개발
         - 정확한 결과가 도출
         - 원하는 시간에 원하는 기능을 수행
       - 소프트웨어 공학의 목표
         - 소프트웨어의 생선상과 품질을 향상
         - 최소의 비용으로 단기간에 시스템에 적합한 소프트웨어를 개발하는 것이 목표

2.  **재공학**
    1. 소프트웨어 재공학
       - 소프트웨어 위기를 개발의 생선상이 아닌 유지보수의 생산성으로 해결하려는 방법
       - 현재의 시스템을 변경, 재구조화 하는것
       - 재구조화는 재공학의 한 유형으로 사용자의 요구사항이나 기술적 설계의 변경 없이 프로그램을 개선하는 것
       - 소프트웨어 재공학 관점에서 가장 연관 깊은 유지보수 유형은 예방유지보수이다.
    2. 재공학의 장점, 목표, 과정
       - 장점 : 개발 시간 및 비용 감소, 품질 향상, 생산성 향상, 신뢰성 향상, 프로젝트 실패위험감소
       - 목표
         - 소프트웨어의 유지보수성 향상의 최우선 목표이다
         - 복잡한 시스템을 다루는 방법 구현, 다른 뷰의 생성, 잃어버린 정보의 복구 및 제거
         - 재사용을 수월하게 하며 소프트웨어의 수명을 연장하기 위해서이다.
       - 과정 : 분석 > 구성 > 역공학 > 이식
    3. 재공학의 과정
       - 분석 : 기존 소프트웨어의 명세서를 확인하여 소프트웨어의 동작을 이해하고 재공학 대상을 선정하는 것
       - 재구성 : 소프트웨어 구조를 향상시키기 위해 코드를 재구성하는 것
       - 역공학 : 원시 코드를 분석하여 소프트웨어 관계를 파악하고 기존 시스템의 설꼐 정보를 재발견하여 다시 제작하는 작업
       - 이식 : 기존 소프트웨어 시스템을 새로운 기술 또는 하드웨어 환경에서 사용할 수 있도록 변환하는 작업
    4. CASE(Computer Aided Software Engineering)
       - 소프트웨어 개발 과정에서 사용되는 요구분석, 설계, 구현, 검사 및 디버깅 과정을 컴퓨터와 전용 소프트웨어 도구를 사용하여 자동화 하는 작업
       - 자료 흐름도 등의 다이어그랩을 쉽게 작성하게 해주는 소프트웨어 도구이다.
       - 작업 과정 및 데이터 공유를 통해 작업자 간의 커뮤니케이션 증대
    5. CASE가 제공하는 기능
       - 개발을 신속하고, 오류 수정이 쉽게 하여 소프트웨어 품질 향상
         - CASE 도구는 설계·코드·테스트를 자동화해서 사람이 일일이 반복 작업을 하지 않아도 된다.그 결과 개발 속도가 빨라지고, 사람이 만드는 실수도 줄어든다.
         - 예시
           - IntelliJ / VSCode의 자동완성(Auto-complete)
           - ESLint, Prettier 자동 코드 정리
       - 소프트웨어 생명주기의 전체 단계를 연결해 주고 자동화시켜 주는 통합된 도구를 제공해주는 기술이다.
         - 요구분석 → 설계 → 구현 → 테스트 → 유지보수 모든 과정을 하나의 플랫폼에서 관리할 수 있도록 해주는 것이 CASE의 핵심 개념.
         - 예시
           - IBM Rational Suite
       - 소프트웨어 시스템의 문서화 및 명세화를 위한 그래픽 기능을 제공
       - 소프트웨어 개발단계의 표준화를 기할 수 있으며 자료 흐름도 작성 기능을 제공
       - 모델들 사이의 모순 검사 기능을 제공하며 다양한 소프트웨어 개발 모형을 지원한다.
       - 원천 기술 : 구조적 기법, 프로토타이핑 기술, 정보저장소 기술
    6. CASE의 장점
       - 소프트웨어 개발 기간 단축 및 개발 비용절약
       - 품질이 향상
       - 재사용성이 향상
       - 소프트웨어 개발 주기의 표준안 확립, 개발 기법의 실용화, 문서화의 용이성 제공, 유지보수 축소
    7. CASE의 분류
       - 상위 CASE : 요구분석 및 설계 단계 지원 (StarUML, ERwin, Enterprise Architect)
       - 하위 CASE : 소스 코드 작성, 테스트, 문서화 지원 (VSCode, IntelliJ, Jenkins, JUnit, ESLint)
       - 통합 CASE : 소프트웨어 개발 주기 전체의 과정을 지원 (Rational Rose, IBM Rational Suite, Visual Studio)

3.  **개발방법론**
    1.  소프트웨어 생명주기
        - 소프트웨어 제품의 개념 형성에서 시작하여 운용/유지보수에 이르기까지 변화의 모든 과정
        - 타당성 검토 > 개발 계획 > 요구사항 분석 > 설계 > 구현 > 테스트 > 운영 > 유지보수
    2.  개발방법론의 모형(모델)
        - 폭포수 모형(선형 순차적 모델)
          - Boehm이 제시한 **고전적** 생명주기 모형
          - 소프트웨어 개발 과정의 각 단계가 순차적으로 진행되는 모형
          - 문서 기반, 변경에 약함
        - 나선형 모형
          - Boehm이 제시, 반복적인 작업을 수행하는 점증적 생명주기 모형
          - 소프트웨어 개발 중 발생할 수 있는 위험을 관리, 최소화하는 것을 목적으로 함(**위험분석**)
          - 나선을 따라 돌면서 순차적으로 반복하여 수행하는 점진적 방식
            <ImageWithCaption src="/static/images/spiralModel.png" alt="spiral model" caption="나선형 구조" />
        - v-모델
          - 폭포수 모델을 개선한 검증·테스트 중심 개발방법론으로, **개발 과정의 각 단계마다 대응되는 테스트 단계를 명확히 연결한 모델**
            <ImageWithCaption src="/static/images/v-model.png" alt="v-model" caption="v-모델" />
          - 특징
            - 테스트 중심 모델 : 각 설계 단계마다 대응되는 테스트 계획을 먼저 세운다. > 신뢰도 높은 시스탬 개발에 효과적
            - 문서 기반 : 폭포수처럼 문서화를 중시.
            - 변경에 약함 : 요구 사항이 자주 바뀌는 프로젝트에는 부적합.
            - 대형 프로젝트·공공 SI에서 흔히 사용
    3.  설계 방식
        - 하향식 설계
          - 소프트웨어의 설계 시 제일 상위에 있는 Main User Function에서 시작하여 기능을 하위 기능들로 나눠가면서 설계하는 방식
          - 전체 시스템 → 하위 모듈로 점점 쪼개 내려가며 설계하는 방식
          - 특징
            - 전체 구조(아키텍처)를 먼저 정의
            - 큰 기능을 세부 기능으로 분해(분할 정복)
            - 조직적이고 문서화에 강함
            - 폭포수 모델과 잘 맞는 방식
          - 장점
            - 시스템 전체 흐름을 쉽게 이해
            - 모듈 간 인터페이스를 명확히 정의
            - 구조적 설계에 적합
          - 단점
            - 하위 모듈의 실제 구현 가능성을 초기에 정확히 예측하기 어려움
            - 부분 구현이 늦어짐 (상위 설계가 끝나야 하위 개발 가능)

        - 상향식 설계
          - 가장 기본적인 컴포넌트를 먼저 설계 한 다음 이것을 사용하는 상위 수준의 컴포넌트를 설계하는 방식
          - 작은 단위의 모듈을 먼저 개발한 뒤 → 이들을 조합해 전체 시스템을 완성하는 방식
          - 특징
            - 재사용 가능한 컴포넌트 중심
            - 실제 구현 가능한 부분부터 제작 가능
            - 애자일 개발 방식과 철학적으로 잘 맞음
          - 장점
            - 초기에 작게라도 실행 가능한 기능이 나옴
            - 재사용성, 모듈화가 쉬움
            - 현실적이고 유연함
          - 단점
            - 전체 구조를 뒤늦게 맞추려면 조정 비용 발생
            - 작은 모듈들이 전체 비즈니스 요구와 어긋날 가능성이 있음

    4.  설계 도구
        - HIPO(Herearchy Input Process Output) - 계층적 입력 출력 과정
          - 시스템을 계층적으로 나누고, 각 기능(프로세스)의 입력(Input), 처리(Process), 출력(Output)을 체계적으로 표현하는 방법
          - 일반적으로 **가시적 도표(Visual Table of Contents)**, 총체적 다이어그램, 세부적 다이어그램으로 구성된다.
          - 가시적 도표는 전체적인 기능과 흐름을 보여주는 구조
          - 보기 쉽고 이해하기 쉬우며 유지보수가 쉬움
          - 하양식 소프트웨어 개발을 위한 문서화 도구
    5.  개발방법론
        - 에자일 개발 방법론
          - 특정 모형을 특정하는 것이 아닌 좋은것을 빠로그 낭비없이 만들기 위해 고객과의 소통에 초점을 맞춘 방법론의 총칭
          - 작은 단위로 빠르게 개발하고, 고객·사용자의 피드백을 받아 지속적으로 개선하는 반복·점진적 개발방법론
          - 짧은 배포(릴리즈), 점증적 설계, 사용자 참여
          - 애자일의 핵심 철학 4가지(에자일 선언문)
            - 프로세스보다 개인과 상호작용을 중시
            - 작동하는 소프트웨어를 중시
            - 문서보다 고객 협업을 중시
            - 계획보다 변화 대응을 중시
        - xp(extreme programming)
          - **익스트림 프로그래밍(Extreme Programming, XP)**은 애자일 개발방법론 중 하나로, 소프트웨어 품질을 극대화하기 위해 ‘고객 참여·테스트·리팩토링·커뮤니케이션’을 극도로 강조하는 개발 방식
          - 특징
            - 요구사항변동이 많을때 사용하는 방식
            - 요구사항이 변경되는 것을 젹용하는 방식
          - 핵심 가치
            - 소통 : 개발자, 관리자, 고객간의 소통을 지향
            - 단순성 : 부가적 기능 또는 미사용 구조와 알고리즘은 배제한다
            - 피드백 : 소프트웨어 개발에서 변화가 불가피함을 받아들이고 지속적 테스트, 결함 수정등에 능동적으로 대응
            - 용기 : 고객 요구사항 변화에 능동적 대응
            - 존중 : 개발 팀원 간의 상호 존중을 기본으로 함

4.  **SCRUM**
    1.  스크럼의 개념과 특징
        - 애자일 방법론의 한 종류이며 반복 주기(Sprint)를 기반으로 팀이 자율적으로 협업하여 제품을 점진적으로 개발하는 프레임워크.
        - 스크럼의 핵심
          - 스프린트
            - 1~2주 동안 할 수 있는 만큼만 목표 잡음
            - 이 기간을 스프린트라고 부름
            - 끝나면 바로 다음 스프린트 시작
          - 데일리 스크럼
            - 매일 하는 짧은 스탠드업 미팅
            - 어제 한 일, 오늘 할 일, 장애 요소(Blocker)만 공유
          - 스프린트 리뷰(Sprint Review)
            - 스프린트 결과물을 실제로 시연
            - 이해관계자 피드백 수집
            - 백로그 변경 가능
          - 스프린트 회고(Retrospective)
            - 프로세스 개선 회의
            - “잘된 점, 개선할 점, 다음 스프린트부터 적용할 것” 정리
        - 스크럼의 장점
          - 변경 대응력 매우 높음 : 매 스프린트마다 우선순위 재조정 가능
          - 협업 강화 : 데일리 스크럼·회고로 지속적 개선
          - 빠른 피드백 : 리뷰를 통해 고객 반응을 바로 반영
          - 작동하는 제품을 반복적으로 제공 : 위험 감소
        - 스크럼의 단점
          - 팀 성숙도에 따라 성과 편차 큼 : 소통 능력·자율성이 부족하면 실패
          - PO·SM 역할 수행이 매우 중요 : 오너 부재나 코칭 부족하면 프레임워크 붕괴
          - 많은 회의 부담 : 데일리·회고·리뷰 등 일정 조율 필요
        - 스크럼 참여 역할(Roles)
          - 스크럼에는 3가지 역할만 존재함.
          - **제품 책임자(PO: Product Owner)**
            - 제품의 비전과 방향 설정
            - 백로그 우선순위 결정
            - 고객·이해관계자 요구사항 대리인 역할
          - **스크럼 마스터(SM: Scrum Master)**
            - 스크럼 규칙을 지키도록 코칭
            - 팀 장애물 제거
            - 퍼실리테이터 역할
          - **개발팀(Developers)**
            - 직접 제품을 만드는 사람들
            - 자율적으로 스프린트 목표를 수행
            - 디자이너, 기획자, 개발자 모두 포함 가능
        - 스크럼 산출물(Artifacts)
          - 제품 백로그(Product Backlog)
            - 현재·미래 기능, 요구사항의 전체 목록
            - PO가 관리
            - 계속 추가·변경되는 살아있는 문서
          - 스프린트 백로그(Sprint Backlog)
            - 이번 스프린트에 개발할 작업 목록
            - 개발팀이 선정하고 계획
          - 인크리먼트(Increment)
            - 스프린트 종료 시 제공되는 작동하는 제품 결과물
            - “완료(Definition of Done)” 기준을 만족해야 함
