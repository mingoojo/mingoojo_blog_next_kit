---
title: '[정보처리기사 자격증] 3.데이터베이스 구축 > 1장 논리 데이터베이스 설계 (WEEK 6)'
date: '2026-01-19'
tags: ['dev', 'license']
draft: false
summary: 정보처리기사 6주차 내용정리 - 논리 데이터베이스 설계
# https://velog.io/@alpaka206/60.-데이터베이스-설계
---

import ImageWithCaption from '@/components/mdxComponents/ImageWithCaption'

### 1. 데이터베이스 설계

1. **데이터베이스 설계 개요**

   > 사용자가 원하는 데이터를 체계적으로 저장하고 사용할 수 있도록 데이터베이스 구조를 만드는 전체 과정
   - 쉽게 말하면, 집을 짓는 것과 비슷
     - 어떤 집이 필요한지 파악하고 (요구 분석)
     - 설계도를 그리고 (개념적/논리적 설계)
     - 실제 자재를 선택하고 (물리적 설계)
     - 집을 완성하는 것 (구현)

2. **설계 시 반드시 고려해야 할 6가지**
   | 고려사항 | 의미 | 쉬운 예시 |
   | ---------- | ---------------------------------- | ---------------------------------------------- |
   | **무결성** | 데이터가 항상 정확하고 유효해야 함 | 나이에 -5살이 들어가면 안 됨 |
   | **일관성** | 같은 질문에는 항상 같은 답 | A 창구와 B 창구에서 잔액 조회 결과가 같아야 함 |
   | **회복** | 장애 발생 시 복구 가능 | 정전 후에도 데이터가 살아있어야 함 |
   | **보안** | 불법 접근 차단 | 내 계좌를 남이 볼 수 없어야 함 |
   | **효율성** | 빠르고 공간 절약 | 검색이 빨라야 하고, 저장 공간 낭비 X |
   | **확장성** | 데이터 추가가 자유로움 | 회원이 늘어나도 시스템이 멈추면 안 됨 |

3. **데이터베이스 설계 5단계**
   - 요구 조건 분석 → 개념적 설계 → 논리적 설계 → 물리적 설계 → 구현
     1. 요구 조건 분석 (Requirements Analysis)
        - **요구사항 분석이란**
          - 뭘 만들어야 하는지 파악
          - 사용자 인터뷰를 통해 필요한 데이터 수집
          - 어떤 데이터가 필요한지, 어떻게 처리할지 파악
          - **요구 조건 명세서** 작성
        - **하는 일**
          - 사용자 인터뷰를 통해 필요한 데이터 수집
          - 어떤 데이터가 필요한지, 어떻게 처리할지 파악
          - **요구 조건 명세서** 작성
        - **예시** : 쇼핑몰을 만든다면?
          - 고객 정보가 필요해요 (이름, 연락처, 주소)
          - 상품 정보가 필요해요 (상품명, 가격, 재고)
          - 주문 정보가 필요해요 (누가, 뭘, 언제 샀는지)
     2. 개념적 설계 (Conceptual Design)
        - **개념적 설계란**
          - 현실 세계를 추상화된 모델로 표현
          - 정보 모델링, 개념화
          - **E-R 다이어그램** 작성 (시험에 자주 나옴!)
          - **DBMS에 독립적** (특정 DB에 종속되지 않음)
        - **하는 일**
          - 개념 스키마 모델링
          - 트랜잭션 모델링 (병행 수행)
        - **E-R 다이어그램이란?**
          - Entity(개체)와 Relationship(관계)를 그림으로 표현
          - 예: 고객 ─ 주문하다 ─ 상품
          - 주문 정보가 필요해요 (누가, 뭘, 언제 샀는지)
        - **핵심 포인트**: 이 단계에서는 "MySQL 쓸까, Oracle 쓸까" 같은 건 생각하지 않는다!
     3. 논리적 설계 (Logical Design)
        - **논리적 설계란**
          - 개념을 특정 DBMS가 이해할 수 있는 구조로 변환
          - 데이터 모델링
          - **DBMS에 종속적** (개념적 설계와 반대!)
          - **테이블 설계** (관계형 DB의 경우)
          - 트랜잭션 인터페이스 설계
        - **하는 일**
          - 개념 스키마 → 논리적 스키마로 변환(mapping)
          - 필드, 데이터 타입, 관계 정의
     4. 논리적 설계 (Logical Design)
        - **물리적 설계란**
          - 실제 저장 방법 결정
          - 데이터 구조화
          - 저장 구조 및 **액세스 경로** 결정
          - **성능 최적화**
        - **하는 일**
          - 저장 레코드 양식 설계
          - 인덱스 설계 (빠른 검색을 위해)
          - 파일 구조 결정
        - **고려 사항**
          - 트랜잭션 처리량
          - 응답 시간
          - 디스크 용량
          - 저장 공간의 효율화
     5. 데이터베이스 구현 (Implementation)
        - **데이터베이스 구현이란**
          - 실제로 DB를 만들고 사용 가능하게 함
        - **하는 일**
          - **DDL**(데이터 정의어)로 스키마 작성 → 컴파일
          - 빈 데이터베이스 파일 생성
          - 데이터 입력
          - 트랜잭션 작성
          - 응용 프로그램 개발
        - **DDL 예시**
          ```sql
            CREATE TABLE 고객 (
                고객ID INT PRIMARY KEY,
                이름 VARCHAR(50),
                연락처 VARCHAR(20)
            );
          ```

---

### 2. 데이터 모델의 개념

> 데이터 모델 = 현실 세계를 DB에 표현하기 위한 **중간 다리**

1. **데이터 모델의 정의**
   - 현실 세계의 정보를 **단순화·추상화**해서 컴퓨터가 이해할 수 있게 표현한 개념적 모형
   - 그냥 "데이터 모델"이라고 하면 → **논리적 데이터 모델**을 의미!

2. **데이터 모델의 구성 요소 3가지 (시험 필수!)**
   | 구성 요소 | 설명 | 예시 |
   | ----------------------- | ------------------------------- | ------------------------ |
   | **개체 (Entity)** | 표현하려는 대상, 정보 단위 | 학생, 교수, 과목 |
   | **속성 (Attribute)** | 데이터의 가장 작은 단위 (=필드) | 이름, 학번, 전화번호 |
   | **관계 (Relationship)** | 개체 간의 논리적 연결 | 학생이 과목을 "수강한다" |

3. **관계의 3가지 형태**
   | 형태 | 설명 | 예시 |
   | ------- | -------------------------------------- | --------------- |
   | **1:1** | A의 각 원소 ↔ B의 원소 **1개**씩 대응 | 사람 - 주민번호 |
   | **1:N** | A의 1개 → B의 **여러 개** 대응 | 부서 - 직원 |
   | **N:M** | A의 여러 개 ↔ B의 여러 개 대응 | 학생 - 과목 |

4. **데이터 모델의 종류**
   | 종류 | 특징 | 대표 모델 |
   | ---------- | ------------------------------------------------------ | ----------------------- |
   | **개념적** | 인간이 이해하기 쉬운 추상적 표현, 정보 모델이라고도 함 | **E-R 모델** |
   | **논리적** | 컴퓨터가 이해할 수 있는 구조로 변환 | 관계·계층·네트워크 모델 |
   | **물리적** | 실제 저장 방법 | 저장 구조 |
   - 논리적 데이터 모델 3가지
     - **관계 모델**: 테이블 형태 (가장 많이 사용!)
     - **계층 모델**: 트리 형태 (부모-자식)
     - **네트워크 모델**: 그래프 형태 (다대다 관계 표현)

5. **데이터 모델에 표시할 요소 3가지**
   | 요소 | 의미 | 키워드 |
   | ------------- | --------------------------- | ---------------- |
   | **구조** | 개체 타입들 간의 관계 | 정적 성질 |
   | **연산** | 데이터 처리 작업 명세 | 조작 도구 (CRUD) |
   | **제약 조건** | 저장될 데이터의 논리적 제한 | 유효성 규칙 |

---

### 3. E-R(개체-관계) 모델

> E-R 모델 = 개념적 데이터 모델의 **대표 주자!** (1976년 피터 첸 제안)

1. **E-R 모델이란?**
   - 개체(Entity)와 관계(Relationship)로 현실 세계를 표현하는 방법
   - **개념적 데이터 모델**의 가장 대표적인 모델
   - **DBMS에 독립적** (특정 DB 고려 X)
   - 1:1, 1:N, N:M 관계 모두 표현 가능
   - E-R 다이어그램 기호
     | 기호 | 이름 | 의미 |
     | :-------: | ----------- | --------------------------- |
     | **▭** | 사각형 | **개체(Entity)** 타입 |
     | **◇** | 마름모 | **관계(Relationship)** 타입 |
     | **○** | 타원 | **속성(Attribute)** |
     | **◎** | 이중 타원 | **다중값 속성** (복합 속성) |
     | **○̲** | 밑줄 타원 | **기본키(PK)** 속성 |
     | **─** | 선, 링크 | 개체와 속성 연결 |
     | **◇ N─M** | 관계 + 숫자 | 대응수 (1:1, 1:N, N:M) |
   - 복합 속성 예시

     ```
         ○ 성명
       / \
       ○   ○
     성   이름
     ```

     → 성명은 '성'과 '이름'으로 구성된 복합 속성

2. **E-R 다이어그램 예제**
   - **고객 - 주문서 관계**

     ```
     ○고객번호  ○성명  ○주소
       (PK)      |      |
         \       |     /
         ───[ 고객 ]───────┐
                          │
                         <주문>  ← 1:N 관계
                          │
         ───[ 주문서 ]─────┘
         /       |      \     \
     ○주문번호  ○품명  ○수량  ○금액
       (PK)
     ```

   - **해석**
     - 개체: 고객, 주문서
     - 관계: 주문 (1:N) → 한 고객이 여러 주문 가능
     - 기본키: 고객번호, 주문번호 (밑줄 표시)

---

### 4. 관계형 데이터베이스의 구조

> 관계형 DB = 모든 데이터를 테이블(표)로 표현! (1970년 코드 E.F. Codd 제안)

1. **관계형 데이터베이스란?**
   - 개체(Entity)와 관계(Relationship)를 모두 **릴레이션(테이블)**으로 표현
   - **장점**: 간결하고 보기 편함, 다른 DB로 변환 용이
   - **단점**: 성능이 다소 떨어짐
2. **릴레이션 구조**

   ```
           ← ────── 속성(Attribute) ────── →
           ← ────── 디그리(Degree)/차수 ── →
         ┌────────┬────────┬────────┬────────┐
         │ 학번    │ 이름    │ 학년    │ 학과     │ ← 스키마
         ├────────┼────────┼────────┼────────┤
     ↑   │ 1001   │ 김예소   │   2    │ 컴공    │ ← 튜플(행)
     │   ├────────┼────────┼────────┼────────┤
   튜플   │ 1002   │ 고강민   │   1    │ 경영    │ ← 튜플(행)
     │   ├────────┼────────┼────────┼────────┤
     │   │ 1003   │ 박지민   │   4    │ 전자    │ ← 튜플(행)
     ↓   └────────┴────────┴────────┴────────┘
         ←── 카디널리티(Cardinality)/기수 = 3 ──→
   ```

   - 핵심 용어 정리
     | 용어 | 의미 | 다른 표현 | 파일 구조 |
     | -------------------- | ----------------------------- | ------------ | --------- |
     | **튜플 (Tuple)** | 행 (가로) | Row | 레코드 |
     | **속성 (Attribute)** | 열 (세로) | Column | 필드 |
     | **카디널리티** | 튜플의 **수** | 기수, 대응수 | - |
     | **디그리** | 속성의 **수** | 차수 | - |
     | **도메인** | 속성이 가질 수 있는 값의 집합 | - | - |

3. **도메인(Domain) 이해하기**
   - 속성이 가질 수 있는 **허용된 값들의 집합**

   | 속성 | 도메인 예시               |
   | ---- | ------------------------- |
   | 성별 | ['남', '여']              |
   | 학년 | [1, 2, 3, 4]              |
   | 학점 | ['A', 'B', 'C', 'D', 'F'] |

   → 도메인 외의 값 입력 시 **시스템이 거부!**

4. **릴레이션의 특징 7가지**
   | 특징 | 설명 |
   | -------------------- | --------------------------------- |
   | **튜플 유일성** | 똑같은 튜플 X (중복 불가) |
   | **튜플 순서 무관** | 행의 위치가 바뀌어도 OK |
   | **속성 순서 무관** | 열의 위치가 바뀌어도 OK |
   | **속성명 유일** | 속성 이름은 중복 불가 |
   | **속성값 중복 가능** | 값은 중복 가능 (학년: 2, 2, 1...) |
   | **원자값** | 더 이상 쪼갤 수 없는 값만 저장 |
   | **시간에 따라 변함** | 삽입/삭제로 내용 변경 |

---

### 5. 관계형 데이터베이스의 제약 조건 - 키(key)

> 키(Key) = 튜플을 **구분**하는 기준이 되는 속성

1. **제약 조건이란?**
   - 데이터의 **정확성을 보장**하기 위해 입력 데이터에 제한을 주는 것
     - 개체 무결성 제약
     - 참조 무결성 제약

2. **키의 종류 5가지**

   ```
   ┌─────────────────────────────────────┐
   │            슈퍼키 (유일성 O)          │
   │  ┌───────────────────────────────┐  │
   │  │       후보키 (유일성 + 최소성)   │  │
   │  │  ┌──────────┬──────────┐     │  │
   │  │  │  기본키   │  대체키   │     │  │
   │  │  │  (PK)    │  (AK)    │     │  │
   │  │  └──────────┴──────────┘     │  │
   │  └───────────────────────────────┘  │
   └─────────────────────────────────────┘
           + 외래키(FK)는 별도!
   ```

   1. 후보키 (Candidate Key)
      - **기본키가 될 수 있는** 후보들
      - 조건: **유일성 + 최소성** 둘 다 만족
      - 모든 릴레이션에 **1개 이상** 존재

      | 조건       | 의미                           |
      | ---------- | ------------------------------ |
      | **유일성** | 하나의 키로 하나의 튜플만 식별 |
      | **최소성** | 꼭 필요한 속성으로만 구성      |

      > 예: 학생 테이블에서 '학번', '주민번호' → 둘 다 후보키

   2. 기본키 (Primary Key, PK)
      - 후보키 중 **선택된 대표 키**
      - 조건: 유일성 + 최소성 + **NULL 불가**
      - 릴레이션당 **1개만** 존재

      > 예: '학번'을 기본키로 선택 → 중복/NULL 입력 불가

   3. 대체키 (Alternate Key)
      - 후보키 중 **기본키 제외한 나머지**
      - = 보조키

      > 예: '학번'이 기본키면 → '주민번호'는 대체키

   4. 슈퍼키 (Super Key)
      - **유일성만 만족** (최소성 X)
      - 속성을 막 조합해도 됨

      > 예: '학번', '학번+이름', '학번+주민번호+이름' 모두 슈퍼키

   5. 외래키 (Foreign Key, FK)
      - **다른 릴레이션의 기본키를 참조**
      - 릴레이션 간 **관계 표현**
      - 참조하는 기본키에 **없는 값은 입력 불가**

      > 예: 수강 테이블의 '학번' → 학생 테이블의 '학번(PK)'을 참조

      ```
      [학생]                    [수강]
      학번(PK) | 이름           학번(FK) | 과목명
      ---------|-----          ---------|--------
      1001     | 김예소    ←──  1001     | 데이터베이스
      1002     | 고강민    ←──  1002     | 자료구조
      ```

   6. 핵심 비교표

      | 키 종류    | 유일성 | 최소성 | NULL | 개수     |
      | ---------- | :----: | :----: | :--: | -------- |
      | **슈퍼키** |   ⭕   |   ❌   |  -   | 여러 개  |
      | **후보키** |   ⭕   |   ⭕   |  -   | 1개 이상 |
      | **기본키** |   ⭕   |   ⭕   |  ❌  | **1개**  |
      | **대체키** |   ⭕   |   ⭕   |  -   | 0개 이상 |
      | **외래키** |   -    |   -    |  ⭕  | 여러 개  |

---

### 6. 관계형 데이터베이스의 제약 조건 - 무결성

> 무결성 = 저장된 데이터가 **현실 세계와 일치**하는 정확성

1. **무결성이란?**
   - DB의 데이터 값 = 현실 세계의 실제 값 → **정확성 보장**
   - 부정확한 데이터가 저장되는 것을 **방지**하는 제약 조건
2. **무결성의 종류 4가지 (시험 필수!)**
   | 종류 | 핵심 규정 | 관련 키 |
   | ---------------------- | ----------------------------------------- | ---------- |
   | **개체 무결성** | 기본키는 NULL/중복 불가 | 기본키(PK) |
   | **참조 무결성** | 외래키는 NULL이거나 참조 테이블 PK와 동일 | 외래키(FK) |
   | **도메인 무결성** | 정의된 도메인 값만 허용 | - |
   | **사용자 정의 무결성** | 사용자가 정한 조건 만족 | - |
   1. 개체 무결성 (Entity Integrity)
      - 규정: 기본키(PK)는 NULL과 중복을 허용하지 않음
        ```
        [학생] 테이블 - 기본키: 학번
        ─────────────────────────
        학번(PK) │ 이름   │ 주소
        ─────────────────────────
        1001     │ 김예소 │ 서울    ✅ OK
        NULL     │ 고강민 │ 부산    ❌ 기본키 NULL 불가!
        1001     │ 박지민 │ 대전    ❌ 기본키 중복 불가!
        ```
   2. 참조 무결성 (Referential Integrity)
      - 규정: 외래키는 NULL이거나 참조 테이블의 PK 값이어야 함
        ```
        [학생]                    [수강]
        학번(PK) │ 이름           학번(FK) │ 과목
        ─────────┼─────          ─────────┼──────
        1001     │ 김예소         1001     │ DB      ✅ OK
        1002     │ 고강민         NULL     │ 자료구조 ✅ OK (NULL 허용)
                                  9999     │ 네트워크 ❌ 참조할 수 없음!
        ```
      - 추가 규정: 외래키와 참조 기본키는 도메인과 속성 개수가 같아야 함
   3. 도메인 무결성 (Domain Integrity)
      - 규정: 정의된 도메인(허용값) 범위 내의 값만 입력 가능
        ```
        [수강] 테이블 - 과목명 도메인: {영어, 수학, 전산}
        ───────────────────
        학번   │ 과목명
        ───────────────────
        1001   │ 영어     ✅ OK
        1002   │ 과학     ❌ 도메인에 없음!
        ```
   4. 사용자 정의 무결성
      - 규정: 사용자가 직접 정의한 조건 만족
        - 예: "급여는 최저임금 이상이어야 한다"

3. 무결성 강화 방법 3가지

   | 방법             | 장점                        | 단점                  |
   | ---------------- | --------------------------- | --------------------- |
   | **애플리케이션** | 복잡한 조건 구현 가능       | 관리 어려움, 분산됨   |
   | **트리거**       | 통합 관리, 복잡한 조건 가능 | 변경 어려움           |
   | **제약 조건**    | 간단, 통합 관리, 변경 용이  | 복잡한 조건/예외 불가 |

   **TIP**: 무결성은 **DB 구축 과정에서** 정의해야 함! (나중에 하면 비용↑)

---

### 7. 관계대수 및 관계해석

> 관계대수 = 원하는 정보를 **어떻게** 얻을지 기술 (절차적)
> 관계해석 = 원하는 정보가 **무엇**인지 정의 (비절차적)

1. **관계대수 vs 관계해석**
   | 구분 | 관계대수 | 관계해석 |
   | ------ | ----------- | ----------------- |
   | 특성 | **절차적** | **비절차적** |
   | 표현 | 연산자 사용 | 계산 수식(질의어) |
   | 초점 | 어떻게(How) | 무엇을(What) |
   | 제안자 | - | 코드(E.F. Codd) |

💡 둘은 기능과 능력이 동등함! (서로 변환 가능)

2. **관계대수 연산자 총정리**
   1. 연산자 분류
      | 분류 | 연산자 |
      | -------------------- | -------------------------------------------------- |
      | **순수 관계 연산자** | Select, Project, Join, Division |
      | **일반 집합 연산자** | UNION, INTERSECTION, DIFFERENCE, CARTESIAN PRODUCT |
      - 순수 관계 연산자 (시험 필수!)
        1. Select (σ) - 시그마
           - Select는 릴레이션에 존재하는 튜플 중에서 선택 조건을 만족하는 튜플의 부분집합을 구하여 새로운 릴레이션을 만드는 연산
             | 항목 | 내용 |
             | ---- | ------------------------------- |
             | 기호 | **σ (시그마)** |
             | 기능 | 조건 만족하는 **튜플(행)** 추출 |
             | 별칭 | **수평 연산** (가로) |
             | 형식 | σ\<조건>(R) |

        ```
        σ Avg≥90 (성적)  →  평균 90점 이상인 행만 추출

        [성적]                         [결과]
        이름   | 평균                  이름   | 평균
        -------|------                 -------|------
        김예소 | 86.6      →           김준용 | 93.3
        김준용 | 93.3                  윤정희 | 90.0
        윤정희 | 90.0
        ```

        2. Project (π) - 파이
           - Project는 주어진 릴레이션에서 속성 리스트(Attribute List)에 제시된 속성 값만을 추출하여 새로운 릴레이션을 만드는 연산

        | 항목 | 내용                     |
        | ---- | ------------------------ |
        | 기호 | **π (파이)**             |
        | 기능 | 원하는 **속성(열)** 추출 |
        | 별칭 | **수직 연산** (세로)     |
        | 형식 | π\<속성리스트>(R)        |
        | 특징 | 중복 제거됨!             |

        ```
        π 이름,평균 (성적)  →  이름, 평균 열만 추출

        [성적]                              [결과]
        이름   | 국어 | 영어 | 평균         이름   | 평균
        -------|------|------|------  →    -------|------
        김예소 | 80   | 80   | 86.6        김예소 | 86.6
        김준용 | 90   | 100  | 93.3        김준용 | 93.3
        ```

        3. Join (⋈) - 보타이
           - Join은 공통 속성을 중심으로 두 개의 릴레이션을 하나로 합쳐서 새로운 릴레이션을 만드는 연산
           - **자연 조인 (Natural Join)**: 중복 속성 **1번만** 표시

        | 항목      | 내용                                 |
        | --------- | ------------------------------------ |
        | 기호      | **⋈ (보타이)**                       |
        | 기능      | 공통 속성으로 두 릴레이션 **합치기** |
        | 형식      | R ⋈\<조건> S                         |
        | 결과 차수 | 두 릴레이션 차수의 **합**            |

        ```
        성적 ⋈ No=No 학적부  →  No 기준으로 합침

        [성적]          [학적부]         [결과]
        No  | 이름      No  | 주소       No  | 이름  | 주소
        ----|-----      ----|-----   →   ----|-------|-----
        101 | 김예소    101 | 서울       101 | 김예소 | 서울
        102 | 김준용    102 | 부산       102 | 김준용 | 부산
        ```

        4. Division (÷)
           - Division은 X⊃Y인 두 개의 릴레이션 R(X)와 S(Y)가 있을 때, R의 속성이 S의 속성 값을 모두 가진 튜플에서 S가 가진 속성을 제외한 속성만을 구하는 연산

        | 항목 | 내용                                        |
        | ---- | ------------------------------------------- |
        | 기호 | **÷**                                       |
        | 기능 | S의 모든 값을 가진 R의 튜플에서 S 속성 제외 |
        | 형식 | R [속성r ÷ 속성s] S                         |

        💡 "S의 **모든 것**을 가진 애만 뽑아줘!" 느낌

      - 일반 집합 연산자
        - **병합 조건**: 합집합, 교집합, 차집합은 두 릴레이션의 **속성 수와 도메인이 같아야** 함!

        | 연산       | 기호 | 의미                 | 카디널리티          |
        | ---------- | :--: | -------------------- | ------------------- |
        | **합집합** |  ∪   | R 또는 S (중복 제거) | ≤ \|R\| + \|S\|     |
        | **교집합** |  ∩   | R 그리고 S           | ≤ MIN(\|R\|, \|S\|) |
        | **차집합** |  -   | R에만 있는 것        | ≤ \|R\|             |
        | **교차곱** |  ×   | 모든 조합 (순서쌍)   | = \|R\| × \|S\|     |
        - 예시

          ```
          [사원]        [직원]
          이름          이름
          -----         -----
          고회식        김준용
          김준용        윤정희

          합집합(∪): 고회식, 김준용, 윤정희
          교집합(∩): 김준용
          차집합(-): 고회식
          교차곱(×): (고회식,김준용), (고회식,윤정희), (김준용,김준용), (김준용,윤정희)
          ```

3. **관계해석**
   - 코드(E.F. Codd)가 제안
   - **비절차적** (무엇을 원하 는지만 정의)
   - 종류: **튜플 관계해석**,**도메인 관계해석**
   - 논리 기호
     | 기호 | 이름 | 의미 |
     | :---: | ----------- | ---------------------------------- |
     | **∀** | 전칭 정량자 | **모든** 튜플에 대해 (For All) |
     | **∃** | 존재 정량자 | **하나라도** 있으면 (There Exists) |

---

### 8. 정규화(Normalization)

> 정규화 = 릴레이션을 더 작은 단위로 쪼개서 바람직한 스키마로 만드는 과정

1. **정규화란?**
   - 함수적 종속성 이론을 이용해 스키마를 분해하는 과정
   - 논리적 설계 단계에서 수행
   - 차수가 높아질수록 제약 조건은 올라간다

2. **정규화의 목적**
   - 이상(Anomaly) 방지
   - 데이터 중복 최소화
   - 데이터 무결성 유지
   - 이상(Anomaly) 3가지 종류

   | 이상          | 설명                                       |
   | ------------- | ------------------------------------------ |
   | **삽입 이상** | 삽입 시 **원하지 않는 값**도 함께 삽입됨   |
   | **삭제 이상** | 삭제 시 **의도하지 않은 값**도 함께 삭제됨 |
   | **갱신 이상** | 일부만 갱신되어 **정보 모순** 발생         |

   💡 정규화를 안 하면 → 이상 현상 발생!

3. **정규화 단계**

   ```
   비정규 릴레이션
         ↓ 도메인이 원자값
       [1NF]
         ↓ 부분적 함수 종속 제거
       [2NF]
         ↓ 이행적 함수 종속 제거
       [3NF]
         ↓ 결정자이면서 후보키 아닌 것 제거
       [BCNF]
         ↓ 다치 종속 제거
       [4NF]
         ↓ 조인 종속성 이용
       [5NF]
   ```

   - 정규형별 상세
     1. 1NF (제1정규형)
        - **조건**: 모든 도메인이 **원자값(Atomic Value)**만 가짐

        ```
        ❌ 비정규형              ✅ 1NF
        이름  | 전화번호         이름  | 전화번호
        ------|----------        ------|----------
        철수  | 010-1234         철수  | 010-1234
              | 010-5678         철수  | 010-5678
        ```

     2. 2NF (제2정규형)
        - **조건**: 1NF + **부분적 함수 종속 제거** (완전 함수적 종속 만족)

        ```
        기본키: (학번, 과목명)

        ❌ 부분 종속 있음: 학년은 학번만으로 결정됨
          (학번, 과목명) → 학년  ← 부분 종속!

        ✅ 분리: 학년을 별도 테이블로
        ```

     3. 3NF (제3정규형)
        - **조건**: 2NF + **이행적 함수 종속 제거**

        ```
        이행적 종속: A → B → C (A가 C를 간접 결정)

        ❌ 학번 → 학과 → 학과장  (이행적 종속)
        ✅ 분리: 학과장을 별도 테이블로
        ```

     4. BCNF (보이스-코드 정규형)
        - **조건**: 3NF + **모든 결정자가 후보키**
        - 강한 3NF라고도 함
        - 후보키가 여러 개이고 중첩될 때 적용
     5. 4NF (제4정규형)
        - **조건**: BCNF + **다치 종속 제거**
     6. 5NF (제5정규형, PJ/NF)
        - **조건**: 4NF + **조인 종속이 후보키를 통해서만 성립**

---

### 9. 반정규화(Denormalization)

> 반정규화 = **성능 향상**을 위해 정규화 원칙을 **의도적으로 위배**하는 것

1. **반정규화란?**
   - 정규화된 데이터 모델을 **통합, 중복, 분리**하는 과정
   - **성능 향상** & 관리 효율성 증가가 목적
   - 단, 데이터 **일관성/정합성 저하** 가능

   ⚠️ **과도한 반정규화** → 오히려 성능 저하!

2. **정규화 vs 반정규화**

   | 구분   | 정규화               | 반정규화      |
   | ------ | -------------------- | ------------- |
   | 목적   | 이상 방지, 중복 제거 | **성능 향상** |
   | 테이블 | 분해 (↑)             | 통합/중복     |
   | 조인   | 많음                 | 적음          |
   | 무결성 | 높음                 | **저하 가능** |

3. **반정규화 방법 4가지**
   1. 테이블 통합
      - 사용 조건 : 조인이 **자주 발생**할 때 → 하나로 합침
      - 통합 종류
        - 1:1 관계 테이블 통합
        - 1:N 관계 테이블 통합
        - 슈퍼타입/서브타입 테이블 통합
      - 고려사항
        | 장점 | 단점 |
        | --------- | ------------------------ |
        | 검색 간편 | 레코드 증가 → 처리량 ↑ |
        | 조인 감소 | 입력/수정/삭제 규칙 복잡 |
        | | 제약조건 설계 어려움 |
   2. 테이블 분할
      - 수평 분할 (Horizontal)
        - **레코드(행)** 기준 분할
        - 사용 빈도 차이가 클 때
        ```
        [회원 테이블]              [활성 회원]     [휴면 회원]
        ID | 이름 | 상태    →     ID | 이름      ID | 이름
        ---|------|------        ---|-----      ---|-----
        1  | 철수 | 활성          1  | 철수       2  | 영희
        2  | 영희 | 휴면
        ```
      - 수직 분할 (Vertical)
        - **속성(열)** 기준 분할
        - 속성이 너무 많을 때
          | 분할 기준 | 설명 |
          | ------------------ | -------------------------- |
          | 갱신 위주 속성 | 갱신 자주 → 잠금 문제 해결 |
          | 자주 조회되는 속성 | 일부만 자주 사용 시 |
          | 크기 큰 속성 | 이미지, 대용량 텍스트 |
          | 보안 적용 속성 | 민감 정보 분리 |
        - 분할 시 고려사항
          - 기본키 유일성 관리 어려움
          - 수행 속도 느려질 수 있음
          - 데이터 양/빈도 낮으면 불필요
   3. 중복 테이블 추가
      - 사용 조건 : 여러 테이블에서 데이터 추출 or 다른 서버 테이블 이용 시
      - 추가하는 경우
        - 정규화로 수행 속도 느릴 때
        - 많은/특정 범위 데이터 자주 처리 시
        - 처리 범위 줄이지 않고 개선 불가 시
      - 추가 방법
        | 방법 | 설명 | 주의점 |
        | --------------- | --------------------------- | --------------- |
        | **집계 테이블** | 집계 데이터용 + 트리거 설정 | 트리거 오버헤드 |
        | **진행 테이블** | 이력 관리용 | 적절한 PK 설정 |
        | **부분 테이블** | 특정 부분만 새 테이블로 | - |

   4. 중복 속성 추가
      - 사용 조건 : 조인 경로 **단축**을 위해 자주 쓰는 속성 추가
      - 추가하는 경우
        - 조인이 자주 발생하는 속성
        - 접근 경로가 복잡한 속성
        - 액세스 조건으로 자주 사용
        - 기본키가 여러 속성으로 구성된 경우
      - 고려사항
        - 데이터 **일관성/무결성** 유의
        - 저장 공간 낭비 고려
        - SQL 그룹 함수로 처리 가능해야 함

---

### 10. 시스템 카탈로그

> 시스템 카탈로그 = DB의 **모든 객체 정보**를 담은 시스템 데이터베이스

1. **시스템 카탈로그란?**
   - 시스템 자체에 관한 다양한 **객체 정보**를 포함
   - 모든 데이터 객체의 **정의/명세** 정보를 유지 관리
   - **데이터 사전(Data Dictionary)**에 저장됨
   - 카탈로그 ≒ 데이터 사전 (좁은 의미)

   💡 쉽게 말해: **"DB의 설명서/목차"** 같은 것!

2. **저장 정보 = 메타 데이터(Meta-Data)**

| 유형                | 저장 내용                      |
| ------------------- | ------------------------------ |
| **객체 정보**       | 테이블, 인덱스, 뷰의 구조/통계 |
| **사용자 정보**     | ID, 패스워드, 접근 권한        |
| **무결성 제약조건** | 기본키, 외래키, NULL 허용 여부 |
| **프로그램 정보**   | 함수, 프로시저, 트리거         |

💡 **메타 데이터** = "데이터에 대한 데이터"

3. **카탈로그의 특징 (시험 필수!)**

| 특징               | 설명                                   |
| ------------------ | -------------------------------------- |
| **조회 가능**      | SQL로 SELECT 가능 ⭕                   |
| **직접 수정 불가** | INSERT/DELETE/UPDATE 불가 ❌           |
| **자동 갱신**      | DBMS가 **스스로** 생성/유지            |
| **갱신 시점**      | 테이블/뷰/인덱스 변경 시 **자동** 갱신 |

```
사용자 → SELECT로 조회 ⭕
사용자 → INSERT/UPDATE/DELETE ❌
DBMS → 자동으로 생성/갱신 ⭕
```

4. **관련 DBMS 모듈**

| 모듈                | 기능                                       |
| ------------------- | ------------------------------------------ |
| **DDL 번역기**      | DDL → 메타데이터로 변환 → 데이터 사전 저장 |
| **DML 번역기**      | DML → 프로시저 호출로 변환                 |
| **질의 최적화기**   | 효율적인 질의 처리 전략 수립               |
| **트랜잭션 처리기** | 동시 트랜잭션 문제 해결                    |

5. **카탈로그 vs 데이터 디렉터리**

| 구분     | 시스템 카탈로그 | 데이터 디렉터리 |
| -------- | --------------- | --------------- |
| 내용     | 객체 정의/명세  | 실제 접근 정보  |
| **접근** | 사용자 + 시스템 | **시스템만**    |

💡 **시험 포인트**:

- 카탈로그 → 사용자도 접근 가능 (조회만)
- 디렉터리 → 시스템**만** 접근 가능

6. **시스템 구조 (이미지 참고)**

```
        [사용자]
           │
    ┌──────┼──────┐
    ↓      ↓      ↓
 응용    질의   DDL
프로그램
    │      │      │
    ↓      ↓      ↓
 DML    질의    DDL
번역기  처리기  번역기
    │      │      │
    └──────┼──────┘
           ↓
    [데이터베이스 관리 프로그램]
           │
    ┌──────┼──────┐
    ↓             ↓
 [파일관리]  [시스템 카탈로그]
    ↓        = 데이터 사전
 [데이터/
  디스크]
```
