---
title: '[정보처리기사 자격증] 2.소프트웨어 개발 > 4장 애플리케이션 테스트 관리(WEEK 5)'
date: '2026-01-14'
tags: ['dev', 'license']
draft: false
summary: 정보처리기사 5주차 내용정리 - 애플리케이션 테스트 관리
# https://velog.io/@alpaka206/40.-소프트웨어-사용자-매뉴얼-작성
---

import ImageWithCaption from '@/components/mdxComponents/ImageWithCaption'

### 1. 애플리케이션 테스트

1.  **애플리케이션 테스트의 개요**

    > 애플리케이션 테스트란 소프트웨어에 잠재된 결함(Bug, Error)을 찾아내기 위한 체계적인 활동 및 절차
    - 테스트의 두 가지 핵심 목적
      - Validation(확인) : 이 소프트웨어가 사용자 요구사항을 만족하는가?
      - Verification(검증) : 요구된 기능을 정확히 구현했는가?
    - 테스트 전 선행 작업
      - 개발된 소프트웨어의 유형·특성 분석
      - 소프트웨어 유형에 따라 중점 테스트 항목 선정
      - 전략적 테스트 필요
    - 소프트웨어 유형별 특성
      - 소프트웨어는 제공 방식·기능·환경·개발 유형에 따라 테스트 관점이 달라짐
      - | 구분                               | 핵심 테스트 관점          |
        | ---------------------------------- | ------------------------- |
        | 서비스 제공 소프트웨어 (신규 개발) | 사용자 요구사항 누락 여부 |
        | 기존 시스템 연계                   | 데이터 손실·정합성        |
        | 상용 소프트웨어                    | 다양한 OS·환경 호환성     |
    - 소프트웨어의 분류
      1. 소프트웨어 개념
         - 소프트웨어(Software) → 하드웨어를 제어하고 사용자의 작업을 지원하는 프로그램 + 자료구조의 총칭
      2. 상용 소프트웨어
         - 불특정 다수를 대상으로 판매·배포되는 소프트웨어
         1. 산업 범용 소프트웨어
            1. 시스템 소프트웨어
               - 운영체제(OS)
               - 데이터 관리, 스토리지
               - 소프트웨어 공학 도구
               - 가상화, 보안 소프트웨어
            2. 미들웨어
               - OS와 응용 프로그램 사이에서 추가 서비스 제공
               - 분산 시스템, IT 자원 관리
               - 서비스 플랫폼, 네트워크 보안
            3. 응용 소프트웨어
               - 특정 업무 수행 목적
               - 영상 처리, VR/CG
               - 콘텐츠 배포, 자연어/음성 처리
               - 기업용 소프트웨어
         2. 산업 특화 소프트웨어
            - 특정 산업만을 위한 전용 소프트웨어
              - 자동차, 항공, 국방
              - 의료, 공공
              - 패션·의류, 농업 등
      3. 서비스 제공 소프트웨어
         - 판매 목적이 아닌 특정 사용자 요구 충족 목적으로 만들어진 소프트웨어
         1. 신규 개발 소프트웨어 : 완전히 새로운 서비스 제공
         2. 기능 개선 소프트웨어 : UI, 응답 속도, 업무 프로세스 개선
         3. 추가 개발 소프트웨어 : 법·제도 변경, 환경 변화 대응
         4. 시스템 통합 소프트웨어 : 여러 시스템을 One-Stop 서비스로 통합

2.  **애플리케이션 테스트의 필요성**
    - 사전 오류 발견
    - 제품 신뢰도 향상 : 반복 테스트 → 품질 안정성 증가
    - 초기 테스트의 중요성
    - 효율성 : 체계적인 테스트 → 최소 시간·노력으로 최대 결함 발견

3.  **애플리케이션 테스트의 기본 원리**
    - 사전 오류 발견
    - 제품 신뢰도 향상 : 반복 테스트 → 품질 안정성 증가
    - 초기 테스트의 중요성
    - 효율성 : 체계적인 테스트 → 최소 시간·노력으로 최대 결함 발견

4.  **애플리케이션 테스트의 기본 원리**
    1. 완벽한 테스트는 불가능하다
       - 테스트는 결함 존재만 증명 가능
       - 결함이 없음을 증명할 수는 없다
    2. 파레토 법칙 (80:20 법칙)
       - 전체 코드의 20%에서 전체 결함의 80% 발생
    3. 살충제 패러독스
       - 같은 테스트 케이스를 반복하면 더 이상 결함이 발견되지 않음
    4. 정황(Context) 의존성 원리
       - 테스트 결과는 다음에 따라 달라진다
         - 소프트웨어 특성
         - 테스트 환경
         - 테스터 역량
    5. 오류-부재의 궤변
       - 결함이 없어도 사용자 요구를 만족하지 못하면 품질이 높다고 할 수 없다
    6. 테스트와 위험의 관계
       - 테스트 수행량이 늘어나면 미래 위험은 감소한다.
       - 테스트는 리스크 감소 활동
    7. 점진적 테스트 원칙
       - 작은 단위 → 큰 단위
       - 모듈 → 시스템 → 통합
    8. 독립적 테스트 원칙
       - 개발자 본인이 아닌 독립된 조직에서 테스트 수행 시 효과 극대화

### 2. 애플리케이션 테스트의 분류

1.  **프로그램 실행 여부에 따른 테스트**
    1. 정적 테스트 (Static Testing)
       - 프로그램을 실행하지 않고 테스트
       - 대상
         - 요구사항 명세서
         - 설계서
         - 소스 코드
       - 목적
         - 개발 초기에 결함 발견
         - 수정 비용 최소화
       - 주요 특징
         - 실행 ❌
         - 초기 단계에 효과적
         - 논리적 오류, 문서 오류 발견에 강점
       - 워크스루 (Walkthrough) / 인스펙션 (Inspection) / 코드 검사 (Code Review) 등
    2. 동적 테스트 (Dynamic Testing)
       - 프로그램을 실제로 실행하여 오류 탐지
       - 소프트웨어 개발 전 단계에서 수행 가능
       - 주요 특징
         - 실행 가능
         - 실제 동작 오류 발견
         - 기능, 성능 검증에 필수

2.  **테스트 기반(Test Basis)에 따른 분류**
    - 무엇을 기반으로 테스트 케이스를 만들었는가?
    1. 명세 기반 테스트 (Specification-Based)
       - 사용자 요구사항 명세서를 기준으로 테스트
       - 요구사항이 빠짐없이 구현되었는가?
       - 특징
         - 내부 구조 몰라도 가능
         - 사용자 관점 테스트
         - 블랙박스 테스트 성격
       - 대표 기법
         - 동등 분할
         - 경계값 분석
    2. 구조 기반 테스트 (Structure-Based)
       - 소프트웨어 내부 논리 구조를 기준으로 테스트
       - 코드 흐름을 따라 테스트 케이스 설계
       - 특징
         - 내부 구조 이해 필요
         - 개발자 관점 테스트
         - 화이트박스 테스트 성격
       - 대표 기법
         - 구문 기반
         - 결정 기반
         - 조건 기반
    3. 경험 기반 테스트 (Experience-Based)
       - 테스터의 경험과 직관에 기반
       - 명세가 불완전하거나 시간이 부족할 때 효과적
       - 특징
         - 문서 의존도 낮음
         - 숙련도 중요
         - 예외 상황 발견에 강점
       - 대표 기법
         - 에러 추정
         - 체크리스트
         - 탐색적 테스팅
3.  **시각(View)에 따른 테스트**
    - 누구의 입장에서 테스트하는가?
    1. 검증 테스트 (Verification)
       - 개발자 관점
       - 개발 과정이 명세서대로 진행되었는지 확인
    2. 확인 테스트 (Validation)
       - 개발자 관점
       - 개발 과정이 명세서대로 진행되었는지 확인
4.  **목적에 따른 테스트**
    - 왜 테스트하는가?
    1. 회복 테스트 (Recovery) : 시스템 장애 발생 후 정상 상태로 복구되는지 확인
    2. 안전 테스트 (Security) : 불법 접근, 침입 시도에 대해 보안 기능이 제대로 동작하는지 확인
    3. 강도 테스트 (Stress) : 과도한 부하를 걸어 한계 상황에서도 정상 동작 여부 확인
    4. 성능 테스트 (Performance) : 응답 시간, 처리량, 자원 사용 효율 확인
    5. 구조 테스트 (Structure) : 내부 논리 경로 코드 복잡도 평가
    6. 회귀 테스트 (Regression) : 수정·변경 이후 기존 기능에 새로운 결함이 없는지 확인
    7. 병행 테스트 (Parallel) : 기존 시스템과 변경된 시스템에 동일한 입력 → 결과 비교

### 3. 테스트 기법에 따른 애플리케이션 테스트

1.  **화이트박스 테스트 (White Box Test)**
    - 내부 구조를 다 들여다보며 테스트하는 과정
    - 주요 특징
      - 소스 코드를 보며 수행하므로 테스트 초기 단계에 주로 수행
      - 설계된 절차와 제어 구조를 바탕으로 함
      - 모듈 안의 작동을 직접 확인
    - 화이트박스 테스트의 종류
      1. 기초 경로 검사(Base Path Testing)
         - 설계의 논리적 복잡도를 측정하여 실행 경로의 기초를 정의하는 가장 대표적인 기법
      2. 제어 구조 검사
         - 조건 검사: 논리적 조건(True/False)이 맞는지 확인
         - 루프 검사: 반복문(for, while 등)의 구조를 확인합니다.
         - 데이터 흐름 검사: 변수가 어디서 정의되고 어디서 쓰이는지 추적
    - 화이트박스 테스트의 검증 기준 (Coverage)
      - 문장(Statement): 모든 문장이 최소 한 번은 실행되게 함.
      - 분기(Branch): 모든 조건문의 결과가 True인 경우와 False인 경우를 모두 체크함.
      - 조건(Condition): 조건문 안의 개별 조건식들이 True/False가 되는 경우를 체크함.
      - 분기/조건: 위 두 가지를 모두 만족하게 설계함.

2.  **블랙박스 테스트 (Black Box Test)**
    - 속은 모르겠고, 결과만 잘 나오면 된다
    - 주요 특징
      - 기능이 완성된 후인 테스트 후반부에 주로 수행
      - 인터페이스, 데이터베이스 접근, 성능 오류 등을 발견하기 위해 수행
      - 요구사항 명세서를 바탕으로 테스트 케이스를 만듬
    - 블랙박스 테스트의 종류
      - 동치 분할 검사(Equivalence Partitioning): 입력값의 범위를 나누어 대표값 하나만 뽑아 테스트
      - 경계값 분석(Boundary Value Analysis): 오류는 주로 경계에서 발생한다는 점을 이용
      - 원인-효과 그래프: 입력 데이터 간의 관계를 분석하여 효용성 높은 케이스를 선정
      - 오류 예측(Error Guessing): 경험이 많은 테스터가 감각적으로 오류를 찾아내는 보충적 기법
      - 비교 검사: 여러 버전의 프로그램에 동일한 값을 넣어 결과가 같은지 비교

### 4. 개발 단계에 따른 애플리케이션 테스트

1.  **개발 단계에 따른 애플리케이션 테스트**
    - 애플리케이션 테스트는 소프트웨어의 개발 단계에 따라 단위 테스트, 통합 테스트, 시스템 테스트, 인수 테스트로 분류
    - 애플리케이션 테스트와 소프트웨어 개발 단계를 연결하여 표현한 것을 V-모델이라함
      - V-모델 (V-Model)
        - 요구사항 분석 ↔ 인수 테스트
        - 분석 ↔ 시스템 테스트
        - 설계 ↔ 통합 테스트
        - 구현(코딩) ↔ 단위 테스트
2.  **단위 테스트 (Unit Test)**
    - 부품 하나하나가 잘 만들어졌는지 체크
    - 소프트웨어 설계의 최소 단위인 모듈이나 컴포넌트를 대상으로 테스트 진행
    - 특징
      - 개발자가 코딩 직후에 바로 수행
      - 주로 내부 구조를 보는 화이트박스 테스트를 사용
      - 알고리즘 오류, 무한 루프, 계산 수식 오류등을 체크
3.  **통합 테스트 (Integration Test)**
    - 부품들을 조립했을 때 서로 잘 맞는지 체크
    - 단위 테스트를 마친 모듈들을 결합하여, 모듈 간의 인터페이스(상호 작용) 오류를 확인
    - 특징
      - 모듈이 서로 연결되었을 때 데이터가 잘 오가는지, 충돌은 없는지 확인
4.  **시스템 테스트 (System Test)**
    - 전체 시스템이 실제 환경에서 잘 돌아가는지 체크
    - 통합된 전체 시스템이 정상적으로 작동하는지 확인
    - 특징
      - 기능적 요구사항: 사용자 요구대로 기능이 작동하는지 체크 > 블랙박스 테스트
      - 비기능적 요구사항: 성능, 보안, 회복력 등이 충분한지 체크 > 화이트박스 테스트
      - 실제 사용 환경과 유사한 환경에서 테스트해야 리스크를 줄일 수 있음
5.  **인수 테스트 (Acceptance Test)**
    - 사용자의 요구사항에 충분한지, 완제품을 제공할 수 있는 수준인지 체크
    - 개발이 완료된 제품을 사용자가 직접 테스트하여 요구사항이 충족되었는지 확인하고 인수를 결정
    - 인수 테스트의 6가지 종류
      - 사용자 인수: 사용자가 시스템 사용의 적절성 확인.
      - 운영상의 인수: 관리자가 백업, 복구, 점검 등 운영 측면 확인.
      - 계약 인수: 계약서의 조건대로 만들어졌는지 확인.
      - 계약 인수: 계약서의 조건대로 만들어졌는지 확인.
      - 규정 인수: 법규나 지침에 맞는지 확인.
      - 알파 테스트 (Alpha Test): 개발자 장소에서 사용자가 개발자 앞에서 하는 테스트. > 통제환경
      - 베타 테스트 (Beta Test): **실제 환경(필드)**에서 최종 사용자가 수행하는 테스트. > 필드테스트

### 5. 통합 테스트

1.  **통합 테스트(Integration Test)**
    - 통합 테스트는 단위 테스트가 끝난 모듈을 통합하는 과정에서 발생하는 오류 및 결함을 찾는 테스트 기법
      - 방식
        1. 비점진적 통합 (Big Bang)
           - 모든 모듈을 한꺼번에 합쳐서 테스트
           - 단시간에 가능하지만, 에러가 나면 어디가 고장 났는지 찾기 매우 어려움
        2. 점진적 통합
           - 모듈을 하나씩 단계적으로 합칩니다. (하향식, 상향식, 샌드위치)
           - 오류 수정이 쉽고 훨씬 꼼꼼하게 테스트할 수 있음
2.  ** 하향식 vs 상향식**
    1. 하향식 통합 테스트 (Top-Down)
       - 위(제어 모듈)에서 아래(종속 모듈)로 내려오며 테스트
       - 핵심 도구: 스텁(Stub)
         - 아직 개발 안 된 하위 모듈을 대신해 주는 '가짜 모듈'
       - 방법: 깊이 우선(Depth-first) 또는 넓이 우선(Breadth-first) 방식으로 통합
       - 장점: 시스템 전체의 구조를 초기에 파악하기 좋음
    2. 상향식 통합 테스트 (Bottom-Up)
       - 아래(기능 모듈)에서 위(제어 모듈)로 올라가며 테스트
       - 핵심 도구: 드라이버(Driver)
         - 하위 모듈은 있는데 상위(제어) 모듈이 없을 때, 데이터를 주고받게 해주는 '테스트 구동기'
       - 방법: 하위 모듈들을 **클러스터(Cluster)**로 묶어서 테스트
       - 장점: 하위 수준의 기능들을 먼저 확실하게 검증
3.  **혼합식 통합 테스트**
    - 혼합식 통합 테스트는 하위 수준에서는 상향식 통합, 상위 수준에서는 하향식 통합을 사용하여 최적의 테스트를 지원하는 방식으로, 샌드위치(Sandwich)식 통합 테스트 방법이라고도 함
4.  **회귀 테스트 (Regression Test)**
    - 통합 테스트를 하기위해 수정한 코드로 인해 발생 가능한 버그를 다시 확인하는 것이 회귀 테스트
    - 목적: 변경된 코드의 부작용(Side Effect) 확인.
    - 방법: 기존 테스트 케이스 중 중요한 것을 골라 다시 수행.

### 6. 통합 테스트

1.  **테스트 케이스 (Test Case)**
    - 무엇을 테스트할 것인가?
    - 사용자의 요구사항을 잘 지켰는지 확인하기 위해 만든 입력 값, 실행 조건, 예상 결과의 집합
      - 핵심 요소: 입력 값 + 실행 조건 + 예상 결과
      - 작성 시기: 시스템 설계 단계에 작성하는 것이 가장 효율적
      - 장점: 테스트 누락 방지, 인력 및 시간 낭비 감소.
      - 작성 순서: 1. 계획 검토 및 자료 확보 → 2. 위험 평가(우선순위) → 3. 요구사항 정의 → 4. 구조 설계 → 5. 케이스 정의 → 6. 타당성 확인

2.  **테스트 시나리오 (Test Scenario)**
    - 어떤 순서로 테스트할 것인가?
    - 여러 개의 테스트 케이스를 동작 순서에 따라 묶은 것. 사용자가 실제로 소프트웨어를 사용하는 '흐름'을 테스트
      - 특징: 테스트 케이스의 집합이며, 구체적인 절차를 담고 있습니다.
      - 주의사항: 모듈별, 항목별로 분리해서 작성해야 관리가 쉽습니다.
        - 유스케이스(Use Case) 간의 업무 흐름이 정상적인지 확인해야 합니다.
        - 예상 결과가 명확히 포함되어야 합니다.

3.  **테스트 오라클 (Test Oracle)**
    - 이 결과가 정답인가?
    - 테스트를 수행한 결과가 나온 뒤, 이 결과가 맞는지 틀린지 판단하기 위해 미리 정의된 참(True)값과 비교하는 기법
      - 특징
        - 제한된 검증: 모든 케이스에 오라클을 적용하기는 어려움(시간/비용 문제)
        - 수학적 기법: 수학적 원리를 이용해 결과값을 구할 수 있다.
        - 자동화 가능: 도구를 통해 자동으로 비교할 수 있다.
      - 테스트 오라클 종류
        - | 종류               | 핵심 특징                                      | 활용 분야                           |
          | ------------------ | ---------------------------------------------- | ----------------------------------- |
          | 참(True) 오라클    | 모든 입력 값에 대해 정답을 제공함.             | 항공기, 은행 등 사고 시 위험한 분야 |
          | 샘플링(Sampling)   | 특정한 몇몇 입력 값에 대해서만 정답 제공.      | 일반적인 업무, 게임 등              |
          | 추정(Heuristic)    | 샘플링 + 나머지는 **추정(Guessing)**으로 처리. | 샘플링 오라클의 보완 기법           |
          | 일관성(Consistent) | 수정 전후의 결과값이 같은지 확인.              | 애플리케이션 변경(회귀 테스트) 시   |

### 7. 테스트 자동화 도구

1.  **테스트 자동화개요**
    - 사람이 할 일을 도구(스크립트)가 대신하게 만드는 것
    - 반복적인 테스트 업무를 자동으로 수행하는 도구를 사용하는 것. 로봇 청소기처럼 한 번 설정해두면 정해진 규칙에 따라 효율적으로 테스트를 수행.
      - 장점: 인력·시간 절약, 휴먼 에러(Human Error) 감소, 객관적인 평가 가능.
      - 단점: 도구 사용법 학습 필요, 초기 설정 비용(시간/돈)이 많이 듦, 상용 도구는 비쌈.

2.  **테스트 자동화 도구의 유형**
    1. 정적 분석 도구 (Static Analysis)
       - 프로그램을 실행하지 않고 소스 코드만 분석
       - 코딩 표준 준수 여부, 코드 복잡도, 결함 등을 찾아냄.
    2. 테스트 실행 도구 (Execution)
       - 스크립트를 이용해 테스트를 실제로 수행.
       - 데이터 주도 접근: 데이터를 시트(Excel 등)에 따로 저장하고 읽어서 실행.
       - 키워드 주도 접근: 수행할 동작(클릭, 입력 등)을 키워드로 정의하여 실행.
    3. 성능 테스트 도구 (Performance)
       - 가상의 사용자를 만들어 시스템에 부하를 주고 응답 시간, 자원 사용률 등을 체크.
    4. 테스트 통제 도구 (Control)
       - 테스트 계획, 형상 관리, 결함 추적 등 전반적인 관리

3.  **테스트 하네스 (Test Harness)**
    - 테스트를 실행하기 위해 만든 가상의 환경(코드와 데이터)
    - 단위 테스트나 통합 테스트를 할 때, 테스트 대상 모듈이 정상적으로 돌아가도록 도와주는 도구들의 집합
    - 구성 요소
      - 테스트 드라이버 (Driver): 상위 모듈 역할을 하는 가짜 모듈
      - 테스트 스텁 (Stub): 하위 모듈 역할을 하는 가짜 모듈
      - 테스트 슈트 (Test Suite): 테스트 케이스들의 묶음
      - 테스트 케이스 (Test Case): 입력값, 조건, 예상 결과가 담긴 테스트 항목
      - 테스트 스크립트 (Test Script): 자동화된 테스트 실행 순서를 적은 명세서
      - 목 오브젝트 (Mock Object): 사용자의 행위를 미리 입력해둔 가짜 객체

4.  **테스트 자동화 수행 시 고려사항**
    - 모든 과정을 자동화할 수는 없으므로 적절한 도구를 선택
    - 프로젝트 초기에 테스트 엔지니어를 투입하여 계획을 세워야 함
    - 재사용이 불가능한 테스트는 자동화 대상에서 제외하는 것이 경제적

5.  **테스트 수행 단계별 테스트 자동화 도구**
    - 테스트 자동화 도구는 소프트웨어 생명 주기(SDLC)에 맞춰 적재적소에 배치
      | 테스트 단계 | 자동화 도구 | 주요 설명 |
      |--------------|------------|-------------------------------------------|
      | 1. 테스트 계획 | 요구사항 관리 | 사용자의 요구사항 정의 및 변경 사항 등을 관리하는 도구 |
      | 2. 테스트 분석/설계 | 테스트 케이스 생성 | 테스트 기법에 따라 테스트 데이터 및 테스트 케이스 작성을 지원하는 도구 |
      | 3. 테스트 수행 | 테스트 자동화 | 테스트의 자동화를 도와주어 테스트의 효율성을 높임 |
      | | 정적 분석 | 프로그램을 실행하지 않고 코딩 표준, 런타임 오류 등을 검증하는 도구 |
      | | 동적 분석 | 대상 시스템의 시뮬레이션을 통해 오류를 검출하는 도구 |
      | | 성능 테스트 | 가상의 사용자를 생성하여 시스템의 처리 능력(부하 등)을 측정하는 도구 |
      | | 모니터링 | CPU, Memory 등 시스템 자원의 상태 확인 및 분석을 지원하는 도구 |
      | 4. 테스트 관리 | 커버리지 분석 | 테스트 완료 후 테스트의 충분성 여부(얼마나 꼼꼼히 했는지)를 검증함 |
      | | 형상 관리 | 테스트 수행에 필요한 다양한 도구 및 데이터의 버전을 관리함 |
      | | 결함 추적/관리 | 테스트 시 발생한 결함의 생성부터 소멸까지의 과정을 지원함 |

### 8. 결함 관리

1.  **결함(Defect/Fault)의 정의**
    - 결함은 소프트웨어가 개발자의 설계와 다르게 동작하거나, 사용자가 예상한 결과와 실행 결과가 일치하지 않아 변경이 필요한 모든 상태

2.  **결함 관리 프로세스 및 측정 지표**
    - 결함은 단순히 고치는 것에 그치지 않고, 계획부터 분석까지 체계적인 과정을 거침
    - 결함 관리 프로세스 순서
      - 1. 계획 → 2. 기록 → 3. 검토 → 4. 수정 → 5. 재확인 → 6. 상태 추적 및 모니터링 → 7. 분석 및 보고서 작성
    - 결함 관리 측정 지표
      - 결함 분포: 특정 모듈이나 속성에 결함이 얼마나 몰려있는지 측정.
      - 결함 추세: 시간에 따른 결함 수의 변화를 분석.
      - 결함 에이징(Aging): 결함이 해결되지 않고 특정 상태로 얼마나 오래 머무는지 측정.

3.  **결함 상태 추적 순서 (Defect Life Cycle)**
    - 결함 추적은 결함이 발견된 때부터 결함이 해결될 때까지 전 과정을 추적하는 것으로 순서는 다음과 같다.
      1. 결함 등록(Open): 테스터가 결함을 발견하여 보고한 상태.
      2. 결함 검토(Reviewed): 등록된 결함을 담당자가 확인한 상태.
      3. 결함 할당(Assigned): 수정을 위해 개발자에게 전달된 상태.
      4. 결함 수정(Resolved): 개발자가 수정을 완료한 상태.
      5. 결함 종료(Closed): 테스터가 수정 확인 후 종료를 승인한 상태.
      6. 결함 조치 보류(Deterred): 우선순위 등에 밀려 수정을 연기한 상태.
      7. 결함 해제(Clarified): 검토 결과 결함이 아니라고 판명된 상태.

4.  **결함 심각도 vs 우선순위**
    | 구분 | 결함 심각도 (Severity) | 결함 우선순위 (Priority) |
    |----|----------------------|---------------------------|
    | 개념 | 결함이 시스템에 미치는 영향의 치명도 | 결함을 얼마나 빨리 처리해야 하는지의 척도 |
    | 분류 | High, Medium, Low | 결정적(Critical), 높음, 보통, 낮음 |
    | 특징 | 기술적 관점에서 판단함 | 비즈니스/일정 관점에서 판단함 |

5.  **결함 분류 및 관리 도구**
    - 결함 분류
      - 시스템 결함: 서버 다운, 데이터베이스 에러 등 환경적 요인.
      - 기능 결함: 요구사항 불일치, 비즈니스 로직 오류 등.
      - GUI 결함: 화면 설계 오류, 메시지 표시 오류 등.
      - 문서 결함: 요구사항 명세서와 실제 기능의 불일치 등.
    - 결함 관리 도구
      - Mantis: 단위별 작업 기록 및 결함 추적 가능.
      - Trac: 결함 통합 관리 도구.
      - Redmine: 프로젝트 관리와 결함 추적 병행.
      - Bugzilla: 결함의 심각도와 우선순위 지정 및 지속적 관리.

### 9. 복잡도

1.  **복잡도(Complexity)의 개요**
    - 복잡도는 시스템이나 소프트웨어가 얼마나 복잡한지 나타내는 지표
      - 용도: 테스트 수준 결정, 개발 소요 자원 예측, 장애 발생 가능성 파악 등에 사용
      - 주요 측정 방법: 코드 라인 수를 측정하는 LOC(Line Of Code)와 제어 흐름을 분석하는 순환 복잡도(Cyclomatic Complexity)가 있음

2.  **시간 복잡도와 점근 표기법**
    - 알고리즘이 문제를 해결하기 위해 수행하는 연산 횟수를 수치화한 것. 실제 시간이 아닌 명령어 실행 횟수를 표기하기 위해 점근 표기법을 사용
    - 점근 표기법의 종류
      | 종류 | 표기법 | 설명 |
      |------------|----------|------------------------------------|
      | 빅오(Big-O) | $O$ | 최악의 경우를 표기. 성능 예측에 용이하여 가장 많이 사용됨. |
      | 세타(Big-θ) | $\theta$ | 평균적인 경우를 표기. 평가하기 까다로움. |
      | 오메가(Big-Ω) | $\Omega$ | 최상의 경우를 표기. 신뢰성이 떨어짐. |
    - 주요 빅오 표기법 예시 (효율적인 순서)
      1. O(1): 입력값에 관계없이 일정함 (예: 스택의 Push, Pop).
      2. O(log2n): 단계가 입력값에 의해 감소함 (예: 이진 트리 검색).
      3. O(n): 입력값에 비례함 (예: 일반적인 for문).
      4. O(nlog2n): 힙 정렬, 2-Way 합병 정렬.
      5. O(n2): 입력값의 제곱만큼 수행 (예: 버블, 선택, 삽입 정렬).
      6. O(2n): 2의 입력값 제곱만큼 수행 (예: 피보나치 수열).

3.  **순환 복잡도 (Cyclomatic Complexity)**
    - 맥케이브(McCabe)가 제안한 것으로, 프로그램의 논리적인 복잡도를 제어 흐름도 이론을 바탕으로 측정
    - 특징: 프로그램의 독립적인 경로 수를 정의하며, 테스트 횟수의 상한선을 제공
    - 계산 방법
      - 방법 1: 제어 흐름도의 영역(Region) 수를 계산합니다.
      - 방법 2: V(G)=E−N+2 (E: 화살표 수, N: 노드 수).

### 10. 애플리케이션 성능 개선

1.  **소스 코드 최적화**
    - 소스 코드 최적화는 나쁜 코드(Bad Code)를 배제하고, 클린 코드(Clean Code)로 작성하는 것
    1. 클린 코드(Clean Code) vs 나쁜 코드(Bad Code)
       - 클린 코드(Clean Code): 누구나 쉽게 이해하고 수정 및 추가할 수 있는 단순 명료하고 잘 작성된 코드.
       - 나쁜 코드(Bad Code): 로직이 복잡하고 이해하기 어려운 코드로, 대표적으로 다음과 같은 코드가 있음.
         - 스파게티 코드(Spaghetti Code): 코드의 로직이 서로 복잡하게 얽혀 있는 코드.
         - 외계인 코드(Alien Code): 아주 오래되었거나 개발자가 없어 유지보수가 어려운 코드.

2.  **클린 코드 작성 5대 원칙**
    1. 가독성: 누구든지 코드를 쉽게 읽을 수 있도록 이해하기 쉬운 용어를 사용하고 들여쓰기를 적용
    2. 단순성: 한 번에 한 가지를 처리하도록 코드를 간단하게 작성하고, 최소 단위로 분리
    3. 의존성 배제: 코드 변경 시 다른 모듈에 미치는 영향을 최소화하여 작성
    4. 중복성 최소화: 중복된 코드를 삭제하고 공통 코드를 사용
    5. 추상화: 상위 클래스/메소드에서는 간략하게 특성을 나타내고, 상세 내용은 하위에서 구현

3.  **소스 코드 품질 분석 도구**
    - 작성된 코드의 스타일, 복잡도, 결함 등을 발견하기 위해 사용하며, 실행 여부에 따라 크게 두 가지로 나뉨.
    - 정적 분석 도구 vs 동적 분석 도구
      | 구분 | 정적 분석 도구 (Static) | 동적 분석 도구 (Dynamic) |
      |-------|------------------------------------------------------|---------------------|
      | 특징 | 프로그램을 실행하지 않고 분석 | 프로그램을 실행하여 분석 |
      | 분석 내용 | 코딩 표준, 스타일, 복잡도, 결함 등 | 메모리 누수, 스레드 결함 등 |
      | 주요 도구 | pmd, cppcheck, SonarQube, checkstyle, ccm, cobertura | Avalanche, Valgrind |
    - 주요 분석 도구 상세
      | 도구 이름 | 설명 |
      |-----------------|-----------------------------------|
      | pmd | 미사용 변수, 최적화되지 않은 코드 등 결함 유발 코드 검사 |
      | cppcheck | C/C++ 코드의 메모리 누수, 오버플로우 분석 |
      | SonarQube | 중복 코드, 복잡도 등을 분석하는 소스 분석 통합 플랫폼 |
      | checkstyle | 자바(Java) 코드의 소스 코드 표준 준수 여부 검사 |
      | ccm / cobertura | 코드 복잡도 분석 및 테스트 커버리지 측정 |
      | Valgrind | 프로그램 내 메모리 및 스레드 결함 분석 (동적 분석) |
