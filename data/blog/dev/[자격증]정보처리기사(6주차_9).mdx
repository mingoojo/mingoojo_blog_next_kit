---
title: '[정보처리기사 자격증] 4.프로그래밍 언어 활용 > 3장 응용 SW 기초 기술 활용_1 (WEEK 6)'
date: '2026-01-22'
tags: ['dev', 'license']
draft: false
summary: 정보처리기사 6주차 내용정리 - 응용 SW 기초 기술 활용_1
# https://velog.io/@alpaka206/111.-운영체제의-개념
---

import ImageWithCaption from '@/components/mdxComponents/ImageWithCaption'

### 1. 운영체제의 개념

1. **운영체제(OS)란?**

   > **한 줄 정의:** 컴퓨터 **자원을 효율적으로 관리**하며, 사용자가 컴퓨터를 **편리하게 사용**할 수 있도록 환경을 제공하는 **시스템 소프트웨어**

2. **운영체제의 역할**

   | 역할           | 설명                                       |
   | -------------- | ------------------------------------------ |
   | **자원 관리**  | 컴퓨터 시스템 자원 효율적 관리             |
   | **인터페이스** | 사용자와 하드웨어 간 **인터페이스** 제공   |
   | **환경 제공**  | 응용 프로그램이 작업할 수 있도록 환경 제공 |

3. **운영체제의 목적**
   - 운영체제의 **성능 평가 기준**이기도 함

     | 목적                             | 한 줄 정의                          |
     | -------------------------------- | ----------------------------------- |
     | **처리 능력** (Throughput)       | 일정 시간 내 처리하는 **일의 양**   |
     | **반환 시간** (Turn Around Time) | 작업 의뢰~완료까지 **걸린 시간**    |
     | **사용 가능도** (Availability)   | 필요할 때 **즉시 사용** 가능한 정도 |
     | **신뢰도** (Reliability)         | 문제를 **정확하게 해결**하는 정도   |

   - 목표 방향

     |    목적     |    방향    |
     | :---------: | :--------: |
     |  처리 능력  | **향상** ↑ |
     |  반환 시간  | **단축** ↓ |
     | 사용 가능도 | **향상** ↑ |
     |   신뢰도    | **향상** ↑ |

4. **운영체제의 구성**

   ```
   운영체제
   ├── 제어 프로그램 (Control Program)
   │   ├── 감시 프로그램
   │   ├── 작업 관리 프로그램
   │   └── 데이터 관리 프로그램
   │
   └── 처리 프로그램 (Processing Program)
      ├── 언어 번역 프로그램
      └── 서비스 프로그램
   ```

5. **제어 프로그램 (Control Program)**
   - 컴퓨터 전체의 **작동 상태 감시**, 작업 순서 지정, 데이터 관리

     | 프로그램                                   | 한 줄 정의                                |
     | ------------------------------------------ | ----------------------------------------- |
     | **감시 프로그램** (Supervisor)             | **가장 핵심!** 자원 할당, 시스템 **감시** |
     | **작업 관리 프로그램** (Job Management)    | 작업의 **순서와 방법** 관리               |
     | **데이터 관리 프로그램** (Data Management) | **데이터와 파일** 처리 및 전송 관리       |

   - 제어 프로그램 핵심
     - **감시 프로그램** = 제어 프로그램 중 **가장 핵심!**

6. **처리 프로그램 (Processing Program)**
   - 제어 프로그램의 지시를 받아 **사용자 요구 문제 해결**

     | 프로그램               | 한 줄 정의                           | 예시                           |
     | ---------------------- | ------------------------------------ | ------------------------------ |
     | **언어 번역 프로그램** | 원시→목적 프로그램 **변환**          | 컴파일러, 어셈블러, 인터프리터 |
     | **서비스 프로그램**    | 사용자의 **효율적** 컴퓨터 사용 지원 | Sort/Merge, 유틸리티           |

7. **운영체제의 기능**

   | 기능                  | 설명                                      |
   | --------------------- | ----------------------------------------- |
   | **자원 관리**         | 프로세서, 기억장치, 입출력장치, 파일 관리 |
   | **스케줄링**          | 자원의 효율적 관리를 위한 스케줄링        |
   | **인터페이스**        | 사용자와 시스템 간 편리한 인터페이스      |
   | **하드웨어/네트워크** | 하드웨어와 네트워크 관리·제어             |
   | **데이터 관리**       | 데이터 관리, 자원 공유 기능               |
   | **오류 처리**         | 시스템 오류 검사 및 복구                  |
   | **자원 보호**         | 자원 보호 기능                            |
   | **입출력 보조**       | 입출력에 대한 보조 기능                   |
   | **가상 계산기**       | 가상 계산기 기능                          |

8. **제어 프로그램 vs 처리 프로그램**

   | 구분 |       제어 프로그램        |    처리 프로그램     |
   | :--: | :------------------------: | :------------------: |
   | 역할 |      **시스템 관리**       | **사용자 요구 처리** |
   | 핵심 |       감시 프로그램        |  언어 번역 프로그램  |
   | 예시 | 감시, 작업관리, 데이터관리 |  컴파일러, 유틸리티  |

---

### 2. Windows

1. **Windows란?**

   > **한 줄 정의:** **마이크로소프트**가 1990년대 개발한 **GUI 기반** 운영체제

2. **Windows 버전**
   - 95 → 98 → me → XP → Vista → 7 → 8 → 10 → 11

3. **Windows 주요 특징**

   | 특징                  | 한 줄 정의                            |
   | --------------------- | ------------------------------------- |
   | **GUI**               | 마우스로 아이콘/메뉴 선택하여 작업    |
   | **선점형 멀티태스킹** | OS가 CPU 시간 제어, 문제 시 강제 종료 |
   | **PnP**               | 하드웨어 **자동 감지** 및 환경 구성   |
   | **OLE**               | 다른 프로그램 **개체 연결/삽입**      |
   | **긴 파일명**         | **255자**까지 파일명 지정 (VFAT)      |
   | **Single-User**       | 한 대를 **한 사람**만 사용            |

4. **GUI (Graphic User Interface)**
   - 키보드 명령어 대신 **마우스**로 **아이콘/메뉴 선택**하여 작업하는 방식
   - 특징
     - 초보자도 **쉽게 사용** 가능
     - 직관적인 인터페이스
   - GUI vs CLI

     |  구분  |       GUI       |        CLI        |
     | :----: | :-------------: | :---------------: |
     |  방식  | **마우스** 클릭 | **키보드** 명령어 |
     | 난이도 |    **쉬움**     |      어려움       |
     |  예시  |     Windows     | DOS, Linux 터미널 |

5. **선점형 멀티태스킹 (Preemptive Multi-Tasking)**
   - **OS가 CPU 시간을 제어**하여 문제 발생 시 **강제 종료**하고 자원 반환하는 방식
   - 특징

     | 특징          | 설명                                 |
     | ------------- | ------------------------------------ |
     | **CPU 제어**  | 운영체제가 CPU 이용 시간 제어        |
     | **강제 종료** | 문제 발생 시 해당 프로그램 강제 종료 |
     | **자원 반환** | 종료 후 모든 시스템 자원 반환        |
     | **독점 방지** | 하나의 프로그램이 CPU **독점 방지**  |
     | **안정성**    | 시스템 다운 없이 **안정적** 작업     |

   - 선점형 vs 비선점형

     |   구분    |    선점형     |    비선점형     |
     | :-------: | :-----------: | :-------------: |
     | CPU 제어  | **OS**가 제어 | 프로그램이 제어 |
     | 강제 종료 |   **가능**    |     불가능      |
     |  안정성   |   **높음**    |      낮음       |

6. **PnP (Plug and Play)**
   - 하드웨어 설치 시 **시스템 환경을 자동으로 구성**해주는 기능
   - 특징

     | 특징          | 설명                      |
     | ------------- | ------------------------- |
     | **자동 감지** | 하드웨어 규격 자동 인식   |
     | **자동 구성** | 시스템 환경 자동 설정     |
     | **편리함**    | 사용자가 직접 설정 불필요 |

   - PnP 사용 조건
     - **하드웨어 + 소프트웨어** 모두 PnP 지원 필요!

7. **OLE (Object Linking and Embedding)**
   - 다른 프로그램의 개체를 연결(Linking)하거나 삽입(Embedding)하여 편집하는 기능
   - OLE 구성

     |         구분         | 한 줄 정의                          |
     | :------------------: | ----------------------------------- |
     |  **Linking (연결)**  | 원본과 **연결** (원본 수정 시 반영) |
     | **Embedding (삽입)** | 문서에 **삽입** (독립적)            |

   - 특징
     - 다른 프로그램의 문자, 그림 등 **개체** 활용
     - 원본 수정 시 **연결된 문서에 자동 반영**

8. **255자 긴 파일명**
   - **VFAT** 이용하여 최대 **255자**까지 파일명 지정 가능
   - 파일명 규칙

     | 항목               | 내용                              |
     | ------------------ | --------------------------------- |
     | 최대 길이          | **255자** (한글 127자)            |
     | **사용 불가 문자** | \ / : \* ? " < > \|               |
     | 사용 가능          | 위 문자 제외 모든 문자 + **공백** |

   - 사용 불가 문자 암기
     - **\ / : \* ? " < > |** (9개)

9. **Single-User 시스템**
   - 컴퓨터 한 대를 **한 사람만** 독점 사용

10. **Windows 특징 요약**

    | 특징                  | 핵심 키워드                |
    | --------------------- | -------------------------- |
    | **GUI**               | 마우스, 아이콘             |
    | **선점형 멀티태스킹** | OS 제어, 강제 종료, 안정성 |
    | **PnP**               | 자동 감지, 자동 구성       |
    | **OLE**               | 개체 연결/삽입             |
    | **VFAT**              | 255자 파일명               |
    | **Single-User**       | 한 사람 사용               |

---

### 3. UNIX / LINUX / MacOS

1. **UNIX란?**

   > **한 줄 정의:** AT&T 벨 연구소에서 개발한 **시분할 시스템** 기반의 **개방형** 운영체제

2. **UNIX 개요**

   | 항목   | 내용                                               |
   | ------ | -------------------------------------------------- |
   | 개발   | 1960년대 **AT&T 벨 연구소**, MIT, General Electric |
   | 언어   | 대부분 **C 언어**로 작성                           |
   | 시스템 | **시분할 시스템** (Time Sharing System)            |
   | 소스   | **개방형 시스템** (Open System)                    |

3. **UNIX 특징**

   | 특징              | 설명                              |
   | ----------------- | --------------------------------- |
   | **시분할 시스템** | 대화식 운영체제                   |
   | **개방형 시스템** | 소스 공개                         |
   | **C 언어**        | 대부분 C로 작성 → **이식성 높음** |
   | **Multi-User**    | **다중 사용자** 지원              |
   | **Multi-Tasking** | **다중 작업** 지원                |
   | **트리 구조**     | **트리 구조** 파일 시스템         |
   | **네트워킹**      | 통신망 관리용으로 적합            |

4. **다중 사용자 vs 다중 작업**

   |       구분        | 한 줄 정의                           |
   | :---------------: | ------------------------------------ |
   |  **Multi-User**   | **여러 사용자**가 동시에 시스템 사용 |
   | **Multi-Tasking** | **여러 작업**을 동시에 수행          |

5. **UNIX 시스템 구성**

   ```
   ┌─────────────────────────────────┐
   │       사용자 (User)              │
   ├─────────────────────────────────┤
   │    Utility Program (유틸리티)    │  ← 응용 프로그램 처리
   ├─────────────────────────────────┤
   │         Shell (쉘)              │  ← 명령어 해석기
   ├─────────────────────────────────┤
   │        Kernel (커널)            │  ← 핵심! 하드웨어 관리
   ├─────────────────────────────────┤
   │       Hardware (하드웨어)        │
   └─────────────────────────────────┘
   ```

6. **커널 (Kernel)**
   - UNIX의 **가장 핵심** 부분, **주기억장치에 상주**하며 하드웨어와 프로그램 간 **인터페이스**
   - 커널 특징

     | 특징              | 설명                                  |
     | ----------------- | ------------------------------------- |
     | **핵심**          | UNIX의 가장 핵심적인 부분             |
     | **상주**          | 부팅 시 **주기억장치에 적재** 후 상주 |
     | **인터페이스**    | 프로그램과 **하드웨어** 간 인터페이스 |
     | **하드웨어 보호** | 하드웨어 보호                         |

   - 커널 기능

     | 기능                             |
     | -------------------------------- |
     | **프로세스** (CPU 스케줄링) 관리 |
     | **기억장치** 관리                |
     | **파일** 관리                    |
     | **입·출력** 관리                 |
     | 프로세스 간 **통신**             |
     | 데이터 전송 및 변환              |

7. **쉘 (Shell)**
   - 사용자의 **명령어를 해석**하여 프로그램을 호출하는 **명령어 해석기**
   - 쉘 특징

     | 특징              | 설명                               |
     | ----------------- | ---------------------------------- |
     | **명령어 해석기** | 사용자 명령어 인식 → 프로그램 호출 |
     | **인터페이스**    | 시스템과 **사용자** 간 인터페이스  |
     | **상주 안 함**    | 주기억장치에 **상주하지 않음**     |
     | **교체 가능**     | 보조기억장치에서 **교체** 가능     |
     | **파이프라인**    | 파이프라인 기능 지원               |
     | **입출력 재지정** | 입출력 방향 변경 가능              |

   - 쉘 종류

     | 쉘 종류          |
     | ---------------- |
     | **B**ourne Shell |
     | **C** Shell      |
     | **K**orn Shell   |

   - DOS 비교
     - Shell = DOS의 **COMMAND.COM**

8. **유틸리티 프로그램 (Utility Program)**
   - 응용 프로그램을 처리하는 데 사용 (DOS의 **외부 명령어**)
   - 유틸리티 종류
     - 에디터
     - 컴파일러
     - 인터프리터
     - 디버거

9. **커널 vs 쉘 비교**

   |    구분    |      커널 (Kernel)       |      쉘 (Shell)       |
   | :--------: | :----------------------: | :-------------------: |
   |    역할    |    **하드웨어** 관리     |    **명령어** 해석    |
   | 인터페이스 | 프로그램 ↔ **하드웨어** | 사용자 ↔ **시스템**  |
   |   메모리   |   주기억장치 **상주**    | 주기억장치 **비상주** |
   |   핵심도   |      **가장 핵심**       |           -           |

10. **프로세스 간 통신 (IPC)**
    | 방식 | 한 줄 정의 | 방향 |
    | :-----------------: | ------------------------------------- | :--------: |
    | **시그널** (Signal) | 간단한 **메시지** 통신 (초기 UNIX) | - |
    | **파이프** (Pipe) | 한 프로세스 출력 → 다른 프로세스 입력 | **단방향** |
    | **소켓** (Socket) | 프로세스 간 **대화** 가능 | **쌍방향** |

11. **LINUX**
    - **리누스 토발즈**가 1991년 **UNIX 기반**으로 개발한 **무료 공개** 운영체제
    - LINUX 특징

      | 특징      | 설명                        |
      | --------- | --------------------------- |
      | 개발자    | **리누스 토발즈** (1991년)  |
      | 기반      | **UNIX** 기반               |
      | 소스 코드 | **무료 공개**               |
      | 호환성    | UNIX와 **완벽 호환**        |
      | 재배포    | **재배포 가능**             |
      | 플랫폼    | **다양한 플랫폼** 설치 가능 |

12. MacOS
    - **애플**이 1980년대 **UNIX 기반**으로 개발한 운영체제
    - MacOS 특징

      | 특징      | 설명                            |
      | --------- | ------------------------------- |
      | 개발사    | **애플** (Apple)                |
      | 기반      | **UNIX** 기반                   |
      | 사용 제품 | **애플 제품만** (iMac, MacBook) |
      | 설치/삭제 | **단순**                        |

    - 파일 디스크립터 (File Descriptor)
      - 파일 관리를 위한 **파일 정보를 가진 제어 블록** (= 파일 제어 블록, FCB)
      - 특징

        | 특징 | 설명                                         |
        | ---- | -------------------------------------------- |
        | 존재 | 파일마다 **독립적** 존재                     |
        | 저장 | 보조기억장치 → Open 시 **주기억장치**로 이동 |
        | 참조 | 사용자가 **직접 참조 불가** (시스템이 관리)  |

---

### 4. 기억장치 관리의 개요

1. **기억장치 관리란?**

   > **한 줄 정의:** 한정된 **주기억장치 공간을 효율적**으로 사용하기 위한 전략

2. **기억장치 계층 구조**

   ```
         속도 빠름 / 용량 작음 / 고가
               ▲
   ┌─────────────────────────────┐
   │        레지스터             │  ← CPU 내부
   ├─────────────────────────────┤
   │      캐시 기억장치          │  ← CPU 가까이
   ├─────────────────────────────┤
   │       주기억장치            │  ← RAM
   ├─────────────────────────────┤
   │      보조기억장치           │  ← HDD, SSD
   └─────────────────────────────┘
               ▼
         속도 느림 / 용량 큼 / 저가
   ```

   - 계층 구조 특징

     |   위치   |   속도   |   용량   |   가격   |
     | :------: | :------: | :------: | :------: |
     | **상위** | **빠름** | **작음** | **고가** |
     | **하위** |   느림   |    큼    |   저가   |

3. **CPU 직접 액세스**

   |     기억장치      | CPU 직접 액세스 |
   | :---------------: | :-------------: |
   |   **레지스터**    |   ⭕ **가능**   |
   | **캐시 기억장치** |   ⭕ **가능**   |
   |  **주기억장치**   |   ⭕ **가능**   |
   | **보조기억장치**  |  ❌ **불가능**  |
   - 보조기억장치 액세스 방법
     - 보조기억장치 데이터 → **주기억장치에 적재** → CPU 액세스

4. **기억장치 관리 전략 3가지**

   |          전략          | 한 줄 정의                 | 핵심 질문  |
   | :--------------------: | -------------------------- | :--------: |
   |    **반입 (Fetch)**    | **언제** 적재할 것인가     | **When?**  |
   |  **배치 (Placement)**  | **어디에** 위치시킬 것인가 | **Where?** |
   | **교체 (Replacement)** | **무엇을** 교체할 것인가   | **What?**  |
   1. 반입 (Fetch) 전략
      - 보조기억장치의 프로그램/데이터를 **언제** 주기억장치로 적재할지 결정

      |                방법                | 한 줄 정의             |
      | :--------------------------------: | ---------------------- |
      |    **요구 반입** (Demand Fetch)    | **요구할 때** 적재     |
      | **예상 반입** (Anticipatory Fetch) | **미리 예상**하여 적재 |

   2. 배치 (Placement) 전략 (시험 필수!)
      - 새로 반입되는 프로그램/데이터를 **어디에** 위치시킬지 결정

      |           방법            | 한 줄 정의                       |  단편화  |
      | :-----------------------: | -------------------------------- | :------: |
      | **최초 적합** (First Fit) | **첫 번째** 빈 영역에 배치       |    -     |
      | **최적 적합** (Best Fit)  | 단편화 **가장 작게** 남기는 영역 | **최소** |
      | **최악 적합** (Worst Fit) | 단편화 **가장 많이** 남기는 영역 | **최대** |
      - 배치 전략 예시

        ```
        빈 공간: 100KB, 500KB, 200KB, 300KB
        프로그램 크기: 150KB

        최초 적합: 500KB (첫 번째로 들어갈 수 있는 곳)
        최적 적합: 200KB (가장 딱 맞는 곳, 단편화 50KB)
        최악 적합: 500KB (가장 큰 곳, 단편화 350KB)
        ```

   3. 교체 (Replacement) 전략
      - 주기억장치가 꽉 찼을 때 **어느 영역을 교체**할지 결정
      - 교체 전략 종류

        |   전략   | 전체 이름                 |
        | :------: | ------------------------- |
        | **FIFO** | First In First Out        |
        | **OPT**  | Optimal                   |
        | **LRU**  | Least Recently Used       |
        | **LFU**  | Least Frequently Used     |
        | **NUR**  | Not Used Recently         |
        | **SCR**  | Second Chance Replacement |

5. **관리 전략 비교표**

   |   전략   | 결정 사항       | 종류                          |
   | :------: | --------------- | ----------------------------- |
   | **반입** | **언제** 적재   | 요구 반입, 예상 반입          |
   | **배치** | **어디에** 위치 | 최초, 최적, 최악 적합         |
   | **교체** | **무엇을** 교체 | FIFO, OPT, LRU, LFU, NUR, SCR |

---

### 5. 가상기억장치 구현 기법 / 페이지 교체 알고리즘

1. **가상기억장치란?**

   > **한 줄 정의:** **보조기억장치 일부**를 주기억장치처럼 사용하여 **작은 주기억장치를 크게** 보이게 하는 기법

2. **가상기억장치 특징**

   | 특징          | 설명                                      |
   | ------------- | ----------------------------------------- |
   | **목적**      | 주기억장치보다 **큰 프로그램** 실행       |
   | **방식**      | 프로그램을 **블록 단위**로 나누어 관리    |
   | **장점**      | 주기억장치 이용률↑, 다중 프로그래밍 효율↑ |
   | **단편화**    | 연속 할당의 단편화 **해결**               |
   | **주소 변환** | 가상주소 → 실제주소 변환 필요             |

3. **가상기억장치 구현 기법**

   |       기법       |   블록 크기   |     단편화      |
   | :--------------: | :-----------: | :-------------: |
   |    **페이징**    | **동일** 크기 | **내부** 단편화 |
   | **세그먼테이션** | **가변** 크기 | **외부** 단편화 |
   1. 페이징 (Paging) 기법
      - 프로그램과 주기억장치를 **동일한 크기**로 나누어 적재하는 기법
      - 용어

        | 용어                           | 한 줄 정의                             |
        | ------------------------------ | -------------------------------------- |
        | **페이지 (Page)**              | 프로그램을 **동일 크기**로 나눈 단위   |
        | **페이지 프레임 (Page Frame)** | 주기억장치를 **동일 크기**로 나눈 단위 |
        | **페이지 맵 테이블**           | 페이지 **위치 정보** 저장 테이블       |

      - 페이징 특징

        | 특징        | 설명                             |
        | ----------- | -------------------------------- |
        | 블록 크기   | **동일** (고정)                  |
        | 단편화      | **내부 단편화** 발생 가능        |
        | 외부 단편화 | 발생 **안 함**                   |
        | 필요 테이블 | **페이지 맵 테이블**             |
        | 단점        | 테이블 비용 증가, 처리 속도 감소 |

   2. **세그먼테이션 (Segmentation) 기법**
      - 프로그램을 **논리적 단위(가변 크기)**로 나누어 적재하는 기법
      - 용어

        | 용어                   | 한 줄 정의                                |
        | ---------------------- | ----------------------------------------- |
        | **세그먼트 (Segment)** | 배열, 함수 등 **논리적 단위**로 나눈 블록 |
        | **세그먼트 맵 테이블** | 세그먼트 **위치 정보** 저장 테이블        |
        | **기억장치 보호키**    | 다른 세그먼트 **침범 방지**               |

      - 세그먼테이션 특징

        | 특징        | 설명                      |
        | ----------- | ------------------------- |
        | 블록 크기   | **가변** (논리적)         |
        | 단편화      | **외부 단편화** 발생 가능 |
        | 내부 단편화 | 발생 **안 함**            |
        | 목적        | **기억공간 절약**         |
        | 필요 테이블 | **세그먼트 맵 테이블**    |

      - 세그먼트 맵 테이블 구성

        | 세그먼트 번호(s) | 세그먼트 크기(L) | 기준번지(b) |
        | :--------------: | :--------------: | :---------: |
        |  세그먼트 식별   |     한계번지     |  시작주소   |

      - 주소 변환 과정
        1. 세그먼트 번호로 맵 테이블에서 **기준번지, 크기** 검색
        2. **변위값 ≤ 세그먼트 크기** 확인
        3. 조건 충족 시: **기준번지 + 변위값 = 실기억주소**
        4. 조건 미충족 시: **트랩 발생** (영역 침범)

4. **페이징 vs 세그먼테이션 비교**

   |    구분     |      페이징      |    세그먼테이션    |
   | :---------: | :--------------: | :----------------: |
   |  블록 크기  | **동일** (고정)  | **가변** (논리적)  |
   |  블록 이름  |    **페이지**    |    **세그먼트**    |
   | 내부 단편화 |     **발생**     |     발생 안 함     |
   | 외부 단편화 |    발생 안 함    |      **발생**      |
   |  맵 테이블  | 페이지 맵 테이블 | 세그먼트 맵 테이블 |

5. **페이지 교체 알고리즘**
   - **페이지 부재** 발생 시 어떤 페이지를 **교체**할지 결정하는 기법
   - 페이지 부재 (Page Fault)
     - 필요한 페이지가 주기억장치에 **없을 때** 발생

6. **페이지 교체 알고리즘 종류**

   | 알고리즘 | 전체 이름                 | 한 줄 정의                                  |
   | :------: | ------------------------- | ------------------------------------------- |
   | **OPT**  | Optimal                   | **앞으로 가장 오래** 사용 안 할 페이지 교체 |
   | **FIFO** | First In First Out        | **가장 먼저 들어온** 페이지 교체            |
   | **LRU**  | Least Recently Used       | **가장 오래 전에 사용된** 페이지 교체       |
   | **LFU**  | Least Frequently Used     | **사용 빈도 가장 적은** 페이지 교체         |
   | **NUR**  | Not Used Recently         | **최근에 사용 안 한** 페이지 교체           |
   | **SCR**  | Second Chance Replacement | FIFO **단점 보완**, 2차 기회                |
   1. **OPT (Optimal, 최적 교체)**
      - **앞으로 가장 오랫동안 사용하지 않을** 페이지 교체

      | 특징   | 설명                               |
      | ------ | ---------------------------------- |
      | 제안자 | **벨레이디 (Belady)**              |
      | 효율   | **가장 효율적** (페이지 부재 최소) |
      | 단점   | 미래 예측 필요 → 실현 어려움       |

   2. **FIFO (First In First Out)**
      - **가장 먼저 들어와서 가장 오래 있었던** 페이지 교체

      | 특징 | 설명                 |
      | ---- | -------------------- |
      | 방식 | 적재 시간 기록       |
      | 장점 | 이해 쉬움, 설계 간단 |

   3. **LRU (Least Recently Used)**
      - **최근에 가장 오랫동안 사용하지 않은** 페이지 교체

      | 특징 | 설명                                          |
      | ---- | --------------------------------------------- |
      | 방식 | **계수기(Counter)** 또는 **스택(Stack)** 사용 |
      | 기준 | 가장 **오래 전에 사용된** 페이지              |

   4. LFU (Least Frequently Used)
      - **사용 빈도가 가장 적은** 페이지 교체

      | 특징 | 설명                                |
      | ---- | ----------------------------------- |
      | 기준 | 사용 **횟수**                       |
      | 특징 | 활발히 사용되는 페이지는 교체 안 됨 |

   5. NUR (Not Used Recently)
      - **최근에 사용하지 않은** 페이지 교체 (LRU 개선)
      - NUR 비트 구성

      | 참조 비트 | 변형 비트 | 교체 순서 |
      | :-------: | :-------: | :-------: |
      |     0     |     0     | **1순위** |
      |     0     |     1     |   2순위   |
      |     1     |     0     |   3순위   |
      |     1     |     1     |   4순위   |

   6. SCR (Second Chance Replacement)
      - **FIFO 단점 보완**, 자주 사용되는 페이지에 **2차 기회** 부여

---

### 6. 가상기억장치 기타 관리 사항

1. **개요**

   > 가상기억장치의 **페이지 크기, Locality, 워킹 셋, 스래싱** 등 관리 사항

2. **페이지 크기에 따른 특징**
   - 페이지 크기가 **작을** 경우

     | 항목                  | 효과             |
     | --------------------- | ---------------- |
     | 페이지 **단편화**     | **감소** ↓       |
     | 페이지 이동 시간      | **감소** ↓       |
     | 불필요한 내용 적재    | **감소** ↓       |
     | 워킹 셋 유지          | **효율적**       |
     | **Locality**          | **일치** (효율↑) |
     | 페이지 맵 테이블 크기 | **증가** ↑       |
     | 매핑 속도             | **느림**         |
     | 디스크 접근 횟수      | **증가** ↑       |
     | 입출력 시간           | **증가** ↑       |

   - 페이지 크기가 **클** 경우

     | 항목                  | 효과       |
     | --------------------- | ---------- |
     | 페이지 **단편화**     | **증가** ↑ |
     | 페이지 이동 시간      | **증가** ↑ |
     | 불필요한 내용 적재    | **증가** ↑ |
     | 페이지 맵 테이블 크기 | **감소** ↓ |
     | 매핑 속도             | **빠름**   |
     | 디스크 접근 횟수      | **감소** ↓ |
     | 입출력 효율           | **증가** ↑ |

   - 핵심 비교

     | 페이지 크기 | 단편화 | 맵 테이블 | 매핑 속도 | 디스크 접근 |
     | :---------: | :----: | :-------: | :-------: | :---------: |
     |  **작음**   | ↓ 감소 |  ↑ 증가   |  ↓ 느림   |   ↑ 증가    |
     |   **큼**    | ↑ 증가 |  ↓ 감소   |  ↑ 빠름   |   ↓ 감소    |

3. **Locality (국부성/지역성)**
   - 프로세스 실행 중 **일부 페이지만 집중적으로 참조**하는 성질
   - Locality 특징

     | 특징      | 설명                                 |
     | --------- | ------------------------------------ |
     | 제안자    | **데닝 (Denning)** 교수              |
     | 기반 이론 | **워킹 셋** 이론의 기반              |
     | 목적      | **스래싱 방지**                      |
     | 응용      | **캐시 메모리** 시스템의 이론적 근거 |

   - Locality 종류 (시험 필수!)
     1. 시간 구역성 (Temporal Locality)
        - **한 번 참조한 페이지**를 가까운 시간 내에 **계속 참조**

        | 예시                          |
        | ----------------------------- |
        | **Loop** (반복, 순환)         |
        | **스택** (Stack)              |
        | **부 프로그램** (Sub Routine) |
        | **Counting** (1씩 증감)       |
        | **집계** (Totaling) 변수      |

     2. 공간 구역성 (Spatial Locality)
        - 하나의 페이지 참조 시 **근처 페이지를 계속 참조**

        | 예시                            |
        | ------------------------------- |
        | **배열 순회** (Array Traversal) |
        | **순차적 코드** 실행            |
        | **근처에 선언된 변수** 참조     |
        | 같은 **영역**의 변수 참조       |

     3. 시간 vs 공간 구역성 암기

        | 구분 |      시간 구역성      |   공간 구역성    |
        | :--: | :-------------------: | :--------------: |
        | 핵심 | **같은 것** 반복 참조 | **근처 것** 참조 |
        | 예시 |     반복문, 스택      | 배열, 순차 코드  |

4. **워킹 셋 (Working Set)**
   - 프로세스가 일정 시간 동안 **자주 참조하는 페이지들의 집합**
   - 워킹 셋 특징

     | 특징   | 설명                             |
     | ------ | -------------------------------- |
     | 제안자 | **데닝 (Denning)**               |
     | 기반   | **Locality** 특성 이용           |
     | 목적   | **페이지 부재** 및 **교체 감소** |
     | 변화   | 시간에 따라 **변경됨**           |

   - 워킹 셋 효과
     - 자주 참조되는 워킹 셋을 **주기억장치에 상주** → **페이지 부재 감소** → **안정적 실행**

5. **페이지 부재 빈도 (PFF) 방식**
   - **페이지 부재율**에 따라 페이지 프레임 수를 **조절**하는 방식
   - 동작 방식

     |  페이지 부재율  | 조치                        |
     | :-------------: | --------------------------- |
     | **상한선** 초과 | 페이지 프레임 **추가 할당** |
     | **하한선** 미만 | 페이지 프레임 **회수**      |

6. **프리페이징 (Prepaging)**
   - 처음의 **과도한 페이지 부재 방지**를 위해 필요한 페이지를 **한꺼번에 적재**
   - 프리페이징 특징

     | 특징 | 설명                                 |
     | ---- | ------------------------------------ |
     | 목적 | 초기 페이지 부재 **방지**            |
     | 방식 | 필요 페이지 **한꺼번에** 적재        |
     | 단점 | 사용 안 하는 페이지도 적재될 수 있음 |

7. **스래싱 (Thrashing)**
   - 프로세스 처리 시간보다 **페이지 교체 시간이 더 많아지는** 현상
   - 스래싱 특징

     | 특징       | 설명                      |
     | ---------- | ------------------------- |
     | 원인       | **페이지 부재** 자주 발생 |
     | 결과       | 시스템 **성능 저하**      |
     | CPU 이용률 | **급격히 감소**           |

   - 스래싱 발생 과정

     ```
     다중 프로그래밍 정도 ↑
        ↓
     페이지 부재 ↑
        ↓
     페이지 교체 ↑
        ↓
     CPU 이용률 ↓ (스래싱!)
     ```

   - 스래싱 방지 방법

     | 방법                                    |
     | --------------------------------------- |
     | 다중 프로그래밍 정도 **적정 수준 유지** |
     | **페이지 부재 빈도 (PFF)** 조절         |
     | **워킹 셋** 유지                        |
     | 부족한 **자원 증설**                    |
     | 일부 **프로세스 중단**                  |
     | CPU 성능 지속적 **관리/분석**           |
