---
title: Spring Boot MVC패턴
date: '2025-10-13'
tags: ['spring']
draft: false
summary: 스프링에서의 MVC패턴에 대한 설명, 기존의 스프링부트와 REST API로 동작하는 스프링 부트에서의 MVC패턴의 차이.
---

MVC 패턴(Model–View–Controller)은 소프트웨어 아키텍처 패턴 중 하나로, 애플리케이션을 역할별로 분리하여 유지보수성과 확장성을 높이기 위한 구조이다.
이러한 패턴 구조는 웹 프레임워크(Spring MVC, Django, Rails 등)나 프론트엔드(JS, React 아키텍처의 일부 개념)에서도 자주 사용된다.
이번엔 스프링에서의 mvc패턴에 대한 정리이다.

### 1. MVC 구조 개요

| 구성요소                      | 역할                          |예시                          |
| --------------------------- | ---------------------------- |---------------------------- |
| MODEL                       | 데이터 및 비지니스 로직 관리        |DB 엔티티, DAO, 서비스 클래스     |
| VIEW                        | 사용자에게 보여지는 UI            |HTML, JSP, React 컴포넌트 등    |
| CONTROLLER                  | 사용자 요청을 받아 처리 흐름 제어    |Spring Controller, Express Router 등 |

![MVC Diagram](/static/images/mvc_pattern.png)


**동작흐름**
    1. `사용자 요청(Request)` : 사용자가 브라우저에서 URL을 입력하거나 트리거를 통해 Contoller로 요청을 전달
	2. `Contoller처리` : Controller는 해당 요청을 어떤 로직으로 처리할지 결정하고, 필요한 데이터를 Model에서 가져옴
	3. `Model동작` : Model은 DB나 비지니스 로직을 처리하고 결과 데이터를 Controller에게 반환함.
	4. `View 반환` : Contoller는 받은 데이터를 View에 전달 > View는 최종적으로 사용자에게 응답을 렌더링

<br/>

**🔹 구조 다이어그램**

```bash
[Client]
   ↓ HTTP Request
[DispatcherServlet]   ← Front Controller
   ↓
[HandlerMapping] → 어떤 Controller를 호출할지 결정
   ↓
[Controller] → 요청 처리 / Model 데이터 생성
   ↓
[Service] + [DAO] + [Repository] → 비즈니스 로직 / DB 처리
   ↓
[ModelAndView] (데이터 + View 이름)
   ↓
[ViewResolver] → JSP, Thymeleaf 등으로 변환
   ↓
[View] → 최종 HTML 렌더링
   ↓
[Client]
```


> Spring Boot에서는 DispatcherServlet이 자동으로 등록되어,
> 모든 HTTP 요청을 중앙에서 받아 HandlerMapping을 통해 적절한 @Controller 혹은 @RestController 메서드로 라우팅한다.
> 그 후 HandlerAdapter가 해당 메서드를 실행하고, 결과를 HttpMessageConverter를 통해
> View(JSP) 혹은 JSON 응답(ResponseBody) 으로 변환해 클라이언트에 전달한다.

> 즉, “MVC 구조” 자체는 동일하되, View Resolver 대신 Message Converter가 최종 단계를 담당한다는 점이 REST MVC의 핵심 차이점이다.

<br/>

**예시 (스프링 MVC 기준)**

```java
// Controller
@Controller
public class UserController {

    @Autowired
    private UserService userService;

    @GetMapping("/users")
    public String getUsers(Model model) {
        List<User> users = userService.getAllUsers();  // Model 호출
        model.addAttribute("users", users);
        return "userList"; // View 이름 반환 (userList.jsp)
    }
}
```

```java
// Model (Service + Entity)
@Service
public class UserService {
    @Autowired
    private UserRepository userRepository;

    public List<User> getAllUsers() {
        return userRepository.findAll();
    }
}

@Entity
public class User {
    private Long id;
    private String name;
}
```

```html
<!-- View (userList.jsp) -->
<html>
<body>
<h2>사용자 목록</h2>
<ul>
  <c:forEach var="user" items="${users}">
    <li>${user.name}</li>
  </c:forEach>
</ul>
</body>
</html>
```

---

### 2. 통적인 MVC vs REST 기반 MVC

요즘의 스프링 부트(Spring Boot) 애플리케이션은
더 이상 JSP나 Thymeleaf 같은 “화면(View)”을 렌더링하지 않고,
JSON 데이터를 반환하는 REST API 형태로 동작하는 경우가 많다.
즉, 전통적인 MVC 구조에서의 ‘View’ 역할이 달라졌다는 뜻이다. 

아래는 스프링에서 역할에 따라 MVC의 차이를 나타낸다.

| 구분                         | 전통적인 Spring MVC            |RESTful Spring Boot (JSON 응답)|
| --------------------------- | ---------------------------- |---------------------------- |
| VIEW                        | JSP / Thymeleaf / HTML 템플릿 |JSON 데이터 (Response Body)     |
| CONTROLLER                  | @Controller                 |@RestController               |
| 응답방식                      | ViewResolver를 통해 View 이름을 찾음 |@ResponseBody로 JSON 변환   |
| 사용목적                      | 웹 페이지 렌더링                |API 서버 (React, Vue, 앱 등 클라이언트와 통신)|


<br/>

**🔹  Spring Boot에서의 MVC 구성 (JSON 중심)**

```bash
[Client: React / 모바일앱]
   ↓ HTTP 요청 (GET /api/users)
[Controller: @RestController]
   ↓
[Service] - 비즈니스 로직
   ↓
[Repository] - DB 접근 (JPA)
   ↓
[Model] - Entity / DTO
   ↓
[Controller → JSON 변환 후 응답]
   ↓
[Client에 JSON 데이터 반환]
```

<br/>

**예시 (스프링 MVC 기준)**

```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
}
```
```java
@Service
@RequiredArgsConstructor
public class UserService {
    private final UserRepository userRepository;

    public List<User> getAllUsers() {
        return userRepository.findAll();
    }
}
```
```java
@RestController
@RequestMapping("/api/users")
@RequiredArgsConstructor
public class UserController {

    private final UserService userService;

    @GetMapping
    public List<User> getUsers() {
        return userService.getAllUsers();  // JSON으로 자동 변환
    }
}
```


**결과값(VIEW에 해당)**

```JSON
[
  { "id": 1, "name": "Mingoo", "email": "mingoo@ppsoln.com" },
  { "id": 2, "name": "Anna", "email": "anna@example.com" }
]
```


## ✅ 결론

전통적인 Spring MVC는 화면(View)을 렌더링하는 웹 애플리케이션 구조였다.
하지만 Spring Boot + REST API 시대에서는,
뷰(View)가 더 이상 JSP나 Thymeleaf가 아닌 JSON 응답으로 대체되었다.

결국 스프링의 MVC 패턴은 형태만 바뀌었을 뿐,
“Controller는 흐름 제어, Model은 데이터 관리, View는 표현 책임”이라는 핵심 원리는 동일하다.

단지 이제의 View는 HTML이 아닌 JSON이며,
ViewResolver 대신 HttpMessageConverter가 그 역할을 수행할 뿐이다.
이 구조 덕분에 Spring Boot는 프론트엔드(React, Vue)나 모바일 앱과 완벽히 분리된 백엔드 서버로 진화하게 되었다.

