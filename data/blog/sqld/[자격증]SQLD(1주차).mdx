---
title: '[SQLD 자격증 공부] Chaper1 - 데이터 모델링의 이해 (WEEK 1)'
date: '2025-09-07'
tags: ['sqld', 'database', 'license']
draft: false
summary: SQLD 1주차 공부 내용을 정리. [데이터 모델링의 이해], [엔터티], [속성(Attribute)], [관계], [식별자]
---

import ImageWithCaption from '@/components/mdxComponents/ImageWithCaption'

### 1. 데이터 모델링의 이해

1. **모델링의 개념**
   - 일종의 모델을 만드는 작업. 실물을 축소하거나 단순하게 만드는 작업 => 도식화
     - ex) 프라**모델**
   - 원래의 대상을 본떠 만든 장난감
   - 상호 약속된 표기법을 사용
   - 특징을 추려서 단순화하여 나타내는 추상화를 기본으로 함

   <br />

2. **모델링의 특징**

   모델링은 추상화, 단순화, 명확화라는 3가지 특징을 갖는다.
   - 추상화 : 대상의 특징을 추출하여 일정한 형식으로 표현
   - 단순화 : 복잡한 대상을 그대로 표현하지 않고, 단순화 하여 표현
     - UML(unified modeling language)나 ERD(entity relationship diagram)과 같은 약속된 표기법을 사용
   - 명확화 : 보는 사람에 따라 다르게 해석되지 않게 명확하게 표현(중복 최소화, 비유연성 최소화, 비일관성 최소화)

<br />

3. **모델링의 3가지 관점**
   - 데이터 관점 : 데이터에 집중하여 모델링을 진행하는 방식. 데이터들이 맺는 관계와 사용에 초점을 맞춰 모델링(정적 분석 / 구조 분석)
   - 프로세스 관점 : 업무에 흐름에 집중하여 모델링을 진행하는 방식. 업무가 실제로 처리하는 일을 모델링(동적분석 / 도메인 분석)
   - 데이터와 프로세스 관점 : 업무를 구성하는 데이터와 프로세스의 상관관계에 집중하여 모델링을 진행하는 방식(CRUD 기반)

   <br />

4. **모델링의 3가지 단계**
   1. **개념적 모델링**
      - 가장 높은 추상화 레벨의 모델링
      - 업무와 개념 중심의 포괄적 수준의 모델링
      - EA(Enterprise Architecture) 수립, 엔터티, 속성 도출<br/><br/>
   2. **논리적 모델링**
      - 데이터 모델에 대한 키, 속성, 관계를 표현
      - 서로 다른 DBMS에 적용 가능 => 재사용성이 높다.
      - 정규화를 통해 중복데이터를 최소화.<br/><br/>
   3. **물리적 모델링**
      - 특정 DBMS에 맞춰 구현가능한 수준으로 모델링
      - 성능향상을 위해 반정규화 => 테이블, 인덱스, 함수 등을 생성<br/><br/>

   <br />

5. **ANSI-SPARC에서 정의한 3단계 스키마의 구조**

   1975년에 DBMS의 추상적인 설계표준을 제안한 방법으로, 데이터의 독립성을 보장하기 위한 실제방법을 제시한다. 여기서 말하는 3단계는 각각 사용자, 설계자, 개발자의 관점에서 정의한것이다.
   1. **외부 스키마**
      - 사용자의 관점에서 정의
      - 사용자 또는 어플리케이션이 바라보는 데이터베이스 스키마<br/><br/>
   2. **개념 스키마**
      - 설계자 관점에서 정의
      - 모든 사용자가 바라보는 데이터베이스 스키마
      - 데이터베이스에 저장되는 데이터와 관계<br/><br/>
   3. **내부 스키마**
      - 개발저 관점에서 정의
      - 물리적, 실질적 저장구조 테이블, 칼럼, 인덱스 정의<br/><br/>

   <ImageWithCaption
     src="/static/images/ansi-sparc-diagram.png"
     alt="ANSI-SPARC Diagram"
     caption="ANSI-SPARC 다이어그램"
   />

<br />

6. **ERD (Entity Relationship Diagram)**

   데이터베이스를 구성하는 데이터의 논리적 주성요소를 엔터티로 정의하고, 엔터티들의 관계를 표기하여 스키마를 설계하는 방법
   - 작성순서 : 엔터티 도출 > 엔터티 배치 > 엔터티 관계 설명 > 관계명 기술 > 관계 참여도 기술 > 관겨의 필수 여부 기술
     <ImageWithCaption src="/static/images/erd.png" alt="erd" caption="ERD 다이어그램" />

<br />

---

### 2. 엔터티

1. **엔터티의 개념**
   - 데이터베이스 구성요소 중 독립적으로 식별 가능한 객체(Object)
   - 일종의 테이블과 같은 개념
   - 속성이라는 값을 가짐
     - 속성 : Attribute라고하며, 엔터티의 하위요소. 가령 회원 엔터티에 회원명, 주소와 같은 속성을 가짐.
       <ImageWithCaption
         src="/static/images/entity-diagram.png"
         alt="Entity Diagram"
         caption="엔터티 구조"
       />

2. **엔터티의 특징**
   1. 업무에서 필요로하고 관리하고자 하는 정보여야 함
   2. 식별가능한 유일한 식별자를 필요로 함(ID와 같는 값)
   3. 영속적 인스턴스가 2개 이상인 집합 => ex) 회원이라는 엔터티라고 하면 최소 2명 이상의 회원이 필요로
   4. 하위요소로 반드시 속성(attribute)가 필요함
   5. 엔터티는 다른 엔터티와 1개이상의 관계가 필요 > `생략 가능`

3. **엔터티의 분류**
   1. 발생시점 / 상속관계에 따른 분류
      - 기본 엔터티 : 자신의 고유한 주식별자를 가지는 독립적 엔터티 > `회원` 또는 `상품` 등
      - 중심 엔터티 : 기본엔터티로부터 주식별자(PK)를 상속받아 생성되는 엔터티 > `주문`, `월급` 등
      - 행위 엔터티 : 두개이상의 엔터티를 상속받아 생성되는 엔터티 > `주문내역`, `급여내역` 등

   2. 물리적 형태의 존재 여부에 따른 분류
      - 유형 엔터티 : 물리적 형태가 존재하는 엔터티 > `사원`,`학생`,`상품` 등
      - 개념 엔터티 : 물리적 형태가 존재하지 않는 엔터티 > `부서`, `강의` 등
      - 사건 엔터티 : 업무나 수행을 통해 발생하는 이벤트 엔터티 > `주문`, `대여`, `수강` 등

<br />

---

### 3. 속성(Attribute)

1. **속성의 개념**
   - 엔터티의 구체적인 정보를 나타낸것 > 엔터티의 하위요소
   - 엔터티의 특징중 업무와 관계되어 필요한 것
     - `사원이라는 엔터티에 이름, 직책, 주소와 같은 속성값이 있을 수 있음`
   - 의미상 분리하지 않는 최소 단위

2. **속성 값**
   - 속성 값은 속성을 이루는 값의 집합
   - 속성이 가질 수 있는 특정 값
   - 하나의 엔터티 인스턴스에는 속성은 하나의 속성값을 가짐

3. **엔터티, 인스턴스, 속성 값**
   - 하나의 엔터티는 두개 이상의 인스턴스를 갖는다.
   - 하나의 엔터티는 두개 이상의 속성을 갖는다.
   - 하나의 속성의 속성값은 인스턴스별로 하나만 갖는다.
     <ImageWithCaption
       src="/static/images/entity-table.png"
       alt="entity-discription"
       caption="엔터티 설명"
     />

4. **속성의 분류**
   1. 특성에 따른 분류
      - 기본속성 : 엔터티가 기본으로 가진 속성
      - 설계속성 : 설계시 필요에 의해 갖게된 속성
      - 파생속성 : 다른 속성으로부터 계산 및 변형되 만들어진 속성
   2. 구성방식에 따른 분류
      - PK(Primary Key) 기본키 속성 : 인스턴스의 식별자 속성
      - FK(Foreign Key) 외래키 속성 : 다른 엔터티의 관계를 가져와 포함시킨 속성
      - 일반 속성 : PK, FK가 아닌 속성

5. **도메인**

   사전적으로 도메인(Domain)은 영역, 범위라는 뜻을 갖는다. 그래서 인터넷의 주소체계를 말할때도 도메인이 사용되고,데이터베이스의 속성의 범위를 나타내기도 한다.
   - 속성이 가질 수 있는 값의 범위(타입 + 크기)
   - 데이터의 타입, 크기, 제약사항을 묵어 이름을 붙혀 정의
   - 도메인은 데이터 타입(문자형, 숫자형, 날짜형 등) + 허용 범위(길이, 최소/최대값 등)를 포함 > 데이터의 타입보다 좁은 속성값 범위
     | 엔터티 | 속성(Attribute) | **도메인(Domain)** |
     | ------------- | ------------------- | ------------------------ |
     | 회원(Member) | 성별(Gender) | `M`, `F` |
     | 회원(Member) | 나이(Age) | `0 ~ 120 (정수)` |
     | 주문(Order) | 주문일자(OrderDate) | `YYYY-MM-DD (날짜 형식)` |
     | 상품(Product) | 가격(Price) | `0 이상 숫자` |

## <br/>

### 4. 관계

1. **관계의 개념**
   - 엔터티와 엔터티안에 맺고 있는 연관성
   - 존재적 / 행위적 관계로 나눌 수 있음
     1. **존재적 관계**
        - 소속관계를 갖는 경우, 존재 자체로 서로 연관성을 가짐
        - **ex) 사원과 부서의 관계**
     2. **행위적 관계**
        - 한 엔터티가 특정 행위를 일으킬 경우 연관성이 발생하는 관계
        - **ex) 고객과 주문의 관계**

2. **표기법**
   1. 관계명 : 관계의 이름
   2. 관계차수 : `1:1`, `1:N`, `N:M`과 같이 관계를 맺는 인스턴스의 차수

      ```mermaid
      erDiagram
         사원 one to one 급여 : "1:1"
         고객 one optionally to many 주문 : "1:N"
         학생 many to many 강의 : "N:M"
         <<관계 차수 다이어그램>>
      ```

3. **관계 선택 사양**
   1. 필수적/선택적 관계에 대한 내용(Null 가능 여부 진단)
   2. 필수적 관계라면 Null을 허용하지 않음, 선택적 관계일 경우 Null허용
   3. 가령 사원과 부서는 필수적 관계. 그러나 고객과 주문은 선택적 관계

## <br/>

### 5. 식별자

1. **식별자의 개념**
   - 인스턴스를 구분하는 속성을 식별자라 부름.
   - 인스턴스의 대표 속성, ID와 같은 속성으로 작명됨.
   - 속성값의 중복을 허락하지 않는다.
2. **주식별자**
   - 인스턴스를 유일하게 구분해주는 식별자(PK-Priamry Key)
   - **주식별자의 특성**
     1. **유일성** : 주식별자의 속성값은 중복되면 안된다.
     2. **최소성** : 유일성의 보장과 함께 최소 갯수의 속성이 되어야한다. **(식별자(PK)는 중복 없이 유일해야 하지만,동시에 그 유일성을 만들기 위해 불필요한 속성을 포함하지 말라는 의미)**
        - 아래와 같은 테이블이 있을 때 학번만으로 PK를 만들수 있다. `PRIMARY KEY (학번, 이름)`와 같이 필요없는 요소인 "이름"을 PK에 넣을 필요가 없다.
          | 학번 | 이름 | 전공 |
          | ------- | ------ | ---------- |
          | 2025001 | 김민준 | 컴퓨터공학 |
          | 2025002 | 이서윤 | 경영학 |
          ```sql
            CREATE TABLE student (
                학번 INT,
                이름 VARCHAR(20),
                전공 VARCHAR(30),
                PRIMARY KEY (학번)) // 학번만으로 PK 충분함.
          ```
     3. **불변성** : 최초로 부여한값을 변경할 수 없다.
     4. **존재성** : Null을 허락하지 않는다. 즉 값을 필수로 가져야한다.
3. **식별자의 분류**
   1. 대표성 여부에 따른 분류
      - 주식별자 : 인스턴스를 구분하는 식별자. 유일성, 최소성, 불변성, 존재성을 만족하는 대표 식별자이다.
      - 보조식별자 : 엔터티의 인스턴스를 구분할 수 있으나, 대표성이 없고, 참조연결(FK-Foreign Key)에 사용되지 않는다.
        | 학번 | 주민등록번호 | 이메일 | 이름 |
        | ------- | -------------- | -------------------- | ------ |
        | 2025001 | 990101-1234567 | minjun@school.ac.kr | 김민준 |
        | 2025002 | 000305-2345678 | seoyoon@school.ac.kr | 이서윤 |

        ```sql
            CREATE TABLE student (
            학번 INT PRIMARY KEY,            -- 주식별자
            주민등록번호 CHAR(13) UNIQUE,    -- 보조 식별자
            이메일 VARCHAR(50) UNIQUE,        -- 보조 식별자
            이름 VARCHAR(20));
        ```

        - 이 테이블에서는 학생을 구분할 수있는 키가 여러개가 있다. 주민등록번호와 이메일은 유일하지만, 유일성, 최소성, 불변성, 존재성에서 존재성을 만족하지 못한다. 즉 Null을 허용한다는 뜻이다.
          이러한 경우 PK로는 사용할 수 없지만, 학생을 구분하는 보조식별자로써의 역할을 수행할 수 있다.

   2. 스스로 생성여부에 따른 분류
      - 내부식별자 : 엔터티 내부에서 스스로 생성
      - 외부식별자 : 관계를 통해 받아오는 식별자(FK-Foreign Key)
   3. 속성의 수에 따른 분류
      - 단일식별자 : 식별자를 구성하는 속성이 하나일때
      - 복합식별자 : 식별자를 구성하는 속성이 둘 이상일때

        ```mermaid
         erDiagram
             환자 one to many 예약 : "1:N"
             환자{
                 int 환자번호 PK "단일식별자, 내부식별자"
                 string 환자이름
                 string 환자주소
                 string 환자전화번호
             }
             간호사 one optionally to many 예약 : "1:N"
             간호사{
                 int 직원번호 PK "단일식별자, 내부식별자"
                 string 직원이름
                 string 아이디
                 string 패스워드
             }
             예약{
                 int 예약일자
                 int 환자번호 FK "외부 식별자"
                 int 최소구분코드
                 int 직원번호 FK "외부 식별자"
             }
             <<식별자의 분류1>>
        ```

        - `복합식별자(Composite Identifier)` : 예약을 식별하기 위해서는 예약일자 + 환자번호(FK) + 최소구분코드 + 직원번호(FK)가 필요

   4. 대체 여부에 따른 분류
      - 본질식별자(원조식별자) : 업부에 존제하는 본래의 식별자
      - 인조식별자(대리식별자) : 업무에 존재하지 않지만, 원조식별자의 복잡성을 낮추기 위해 만든 식별자

        ```mermaid
         erDiagram
             환자 one to many 예약 : "1:N"
             환자{
                 int 환자번호 PK "본질식별자(원조식별자)"
                 string 환자이름
                 string 환자주소
                 string 환자전화번호
             }
             간호사 one optionally to many 예약 : "1:N"
             간호사{
                 int 직원번호 PK "본질식별자(원조식별자)"
                 string 직원이름
                 string 아이디
                 string 패스워드
             }
             예약{
                 int 예약번호 PK "인조식별자(대리식별자):예약일자 + 순번"
                 int 예약일자
                 int 환자번호 FK "외부 식별자"
                 int 최소구분코드
                 int 직원번호 FK "외부 식별자"
             }
             <<식별자의 분류2>>
        ```

        - 예약일자 + 환자번호(FK) + 최소구분코드 + 직원번호(FK)를 통해 만든 복합식별자의 복잡성을 낮추기 위해 `예약번호`라는 인조식별자를 생성

4. **식별자 관계, 비식별자 관계**
   1. 식별자 관계(Identifying Relationship)
      - 엔터티간의 강한 연결관계
      - 부모엔터티가 자식엔터티와 생명주기가 같아, 같이 소명하는 경우
      - 엔터티에서 실선으로 표현
        | 주문 | 관계 | 주문상세 |
        | ------------- | ---- | ----------------- |
        | 주문번호 (PK) | ← | 주문번호 (PK, FK) |
        | 주문일자 | | 상품번호 (PK) |
        | 고객ID | | 수량 |
      - 부모의 식별자 주문번호가 자식의 PK로 들어왔기 때문에 식별자 관계
   2. 비식별자 관계(Non-Identifying Relationship)
      - 엔터티의 약한 연결관계
      - 부모속성의 식별자가 자식송성의 일반속성이 된다.
      - 점선 표현
        | 고객ID (PK) | 관계 | 주문 |
        | ----------- | ---- | ------------- |
        | 이름 | ← | 고객ID (FK) |
        | 연락처 | | 주문번호 (PK) |
        | | | 주문일자 |
      - 부모의 PK가 자식의 PK로 포함되지 않기 때문에 비식별자 관계
