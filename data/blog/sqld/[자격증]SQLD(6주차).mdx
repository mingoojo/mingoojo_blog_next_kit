---
title: '[SQLD 자격증 공부] Chaper4[part2] - SQL 활용 (WEEK 6)'
date: '2025-10-12'
tags: ['sqld', 'database', 'license']
draft: false
summary: SQLD 6주차 공부 내용을 정리.
---

import ImageWithCaption from '@/components/mdxComponents/ImageWithCaption'
import InternalLink from '@/components/mdxComponents/InternalLink'

### 5. Top N 쿼리

    - 상위 N번째 순위까지를 추출하는 쿼리
    - RANK, DENSE_RANK, ROW_NUMBER를 활용한다.
    1.  **ROWNUM 함수**
        - ROW_NUMBER와는 다른 함수이다. 현재 저장된 데이터를 그대로 두고 각 행에 순차적인 번호를 붙혀주는 함수.
        - WHERE절에서 사용해서 상위 N개(행이 출력되는 상위 N개, 특정값의 내림차순으로 끊는게 아님)의 행을 제한할 때 사용.
        - ```sql
            SELECT NAME, SAL
            FROM EMP -- 1. EMP테이블에서
            WHERE ROWNUM <= 3 --2. 출력되는 순서에서 최상위 3명을 뽑는다.
            ORDER BY SAL DESC; --3. 이후 뽑힌 3명을 SAL기준 내림차순 정리를 한다.
          ```
          - >이 경우 “SAL 상위 3명”이 아니라, “처음 3개의 행”만 가져와서 그 3개를 SAL DESC로 정렬하는 것이다.
    2.  **윈도우함수의 순위함수**
        - 윈도우 함수의 순위함수로는 RANK, DENSE_RANK, ROW_NUMBER가 있다. 이를 활용하여 TOP N쿼리를 작성할 수 있다.
        - ```sql
            SELECT *
            FROM (
            SELECT NAME, DEPT, SAL,
                    --RANK, DENSE_RANK, ROW_NUMBER등으로 바꿔서 활용가능
                    RANK() OVER (ORDER BY SAL DESC) AS RANKING
            FROM EMP
            )
            WHERE RANKING <= 10;
          ```
          - >이 경우 SAL기준으로 내림차순 정리하고, 정리된 값에서 RANKING이 10이상인 값만 출력하는 TOP N 쿼리문이다.

### 6. 계층형 질의와 셀프 조인

    - 데이터의 계층 구조(ex> 본부 - 사업부 - 팀)과 같은 형태로 구성된 상황에 모델링을 트리와 같은 구조로 할 수 있게 되는데 이를 계층형 데이터 모델이라고 한다.
    - 상위 노드에서 하위 노드로 연쇄적으로 데이터에 접근할 경우 계층형 질의 및 셀프 조인을 사용할 수 있다.
      - 계층형 질의 (Hierarchical Query) : 한 테이블 내에서 부모-자식 관계를 트리 구조로 탐색하는 질의
      - 셀프 조인 (Self Join) : 같은 테이블을 자기 자신과 조인해서 관계를 표현
    1.  **계층형 조인**
        - 한 테이블 내에서 부모-자식 관계를 트리 구조로 탐색하는 질의로써, 트리(Tree) 구조, 계층(depth)을 포함한 형태로 표현이 가능하다.
        - 테이블안에서 상하 관계가 있을때, 즉 속성 1의 값이 속성2과 1:N의 관계를 가지고 있을때 그 관계를 계층형으로(Level로) 표현하는 기능
        - 핵심 동작원리
            - | 절          | 역할                                                                  |
                |------------|---------------------------------------------------------------------|
                | START WITH | 루트(시작점) 지정 — ex \) MGR이 NULL인 사장 KING부터 시작                                |
                | CONNECT BY | 부모-자식 관계 지정 (PRIOR EMPNO = MGR ⇒ 상위 EMP의 번호가 하위 EMP의 MGR과 일치할 때 연결) |
                | PRIOR      | 계층 방향을 나타냄 (부모→자식)                                                  |
                | LEVEL      | 계층 단계 (1, 2, 3 …) 자동 계산됨                                            |
        - 예시
            - | EMPNO(직원넘버) | ENAME | MGR(상사의 직원넘버)  |
                |-------|-------|------|
                | 7839  | KING  | NULL |
                | 7566  | JONES | 7839 |
                | 7788  | SCOTT | 7566 |
                | 7876  | ADAMS | 7788 |
                - EMPNO → 직원 ID (부모 키 역할)
                - MGR → 상사의 ID (자식이 부모를 가리킴)
            - ```sql
                SELECT LEVEL, EMPNO, ENAME, MGR
                FROM EMP
                START WITH MGR IS NULL          -- 루트: 사장
                CONNECT BY PRIOR EMPNO = MGR;   -- 부모 EMPNO = 자식 MGR
                ```
            - | LEVEL(계층의 깊이를 표현) | EMPNO | ENAME  | MGR  |
                |-------|-------|--------|------|
                | 1     | 7839  | KING   | NULL |
                | 2     | 7566  | JONES  | 7839 |
                | 3     | 7788  | SCOTT  | 7566 |
                | 4     | 7876  | ADAMS  | 7788 |
                | 3     | 7902  | FORD   | 7566 |
                | 4     | 7369  | SMITH  | 7902 |
                | 2     | 7698  | BLAKE  | 7839 |
                | 3     | 7499  | ALLEN  | 7698 |
                | 3     | 7521  | WARD   | 7698 |
                | 3     | 7654  | MARTIN | 7698 |
                | 3     | 7844  | TURNER | 7698 |
                | 3     | 7900  | JAMES  | 7698 |
                | 2     | 7782  | CLARK  | 7839 |
                | 3     | 7934  | MILLER | 7782 |
            - ```sql
                -- 결과물의 도식화
                LEVEL 1: KING (사장)
                    ├── LEVEL 2: JONES
                    │       ├── LEVEL 3: SCOTT
                    │       │       └── LEVEL 4: ADAMS
                    │       └── LEVEL 3: FORD
                    │               └── LEVEL 4: SMITH
                    ├── LEVEL 2: BLAKE
                    │       ├── ALLEN
                    │       ├── WARD
                    │       └── ...
                    └── LEVEL 2: CLARK
                            └── MILLER
                ```
            - 상사의 정보도 테이블로 표출하기
                - ```sql
                    SELECT LEVEL,
                        EMPNO,
                        ENAME,
                        MGR,
                        PRIOR ENAME AS MANAGER   -- 바로 위 상사의 이름
                    FROM EMP
                    START WITH MGR IS NULL          -- 루트: 사장
                    CONNECT BY PRIOR EMPNO = MGR;   -- 부모 EMPNO = 자식 MGR
                    ```
                - | LEVEL(계층의 깊이 표현) | EMPNO | ENAME  | MGR  | MANAGER |
                    |-------|-------|--------|------|---------|
                    | 1     | 7839  | KING   | NULL | (NULL)  |
                    | 2     | 7566  | JONES  | 7839 | KING    |
                    | 3     | 7788  | SCOTT  | 7566 | JONES   |
                    | 4     | 7876  | ADAMS  | 7788 | SCOTT   |
                    | 3     | 7902  | FORD   | 7566 | JONES   |
                    | 4     | 7369  | SMITH  | 7902 | FORD    |
                    | 2     | 7698  | BLAKE  | 7839 | KING    |
                    | 3     | 7499  | ALLEN  | 7698 | BLAKE   |
                    | 3     | 7521  | WARD   | 7698 | BLAKE   |
                    | 3     | 7844  | TURNER | 7698 | BLAKE   |
                    | 3     | 7900  | JAMES  | 7698 | BLAKE   |
                    | 3     | 7654  | MARTIN | 7698 | BLAKE   |
                    | 2     | 7782  | CLARK  | 7839 | KING    |
                    | 3     | 7934  | MILLER | 7782 | CLARK   |
                - 📌 정리하자면
                    - PRIOR 키워드는 “부모 행”을 가리키기 때문에,
                    - PRIOR ENAME = 상사 이름
                    - PRIOR EMPNO = 상사의 사번
    2.  **셀프 조인**
        - 같은 테이블 내에서 조인이 가능하도록 하는 쿼리
        - 하나의 테이블을 두 번(또는 그 이상) 불러와서 서로 연결해 데이터를 조회하는 방식.
        - 핵심 동작원리
            - ```sql
                -- 기본문법
                SELECT A.컬럼, B.컬럼
                FROM 테이블명1 A, 테이블명1 B
                WHERE A.공통컬럼 = B.공통컬럼;
                ```
            - ```sql
                -- 기본문법
                SELECT A.컬럼, B.컬럼
                FROM 테이블명1 A
                JOIN 테이블명1 B
                ON A.공통컬럼 = B.공통컬럼;
                ```
        - 예시
            - ```sql
                SELECT
                    B.EMPNO,          -- 직원 번호
                    B.ENAME,          -- 직원 이름
                    A.ENAME AS BOSS,  -- 상사 이름
                    A.EMPNO AS BOSSNUMBER -- 상사 사번
                FROM EMP A, EMP B
                WHERE A.EMPNO = B.MGR;  -- 상사 사번 = 직원의 MGR
                ```
            - ```sql
                SELECT
                    B.EMPNO,
                    B.ENAME,
                    A.ENAME AS BOSS,
                    A.EMPNO AS BOSSNUMBER
                FROM EMP B
                JOIN EMP A
                ON B.MGR = A.EMPNO;
                ```
            - | EMPNO | ENAME  | BOSS  | BOSSNUMBER |
                |-------|--------|-------|------------|
                | 7566  | JONES  | KING  | 7839       |
                | 7698  | BLAKE  | KING  | 7839       |
                | 7782  | CLARK  | KING  | 7839       |
                | 7788  | SCOTT  | JONES | 7566       |
                | 7902  | FORD   | JONES | 7566       |
                | 7844  | TURNER | BLAKE | 7698       |
                | 7900  | JAMES  | BLAKE | 7698       |
                | 7876  | ADAMS  | SCOTT | 7788       |
                | 7499  | ALLEN  | BLAKE | 7698       |
                | 7521  | WARD   | BLAKE | 7698       |
                | 7934  | MILLER | CLARK | 7782       |
                | 7654  | MARTIN | BLAKE | 7698       |
                | 7369  | SMITH  | FORD  | 7902       |

### 7. PIVOT절과 UNPIVOT 절

    1.  **PIVOT 절**
      - 행(Row) 형태의 데이터를 열(Column) 형태로 바꾸는 연산자. 즉, 행 → 열 변환을 수행
      - 수행 과정 및 특징
        - **집계 함수(예: SUM, AVG)**를 사용하여 특정 컬럼 값을 기준으로 행 데이터를 열로 변환.
        - FOR 컬럼명 IN (열이름1, 열이름2, …) 구문을 통해 변환 대상 열을 지정.
        - GROUP BY 없이도 자동으로 그룹화.
        - 보고서, 통계표 형태로 데이터를 집계할 때 자주 사용.
        - 예시
            - | PRODUCT | MONTH | AMOUNT |
                |---------|-------|--------|
                | TV      | JAN   | 500    |
                | TV      | FEB   | 700    |
                | RADIO   | JAN   | 300    |
                | RADIO   | FEB   | 400    |
            - ```sql
               SELECT *
                FROM SALES -- SALES 테이블에서
                PIVOT (
                    SUM(AMOUNT) --월별 총 매출 합계 계산
                    FOR MONTH IN --MONTH 컬럼의 값을 열 이름으로 변환
                     ('JAN' AS JAN, 'FEB' AS FEB) --열 이름 지정 (별칭 가능)
                )
                ORDER BY PRODUCT;
                ```
            - | PRODUCT | JAN | FEB |
                |---------|-----|-----|
                | RADIO   | 300 | 400 |
                | TV      | 500 | 700 |
    2.  **PIVOT 절**
      - 열(Column) 형태의 데이터를 행(Row) 형태로 바꾸는 연산자. 즉, 열 → 행 변환을 수행.
      - 수행 과정 및 특징
        - PIVOT의 반대 개념으로, 열 데이터를 행으로 되돌리는 기능을 한다.
        - 여러 열에 나눠져 있는 데이터를 하나의 열로 모을 때 사용한다.
        - FOR 절에서 새로 생성할 열 이름을 지정할 수 있다.
        - 예시
            - | DEPTNO | MANAGER | CLERK | ENGINEER |
                |--------|---------|-------|----------|
                | 10     | 5000    | 3000  | 4000     |
                | 20     | 6000    | 2500  | 4200     |
            - ```sql
               SELECT DEPTNO, JOB, SAL
                FROM DEPT_SALARY  -- 1. DEPT_SALARY테이블에서
                UNPIVOT (
                    SAL FOR  -- 3. 해당 값을 SAL이라는 항목을 만들어 값을 담는다.
                    JOB IN (MANAGER, CLERK, ENGINEER) -- 2. MANAGER, CLERK, ENGINEER를 JOB이라는 속성으로 담고
                )
                ORDER BY DEPTNO, JOB; -- 4. 만든 새 테이블을 DEPTNO, JOB의 값으로 정렬
                ```
            - | DEPTNO | JOB      | SAL  |
                |--------|----------|------|
                | 10     | MANAGER  | 5000 |
                | 10     | CLERK    | 3000 |
                | 10     | ENGINEER | 4000 |
                | 20     | MANAGER  | 6000 |
                | 20     | CLERK    | 2500 |
                | 20     | ENGINEER | 4200 |

### 8. 정규 표현식

    - 문자열을 처리할 때, 패턴에 기반하여 검색, 치환, 추출 등을 수행 할 수 있는 표현법이다.
    - 메타 문자(meta character)와 리터럴 문자(literal character)를 조합하여 패턴을 구성함.
    - SQL에서도 LIKE보다 더 정교한 문자열 검색이 가능.

    1.  **메타문자**
      - | 메타 문자 | 의미                        | 예시                      |
        |-------|---------------------------|-------------------------|
        | \     | 메타 문자를 리터럴 문자로 표시 (이스케이프) | \\ → \                  |
        | ^     | 문자열의 시작                   | ^The → ‘The’로 시작하는 문자열  |
        | $     | 문자열의 끝                    | ing$ → ‘ing’으로 끝나는 문자열  |
        | .     | 임의의 한 문자 (개행 제외)          | a.b → a와 b 사이 아무 문자     |
        | ?     | 앞의 문자가 0개 또는 1개           | no? → ‘n’ 또는 ‘no’       |
        | *     | 앞의 문자가 0개 이상              | no* → ‘n’, ‘no’, ‘nooo’ |
        | +     | 앞의 문자가 1개 이상              | no+ → ‘no’, ‘noo’       |
    2.  **선택·범위 관련 메타 문자**
      - | 메타 문자 | 의미                    | 예시                               |
        |-------|-----------------------|----------------------------------|
        | `     | `                     | 선택적 일치                           |
        | []    | 대괄호 안의 문자 중 하나와 일치    | [abc] → ‘a’, ‘b’, ‘c’            |
        | [-]   | 연속 범위 지정              | [a-z] → ‘a’부터 ‘z’까지              |
        | [^ ]  | 대괄호 안의 문자 제외          | [^abc] → ‘a,b,c’ 제외한 문자          |
        | ()    | 괄호로 묶인 표현을 하나의 단위로 취급 | (ab)+ → ‘ab’, ‘abab’, ‘ababab’ 등 |
    3.  **리터럴 문자**
      - 자기 자신 그대로의 의미를 갖는 문자.
      - 정규표현식 안에서 특별한 의미가 없는 대부분의 문자들. **예시** a, 1, 가, @, _

    4.  **Oracle vs SQL Server의 정규표현식 지원 차이**
      - Oracle
        - | 함수             | 설명                   |
            |----------------|----------------------|
            | REGEXP_LIKE    | 정규표현식을 이용한 LIKE 연산   |
            | REGEXP_REPLACE | 정규표현식으로 문자열 대체       |
            | REGEXP_INSTR   | 정규표현식으로 검색 후 위치 반환   |
            | REGEXP_SUBSTR  | 정규표현식으로 부분 문자열 반환    |
            | REGEXP_COUNT   | 정규표현식으로 특정 패턴의 개수 반환 |
      - SQL Server
        - 정규표현식 함수는 직접 지원하지 않음.
        - 대신 PATINDEX 함수를 이용해 패턴 매칭 가능 (LIKE의 확장판 정도).
