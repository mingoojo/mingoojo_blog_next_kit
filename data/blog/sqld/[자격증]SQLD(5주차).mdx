---
title: '[SQLD 자격증 공부] Chaper4[part1] - SQL 활용 (WEEK 5)'
date: '2025-10-05'
tags: ['sqld', 'database', 'license']
draft: false
summary: SQLD 5주차 공부 내용을 정리.
---

import ImageWithCaption from '@/components/mdxComponents/ImageWithCaption'
import InternalLink from '@/components/mdxComponents/InternalLink'

### 1. 서브쿼리

    - 서브쿼리(Subquery) 는 쿼리(Query) 안에 또 다른 쿼리를 포함하는 것.
    - SELECT, INSERT, UPDATE, DELETE 문 안에서 하위 질의문을 작성하는 방식.
      - 메인쿼리(Main Query): 전체 결과를 반환하는 외부 쿼리
      - 서브쿼리(Sub Query): 메인쿼리의 일부로 먼저 실행되어 메인쿼리에 데이터를 제공
      - ```sql
        SELECT NAME, SALARY -- 메인 쿼리
        FROM EMP
        WHERE SALARY > ( -- 괄호안 => 서브쿼리 = 서브쿼리의 결과를 WHERE절로 사용하는 구문
            SELECT AVG(SALARY)
            FROM EMP
        );
        ```
    - 들어가는 위치에 따른 분류
      - | 구분       | 설명                       | 사용 위치         |
        |----------|--------------------------|---------------|
        | 스칼라 서브쿼리 | SELECT 절 안에서 1행 1열 반환    | SELECT        |
        | 인라인 뷰    | FROM절에 포함된 서브쿼리          | FROM          |
        | 중첩 서브쿼리  | WHERE, HAVING절에 포함된 서브쿼리 | WHERE, HAVING |


    1.  **스칼라 서브쿼리**
        > 각 행(row)에 대해 하나의 값만 계산해서 칼럼처럼 보여주는 서브쿼리

        - SELECT문의 칼럼이 입력되는 위치에 들어가는 서브쿼리
        - 스칼라 서브쿼리의 결과는 하나의 칼럼만 같는다.
        - ```sql
          SELECT NAME, --메인 쿼리
          ( --서브 쿼리(스칼라서브쿼리)
            SELECT DEPT_NAME
            FROM DEPT
            WHERE DEPT_ID = E.DEPT_ID
            ) AS DEPT_NAME
          FROM EMP E;
          ```
        - 같은의미의 조인 문으로 아래와 같이 표현할 수 있다.
          - ```sql
            SELECT E.NAME, D.DEPT_NAME
            FROM EMP E
            JOIN DEPT D
            ON E.DEPT_ID = D.DEPT_ID;
            ```
    2.  **인라인 뷰**

        >SELECT문 안에 잠깐 만들어 쓰는 즉석 테이블

        - FROM절의 테이블이 입력되는 위치에 들어가는 서브쿼리이다.
        - 쿼리 실행시 뷰(VIEW)와 같이 동적으로 생성되는 테이블
        - ```sql
          SELECT DEPT_ID, AVG_SAL --메인 쿼리
          FROM ( --서브 쿼리(인라인 뷰)
              SELECT DEPT_ID, AVG(SALARY) AS AVG_SAL
              FROM EMP
              GROUP BY DEPT_ID
          ) TEMP
          WHERE AVG_SAL >= 4000;
          ```
    3.  **중첩서브 쿼리**

        >조건을 만들기 위해 안쪽에서 먼저 SELECT 한 뒤, 그 결과를 바깥쪽 쿼리의 조건으로 사용하는 방식

        - 쿼리 안에 다른 쿼리가 중첩으로 들어간 경우를 지칭.
        - WHERE절과 HAVING절에 들어간 경우.
        - 반환값 유형에 따라 다음과 같이 분류된다.
          - | 구분        | 설명        | 사용 위치                  | 예시                                |
            |-----------|-----------|------------------------|-----------------------------------|
            | 단일행 중첩 서브쿼리  | 결과 1행만 반환 | WHERE                  | SALARY > (SELECT AVG(SALARY) ...) |
            | 다중행 중첩 서브쿼리  | 여러 행 반환   | WHERE + IN / ANY / ALL | DEPT_ID IN (SELECT DEPT_ID ...)   |
            | 다중컬럼 중첩 서브쿼리 | 여러 컬럼 비교  | WHERE                  | (DEPT_ID, SALARY) IN (...)        |
          - 단일행 중첩 서브쿼리 예시
            - ```sql
              SELECT NAME, SALARY --메인 쿼리: 그 평균보다 높은 급여를 가진 직원 조회
              FROM EMP
              WHERE SALARY > ( --내부 쿼리: 전체 직원의 평균 급여 계산
                  SELECT AVG(SALARY)
                  FROM EMP
              );
              ```
          - 다중행 중첩 서브쿼리 예시
            - ```sql
              SELECT NAME --	메인쿼리: 그 부서ID에 속한 직원만 조회
              FROM EMP
              WHERE DEPT_ID IN ( --서브쿼리: LOC_ID=100인 부서ID 목록 반환
                  SELECT DISTINCT DEPT_ID -- DISTINCT : 중복 제거
                  FROM DEPT
                  WHERE LOC_ID = 100
              );
              ```
          - 다중컬럼 중첩 서브쿼리 예시
            - ```sql
              SELECT NAME --	메인쿼리: 직업과 급여가 서브쿼리와 매칭되는 직원(직업별로 급여가 가장 높은 사람의 정보)를 출력한다.
              FROM EMP
              WHERE (JOB, SAL) IN ( --서브쿼리: 직업별로 가장 높은 급여를 출력
                  SELECT JOB, MAX(SAL)
                  FROM EMP
                  GROUP BY JOB
              );
              ```
          - HAVING절에서 중첩 서브쿼리 예시
            - ```sql
              SELECT DEPT_ID, AVG(SALARY) AS AVG_SAL
              FROM EMP
              GROUP BY DEPT_ID
              HAVING AVG(SALARY) > ( --HAVING절: 부서별 평균이 전체 평균보다 큰 부서만 필터링
                  SELECT AVG(SALARY) --서브쿼리: 전체 평균 급여 계산
                  FROM EMP
              );
              ```
    - 테이블과 뷰의 차이
      - | 구분       | 테이블 (Table)               | 뷰 (View)                        |
        |----------|---------------------------|---------------------------------|
        | 정의       | 실제 데이터가 저장되는 물리적 구조       | SELECT문 결과를 저장한 가상의 테이블         |
        | 저장 여부    | 데이터를 직접 저장                | 데이터 저장하지 않음 (조회 시 원본 테이블에서 가져옴) |
        | 생성 방식    | CREATE TABLE              | CREATE VIEW AS SELECT ...       |
        | 데이터 변경   | INSERT, UPDATE, DELETE 가능 | 일반적으로 불가능 (단, 단순 뷰는 가능)         |
        | 용도       | 데이터를 영구적으로 보관             | 데이터를 필터링/요약/보안 목적 으로 보여줌        |
        | 성능       | 빠름 (실제 데이터에 접근)           | 상대적으로 느림 (실시간으로 원본에서 읽음)        |
        | 삭제 명령어   | DROP TABLE                | DROP VIEW                       |
        | 공간 차지 여부 | 실제 디스크 공간 사용              | 거의 없음 (SELECT 정의문만 저장됨)         |

### 2. 집합연산자

    - 두 테이블에 대한 집합연산(합집합, 교집합 등)을 수행하는 연산자이다.
    - JOIN과 달리 기준이 되는 키(기준 칼럼/속성)가 없이 집합 연산을 수행한다.
    - 두 테이블의 <InternalLink link="schema" name="스키마"/>가 동일해야한다.
    - 집합 연산자 종류
        - | 연산자               | 설명                | 특징                        |
          |-------------------|-------------------|---------------------------|
          | UNION             | 두 결과를 합집합 (중복 제거) | 기본값: DISTINCT             |
          | UNION ALL         | 합집합 (중복 포함)       | 빠름, 중복 제거 X               |
          | INTERSECT         | 교집합               | 양쪽 SELECT 모두에 존재하는 행      |
          | MINUS (또는 EXCEPT) | 차집합               | 첫 번째 SELECT 결과에서 두 번째를 제외 |

    1.  **UNION/ UNION ALL**
        >합집합 연산을 수행
        - 두 테이블에 모든 레코드를 포함시키는 연산을 진행한다.
        - UNION은 중복을 제거, UNION ALL은 중복을 허락한다. 그래서 UNION ALL에서는 값이 같은 항목이 여러개 존재할 수 있다.
        - 예시
            - | EMP_ID | NAME | DEPT |
              |--------|------|------|
              | 1      | 민수   | 개발팀  |
              | 2      | 지현   | 인사팀  |
              | 3      | 영호   | 개발팀  |
            - | EMP_ID | NAME | DEPT |
              |--------|------|------|
              | 4      | 하나   | 개발팀  |
              | 5      | 사토   | 인사팀  |
              | 6      | 민수   | 개발팀  |

            - UNION(합집합, 중복 제거)
              - ```sql
                SELECT NAME, DEPT FROM EMP_A
                UNION
                SELECT NAME, DEPT FROM EMP_B;
                ```
              - | NAME | DEPT |
                |------|------|
                | 민수   | 개발팀  |
                | 지현   | 인사팀  |
                | 영호   | 개발팀  |
                | 하나   | 개발팀  |
                | 사토   | 인사팀  |
            - UNION ALL(합집합, 중복 허락)
              - ```sql
                SELECT NAME, DEPT FROM EMP_A
                UNION ALL
                SELECT NAME, DEPT FROM EMP_B;
                ```
              - | NAME | DEPT |
                |------|------|
                | 민수   | 개발팀  |
                | 지현   | 인사팀  |
                | 영호   | 개발팀  |
                | 하나   | 개발팀  |
                | 사토   | 인사팀  |
                | 민수   | 개발팀  |

    2.  **INTERSECT**
        >교집합 연산을 수행
        - 두 테이블에 공통 포함 레코드만 출력
        - 예시
            - ```sql
              SELECT NAME, DEPT FROM EMP_A
              INTERSECT
              SELECT NAME, DEPT FROM EMP_B;
              ```
            - | NAME | DEPT |
              |------|------|
              | 민수   | 개발팀  |
    3.  **MINUS / EXCEPT**
        >차집합 연산을 수행
        - 왼쪽 테이블에서 두 테이블에 공통적으로 포함되는 레코드를 제외한 값을 출력
        - 예시
            - ```sql
              SELECT NAME, DEPT FROM EMP_A
              MINUS--DBMS에따라 MINUS대신 EXCEPT를 사용
              SELECT NAME, DEPT FROM EMP_B;
              ```
            - | NAME | DEPT |
              |------|------|
              | 지현   | 인사팀  |
              | 영호   | 개발팀  |

### 3. 그룹함수

    - GROUP BY절에 따른 결과에 대해서 그룹 별로 연산을 수행하는 함수.
    - 해당 그룹에 집계함수(갯수, 합, 평균, 최댓값, 최솟값)와 함께 ROLLUP, CUBE등의 함수가 여기에 포함된다.
    1. ROLLUP
        - GROUP BY절에 들어가는 칼럼을 대상으로 하위 그룹핑을 수행하는 함수.
        - 소계와 총계를 구할 때 사용.
        - 예시
          - | DEPT  | JOB     | TOTAL_SAL |
            |-------|---------|-----------|
            | HR    | CLERK   | 1200      |
            | IT    | ANALYST | 3000      |
            | IT    | CLERK   | 1500      |
            | SALES | CLERK   | 1000      |
            | SALES | MANAGER | 4500      |
          - ```sql
            SELECT DEPT, JOB, SUM(SAL) AS TOTAL_SAL
            FROM EMP
            GROUP BY ROLLUP(DEPT, JOB);
            ```
          - | DEPT  | JOB     | TOTAL_SAL             |
            |-------|---------|-----------------------|
            | HR    | CLERK   | 1200                  |
            | HR    | NULL    | 1200 ⬅ (HR 부서의 소계)    |
            | IT    | ANALYST | 3000                  |
            | IT    | CLERK   | 1500                  |
            | IT    | NULL    | 4500 ⬅ (IT 부서의 소계)    |
            | SALES | CLERK   | 1000                  |
            | SALES | MANAGER | 4500                  |
            | SALES | NULL    | 5500 ⬅ (SALES 부서의 소계) |
            | NULL  | NULL    | 11200 ⬅ (전체 총계)       |
          - 정리
            - 목적 : 하위 그룹별 소계와 총계를 자동 계산
            - 사용 위치 : GROUP BY ROLLUP(컬럼1, 컬럼2, …)
            - NULL 의미 : 소계 또는 총계 행
            - 특징
              - ROLLUP 안 컬럼 순서가 계층 구조를 결정함
              - **집계 함수**(SUM(), COUNT(), AVG(), MAX(), MIN())이 있어야 ROLLUP이 작동
    2. CUBE
        - ROLLUP과 달리 조합가능한 모든 경우의 수로 그룹핑을 진행하여 집계 결과값을 반환한다.
          - 예시
            - | DEPT  | JOB     | TOTAL_SAL |
              |-------|---------|-----------|
              | HR    | CLERK   | 1200      |
              | IT    | ANALYST | 3000      |
              | IT    | CLERK   | 1500      |
              | SALES | CLERK   | 1000      |
              | SALES | MANAGER | 4500      |
            - ```sql
              SELECT DEPT, JOB, SUM(SAL) AS TOTAL_SAL
              FROM EMP
              GROUP BY CUBE(DEPT, JOB);
              ```
            - | DEPT  | JOB     | TOTAL_SAL | 설명                         |
              |-------|---------|-----------|----------------------------|
              | HR    | CLERK   | 1200      | HR 부서, CLERK 직급 합계         |
              | HR    | NULL    | 1200      | HR 부서 전체 합계                |
              | IT    | ANALYST | 3000      | IT 부서, ANALYST 직급 합계       |
              | IT    | CLERK   | 1500      | IT 부서, CLERK 직급 합계         |
              | IT    | NULL    | 4500      | IT 부서 전체 합계                |
              | SALES | CLERK   | 1000      | SALES 부서, CLERK 직급 합계      |
              | SALES | MANAGER | 4500      | SALES 부서, MANAGER 직급 합계    |
              | SALES | NULL    | 5500      | SALES 부서 전체 합계             |
              | NULL  | CLERK   | 3700      | 직급별 소계 (모든 부서의 CLERK 합계)   |
              | NULL  | MANAGER | 4500      | 직급별 소계 (모든 부서의 MANAGER 합계) |
              | NULL  | ANALYST | 3000      | 직급별 소계 (모든 부서의 ANALYST 합계) |
              | NULL  | NULL    | 11200     | 전체 총계                      |
          - 정리
            - 목적 : 모든 컬럼 조합별 집계 결과 생성
            - 사용 위치 : GROUP BY CUBE(컬럼1, 컬럼2, …)
            - NULL 의미 : 소계 또는 총계 행
            - 특징
              - ROLLUP은 “단계적 합계”, CUBE는 “모든 조합 합계”
              - **집계 함수**(SUM(), COUNT(), AVG(), MAX(), MIN())이 있어야 CUBE가 작동
    3. GROUPING SET
        - 그룹핑할 대상을 지정하는 함수
        - 여러 GROUP BY 쿼리를 UNION ALL로 합친 것과 같은 결과를
          - 예시
            - | DEPT  | JOB     | TOTAL_SAL |
              |-------|---------|-----------|
              | HR    | CLERK   | 1200      |
              | IT    | ANALYST | 3000      |
              | IT    | CLERK   | 1500      |
              | SALES | CLERK   | 1000      |
              | SALES | MANAGER | 4500      |
            - ```sql
              SELECT DEPT, JOB, SUM(SAL) AS TOTAL_SAL
              FROM EMP
              GROUP BY GROUPING SETS (DEPT, JOB);
              ```
            - | DEPT  | JOB     | TOTAL_SAL | 설명     |
              |-------|---------|-----------|--------|
              | HR    | NULL    | 1200      | 부서별 합계 |
              | IT    | NULL    | 4500      | 부서별 합계 |
              | SALES | NULL    | 5500      | 부서별 합계 |
              | NULL  | CLERK   | 3700      | 직급별 합계 |
              | NULL  | MANAGER | 4500      | 직급별 합계 |
              | NULL  | ANALYST | 3000      | 직급별 합계 |
    3. GROUPING
        > 집계 결과에 나타나는 NULL 값이 **실제 데이터의 NULL**인지,아니면 **소계/총계 행을 의미하는 NULL**인지를 구분
        - 집계 결과(ROLLUP, CUBE, GROUPING SETS 등)에서 해당 컬럼이 실제 그룹에 포함되었는지(또는 집계된 결과인지) 를 구분할 때 사용
        - 기본문법
          - ```sql
            SELECT 컬럼1, 컬럼2, SUM(컬럼3),
            GROUPING(컬럼1) AS G1,
            GROUPING(컬럼2) AS G2
            FROM 테이블
            GROUP BY ROLLUP(컬럼1, 컬럼2);
            ```
          - 예시
            - | DEPT  | JOB     | SAL  |
              |-------|---------|------|
              | SALES | CLERK   | 1000 |
              | SALES | MANAGER | 2500 |
              | IT    | CLERK   | 1500 |
              | IT    | ANALYST | 3000 |
            - ```sql
              SELECT
                DEPT,
                JOB,
                SUM(SAL) AS TOTAL_SAL,
                GROUPING(DEPT) AS G_DEPT,
                GROUPING(JOB) AS G_JOB
              FROM EMP
              GROUP BY ROLLUP(DEPT, JOB);
              ```
            - | DEPT  | JOB     | TOTAL_SAL | G_DEPT | G_JOB | 설명(출력 속성 X)     |
              |-------|---------|-----------|--------|-------|--------|
              | IT    | ANALYST | 3000      | 0      | 0     | 실제 데이터 |
              | IT    | CLERK   | 1500      | 0      | 0     | 실제 데이터 |
              | IT    | NULL    | 4500      | 0      | 1     | 부서별 소계 |
              | SALES | CLERK   | 1000      | 0      | 0     | 실제 데이터 |
              | SALES | MANAGER | 2500      | 0      | 0     | 실제 데이터 |
              | SALES | NULL    | 3500      | 0      | 1     | 부서별 소계 |
              | NULL  | NULL    | 8000      | 1      | 1     | 전체 총계  |

### 4. 윈도우함수

    - 행과 행간의 관계를 나타내는 연산을 쉽게하기 위한 함수
    - 집계 함수(또는 순위 함수) + 행 단위 결과를 함께 보여주는 함수

    >GROUP BY 집계와 달리 행이 줄어들지 않고,각 행을 기준으로 주변 행들을 포함해 계산한 결과를 같은 행에 표시.

    1. OVER 절
        - OVER() 절은 윈도우 함수가 계산되는 기준과 범위를 지정하는 구문
        - 이 함수를 어떤 그룹(PARTITION) 안에서, 어떤 순서(ORDER), 어떤 범위(ROWS)로 계산할지 정한다.
          - OVER 절 기본 구조
              - ```sql
                함수() OVER (
                    [PARTITION BY ...]
                    [ORDER BY ...]
                    [ROWS | RANGE ...]
                )
                ```
              - | 사용 형태                                                        | 설명                  | 예시                                                                                     |
                |--------------------------------------------------------------|---------------------|----------------------------------------------------------------------------------------|
                | OVER()                                                       | 전체 데이터를 하나의 윈도우로 계산 | SUM(SAL) OVER()                                                                        |
                | OVER(PARTITION BY ...)                                       | 그룹 단위로 나누어 계산       | SUM(SAL) OVER(PARTITION BY DEPT)                                                       |
                | OVER(ORDER BY ...)                                           | 전체 데이터에 순서를 매겨 계산   | RANK() OVER(ORDER BY SAL DESC)                                                         |
                | OVER(PARTITION BY ... ORDER BY ...)                          | 그룹 내부에서 순서를 매겨 계산   | RANK() OVER(PARTITION BY DEPT ORDER BY SAL DESC)                                       |
                | OVER(ORDER BY ... ROWS BETWEEN ... AND ...)                  | 순서 + 특정 행 범위에서 계산   | SUM(SAL) OVER(ORDER BY SAL ROWS BETWEEN 1 PRECEDING AND CURRENT ROW)                   |
                | OVER(PARTITION BY ... ORDER BY ... ROWS BETWEEN ... AND ...) | 그룹 내 특정 행 범위 계산     | AVG(SAL) OVER(PARTITION BY DEPT ORDER BY SAL ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) |
                1.  PARTITION BY
                    - 데이터를 논리적으로 그룹(파티션) 으로 나누어 윈도우 함수 적용.
                    - ```sql
                        AVG(SAL) OVER(PARTITION BY DEPT)
                      ```
                2.  ORDER BY
                    - 각 파티션 내부에서 순서를 지정.
                    - RANK(), ROW_NUMBER(), LAG(), LEAD() 등에 필수.
                    - ```sql
                        RANK() OVER(ORDER BY SAL DESC)
                      ```
    2. 순위 함수
        - 순위를 계산하는 함수로, RANK, DENSE_RANK, ROW_NUMBER가 있다.
        - | 함수           | 동점 처리        | 순위 건너뜀    | 특징                |
          |--------------|--------------|-----------|-------------------|
          | RANK()       | 같은 값이면 같은 순위 | ✅ 건너뜀     | 경기 등수(1, 1, 3, 4) |
          | DENSE_RANK() | 같은 값이면 같은 순위 | ❌ 건너뛰지 않음 | 1, 1, 2, 3 처럼 연속  |
          | ROW_NUMBER() | 항상 고유한 번호    | ❌ 건너뛰지 않음 | 행마다 고유번호(1,2,3,4) |

    3. 집계 함수
        - 일반적인 집계함수와 비슷하나 OVER절을 활용하여 파티션별로 집계, 누적 집계할 수 있다.
        - GROUP BY와 달리 그룹별로 하나의 행으로 줄이는 게 아니라 모든 행을 그대로 유지하면서 집계값을 함께 보여준다
        - 기본문법
          - ```sql
              집계함수(컬럼) OVER (
                [PARTITION BY ...]
                [ORDER BY ...]
                [ROWS | RANGE ...]
              )
            ```

    4. 행순서 함수
        - | 함수            | 설명          | 예시       |
          |---------------|-------------|----------|
          | LAG()         | 이전 행 값      | 전월 대비 비교 |
          | LEAD()        | 다음 행 값      | 다음 행과 비교 |
          | FIRST_VALUE() | 그룹 내 첫 번째 값 | 가장 낮은 급여 |
          | LAST_VALUE()  | 그룹 내 마지막 값  | 가장 높은 급여 |


    5. 윈도우 함수 예시
        - 기본 문법
          - ```sql
              함수명(컬럼명) OVER (
              PARTITION BY 컬럼A
              ORDER BY 컬럼B
              ROWS BETWEEN ~
              )
            ```
          - | 구성 요소            | 설명                                   |
            |------------------|--------------------------------------|
            | 함수명()            | 사용할 윈도우 함수 (SUM, AVG, ROW_NUMBER, 등) |
            | OVER             | 윈도우 함수임을 명시                          |
            | PARTITION BY     | 그룹 기준 (GROUP BY와 유사)                 |
            | ORDER BY         | 정렬 기준 (순서 정의)                        |
            | ROWS BETWEEN ... | 윈도우 범위 설정 (생략 시 기본은 “처음부터 현재 행까지”)   |
          - 예시
              - | DEPT  | ENAME | SAL  |
                |-------|-------|------|
                | SALES | A     | 1000 |
                | SALES | B     | 1200 |
                | SALES | C     | 1500 |
                | IT    | D     | 2000 |
                | IT    | E     | 3000 |
                - ```sql
                  --누적합 구하기
                  SELECT
                    DEPT,
                    ENAME,
                    SAL,
                    SUM(SAL) OVER (PARTITION BY DEPT ORDER BY SAL) AS CUM_SAL
                  FROM EMP;
                  ```
                - | DEPT  | ENAME | SAL  | CUM_SAL |
                  |-------|-------|------|---------|
                  | IT    | D     | 2000 | 2000    |
                  | IT    | E     | 3000 | 5000    |
                  | SALES | A     | 1000 | 1000    |
                  | SALES | B     | 1200 | 2200    |
                  | SALES | C     | 1500 | 3700    |
                - ```sql
                  --순위 구하기
                  SELECT
                    ENAME,
                    DEPT,
                    SAL,
                    RANK() OVER (PARTITION BY DEPT ORDER BY SAL DESC) AS RANK,
                    DENSE_RANK() OVER (PARTITION BY DEPT ORDER BY SAL DESC) AS D_RANK,
                    ROW_NUMBER() OVER (PARTITION BY DEPT ORDER BY SAL DESC) AS ROW_NUM
                  FROM EMP;
                  ```
                - | DEPT  | ENAME | SAL  | RANK | D_RANK | ROW_NUM |
                  |-------|-------|------|------|--------|---------|
                  | IT    | E     | 3000 | 1    | 1      | 1       |
                  | IT    | D     | 2000 | 2    | 2      | 2       |
                  | SALES | C     | 1500 | 1    | 1      | 1       |
                  | SALES | B     | 1200 | 2    | 2      | 2       |
                  | SALES | A     | 1000 | 3    | 3      | 3       |
                - ```sql
                  --평균 비교
                  SELECT
                    DEPT,
                    ENAME,
                    SAL,
                    AVG(SAL) OVER (PARTITION BY DEPT) AS AVG_SAL
                  FROM EMP;
                  ```
                - | DEPT  | ENAME | SAL  | AVG_SAL |
                  |-------|-------|------|---------|
                  | IT    | D     | 2000 | 2500    |
                  | IT    | E     | 3000 | 2500    |
                  | SALES | A     | 1000 | 1233    |
                  | SALES | B     | 1200 | 1233    |
                  | SALES | C     | 1500 | 1233    |
                - ```sql
                  --이전 다음 행 조회
                  SELECT
                    ENAME,
                    SAL,
                    LAG(SAL) OVER (ORDER BY SAL) AS PREV_SAL,
                    LEAD(SAL) OVER (ORDER BY SAL) AS NEXT_SAL
                  FROM EMP;
                  ```
                - | ENAME | SAL  | PREV_SAL | NEXT_SAL |
                  |-------|------|----------|----------|
                  | A     | 1000 | NULL     | 1200     |
                  | B     | 1200 | 1000     | 1500     |
                  | C     | 1500 | 1200     | 2000     |
                  | D     | 2000 | 1500     | 3000     |
                  | E     | 3000 | 2000     | NULL     |
